<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_datachannel_server.js.html":{"id":"lib_datachannel_server.js.html","title":"Source: lib/datachannel/server.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/datachannel/server.js 'use strict'; var BinaryServer = require('binaryjs').BinaryServer; var assert = require('assert'); var Transport = require('../network/transport'); var Manager = require('../manager'); var events = require('events'); var inherits = require('util').inherits; var ms = require('ms'); var crypto = require('crypto'); var utils = require('../utils'); /** * Creates a data channel server for sending and receiving consigned file shards * @constructor * @param {Object} options * @param {Transport} options.transport - Transport adapter from {@link Network} * @param {Manager} options.manager - The Manager from {@link Network} * @param {kad.Logger} options.logger - Logger to use from {@link Network} * @param {Number} options.ttl - Close after idle for this length of time */ function DataChannelServer(options) { if (!(this instanceof DataChannelServer)) { return new DataChannelServer(options); } assert.ok(options, 'No options were supplied to constructor'); assert(options.transport instanceof Transport, 'Invalid transport adapter'); assert(options.manager instanceof Manager, 'Invalid manager supplied'); assert.ok(options.logger, 'Invalid logger supplied'); events.EventEmitter.call(this); this._transport = options.transport; this._manager = options.manager; this._log = options.logger; this._ttl = options.ttl || ms('2m'); this._server = new BinaryServer({ server: this._transport._server }); this._allowed = {}; this._server.on('connection', this._handleConnection.bind(this)); this._server.on('error', this._handleError.bind(this)); } inherits(DataChannelServer, events.EventEmitter); /** * Begin accepting data for the given file hash and token * @param {String} token - The authorization token created for transfer * @param {String} filehash - The shard hash to allow for the token */ DataChannelServer.prototype.accept = function(token, filehash) { assert(typeof token === 'string', 'Invalid token supplied'); assert(typeof filehash === 'string', 'Invalid filehash supplied'); this._allowed[token] = { hash: filehash, client: null }; }; /** * Stop accepting data for the given token * @param {String} token - The authorization token created for transfer */ DataChannelServer.prototype.reject = function(token) { assert(typeof token === 'string', 'Invalid token supplied'); if (this._allowed[token]) { if (this._allowed[token].client) { this._allowed[token].client.close(); } delete this._allowed[token]; } }; /** * Closes the data channel and disconnects all clients */ DataChannelServer.prototype.close = function() { return this._server.close(); }; /** * Handles incoming connections * @private * @param {BinaryClient} client - The connected client object */ DataChannelServer.prototype._handleConnection = function(client) { var self = this; this._log.info('data channel connection opened'); this.emit('connection', client); client.on('error', function(err) { self._log.error('data channel connection error: %s', err.message); client.close(); }); client.on('stream', function(stream, meta) { self._log.info('receiving stream from client'); var token = meta.token; var hash = meta.hash; var operation = meta.operation; try { assert.ok(token, 'You did not supply a token'); assert.ok(self._allowed[token], 'The supplied token is not accepted'); assert.ok(hash, 'You did not supply the data hash'); assert(self._allowed[token].client === null, 'Channel is already active'); assert(self._allowed[token].hash === hash, 'Token not valid for hash'); } catch (err) { stream.write({ message: err.message, error: true }); return client.close(); } self._allowed[token].client = client; switch (operation) { case 'PUSH': return self._handleConsignStream(stream, token); case 'PULL': return self._handleRetrieveStream(stream, token); default: return self._handleUnknownStream(stream, token); } }); }; /** * Receives the data stream and writes it to storage * @private * @param {stream.Readable} stream - The incoming data stream * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleConsignStream = function(stream, token) { var self = this; var hasher = crypto.createHash('sha256'); var hash = this._allowed[token].hash; this._manager.load(hash, function(err, item) { if (err) { stream.write({ error: true, message: err.message }); return self.reject(token); } // If the shard is not writable, it means we already have it, so let's // just respond with a success message if (typeof item.shard.write !== 'function') { stream.write({ error: false, message: 'Consignment completed successfully' }); return self.reject(token); } stream.on('data', function(chunk) { hasher.update(chunk); item.shard.write(chunk); }); stream.on('end', function() { if (utils.rmd160(hasher.digest('hex')) !== hash) { stream.write({ error: true, message: 'Calculated hash does not match the expected result' }); return self.reject(token); } item.shard.end(); stream.write({ error: false, message: 'Consignment completed successfully' }); self.reject(token); }); }); }; /** * Pumps the data through to the client * @private * @param {stream.Readable} stream - The incoming data stream * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleRetrieveStream = function(stream, token) { var self = this; var hash = this._allowed[token].hash; this._manager.load(hash, function(err, item) { if (err) { stream.write({ error: true, message: err.message }); return self.reject(token); } var filestream = item.shard.pipe(stream); filestream.on('end', function() { stream.end(); self.reject(token); }); }); }; /** * Closes the stream if it cannot be handled * @private * @param {stream.Readable} stream - The incoming data stream * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleUnknownStream = function(stream, token) { var client = this._allowed[token].client; client.send({ error: true, message: 'Failed to handle the defined operation' }); this.reject(token); }; /** * Handles binary server errors * @private * @param {Error} err - The error object */ DataChannelServer.prototype._handleError = function(err) { this._log.error('data channel server encountered an error: %s', err.message); this.emit('error', err); }; module.exports = DataChannelServer; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: index.js /** * @module storjnode */ 'use strict'; module.exports = { version: require('./package').version }; /** {@link Network} */ module.exports.Network = require('./lib/network'); /** {@link DataChannelClient} */ module.exports.DataChannelClient = require('./lib/datachannel/client'); /** {@link DataChannelServer} */ module.exports.DataChannelServer = require('./lib/datachannel/server'); /** {@link Protocol} */ module.exports.Protocol = require('./lib/network/protocol'); /** {@link Contract} */ module.exports.Contract = require('./lib/contract'); /** {@link Audit} */ module.exports.Audit = require('./lib/audit'); /** {@link Proof} */ module.exports.Proof = require('./lib/proof'); /** {@link Verification} */ module.exports.Verification = require('./lib/verification'); /** {@link Manager} */ module.exports.Manager = require('./lib/manager'); /** {@link StorageAdapter} */ module.exports.StorageAdapter = require('./lib/storage/adapter'); /** {@link FSStorageAdapter} */ module.exports.FSStorageAdapter = require('./lib/storage/adapters/fs'); /** {@link RAMStorageAdapter} */ module.exports.RAMStorageAdapter = require('./lib/storage/adapters/ram'); /** {@link StorageItem} */ module.exports.StorageItem = require('./lib/storage/item'); /** {@link KeyPair} */ module.exports.KeyPair = require('./lib/keypair'); /** {@link constants} */ module.exports.constants = require('./lib/constants'); /** {@link utils} */ module.exports.utils = require('./lib/utils'); × Search results Close "},"lib_audit.js.html":{"id":"lib_audit.js.html","title":"Source: lib/audit.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/audit.js 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var constants = require('./constants'); var MerkleTree = require('mtree'); var merge = require('merge'); var utils = require('./utils'); /** * Represents an auditing interface using a precomputed merkle tree * @constructor * @param {Object} options * @param {Number} options.audits - Total number of challenges to generate * @param {Buffer} options.shard - Data to create audit challenges for */ function Audit(options) { if (!(this instanceof Audit)) { return new Audit(options); } options = merge(Object.create(Audit.DEFAULTS), options); assert(Buffer.isBuffer(options.shard), 'Invalid shard supplied'); assert( options.audits &gt; 0 &amp;&amp; (options.audits % 2 === 0), 'Must supply an even audits value greater than 0' ); this._shard = options.shard; this._audits = options.audits; this._challenges = []; this._tree = this._generateTree(); } Audit.DEFAULTS = { audits: 12, shard: new Buffer([]), }; /** * Returns the bottom leaves of the merkle tree for sending to farmer * @returns {Array} leaves - Bottom merkle leaves of audit tree */ Audit.prototype.getPublicRecord = function() { return this._tree.level(this._tree.levels() - 1); }; /** * Returns the challenges, the tree depth, and merkle root * @returns {Object} challenge - Private audit record with challenges */ Audit.prototype.getPrivateRecord = function() { return { root: this._tree.root(), depth: this._tree.levels(), challenges: this._challenges }; }; /** * Generate the audit merkle tree from a series of challenges * @private * @returns {Audit} self */ Audit.prototype._generateTree = function() { var iterations = 0; var inputs = []; while (iterations &lt; this._audits) { var challenge = this._generateChallenge(); var input = this._createResponseInput(challenge); this._challenges.push(challenge); inputs.push(input); iterations++; } while (iterations &lt; utils.getNextPowerOfTwo(this._audits)) { inputs.push(utils.rmd160sha256('')); iterations++; } return new MerkleTree(inputs, utils.rmd160sha256); }; /** * Generate a random challenge buffer * @private * @returns {String} Hex encoded random bytes */ Audit.prototype._generateChallenge = function() { return crypto.randomBytes(constants.AUDIT_BYTES).toString('hex'); }; /** * Create a challenge response input to merkle tree * @private * @param {Array} response * @returns {Buffer} input - Concatenated challenge+shard_hash */ Audit.prototype._createResponseInput = function(challenge) { return utils.rmd160sha256(utils.rmd160sha256( challenge + this._shard.toString('hex') )); }; module.exports = Audit; × Search results Close "},"lib_constants.js.html":{"id":"lib_constants.js.html","title":"Source: lib/constants.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/constants.js /** * @module storj/constants */ 'use strict'; module.exports = { /** @constant {Number} PREFIX - NodeID prefix (same as bitcoin) */ PREFIX: 0x00, /** @constant {Number} NONCE_EXPIRE - Time to honor a signed message */ NONCE_EXPIRE: 10000, /** @constant {Number} AUDIT_BYTES - Number of bytes for audit challenge */ AUDIT_BYTES: 32, }; × Search results Close "},"lib_contract_index.js.html":{"id":"lib_contract_index.js.html","title":"Source: lib/contract/index.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/contract/index.js 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var merge = require('merge'); var JSONSchema = require('jsen'); var stringify = require('json-stable-stringify'); var bitcore = require('bitcore-lib'); var Message = require('bitcore-message'); /** * Represents a storage contract between a renter and a farmer * @constructor * @version 0 * @param {Object} contract * @param {String} contract.type - Unique identifier for the contract * @param {String} contract.renter_id - Node ID of the renter * @param {String} contract.renter_signature - Renter's cryptographic signature * @param {String} contract.farmer_id - Node ID of the farmer * @param {String} contract.farmer_signature - Farmer's cryptographic signature * @param {Number} contract.data_size - Number of bytes to store * @param {String} contract.data_hash - RIPEMD-160 SHA-256 hash of the data * @param {Number} contract.store_begin - UNIX timestamp to start contract * @param {Number} contract.store_end - UNIX timestamp to end the contract * @param {Number} contract.audit_count - Number of audits renter will perform * @param {Number} contract.payment_storage_price - Total price for storage * @param {Number} contract.payment_download_price - Price per download * @param {String} contract.payment_destination - Bitcoin address to send funds */ function Contract(contract) { if (!(this instanceof Contract)) { return new Contract(contract); } this._properties = merge(Object.create(Contract.DEFAULTS), contract); this._validator = Contract.createValidator(); this._clean(); assert.ok(this._validate(), 'Invalid contract specification was supplied'); } /** * Defines the JSON Schema of a {@link Contract} * @static */ Contract.Schema = require('./schema.json'); /** * Defines some default properties of a {@link Contract} * @static */ Contract.DEFAULTS = { type: '56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d', renter_id: null, renter_signature: null, farmer_id: null, farmer_signature: null, data_size: 1234, data_hash: null, store_begin: 2000000000, store_end: 3000000000, audit_count: 10, payment_storage_price: 0, payment_download_price: 0, payment_destination: null }; /** * Removes all properties not in the schema from contract * @private * @returns {Contract} self */ Contract.prototype._clean = function() { var keys = Object.keys(Contract.Schema.properties); for (var field in this._properties) { if (keys.indexOf(field) === -1) { delete this._properties[field]; } } return this; }; /** * Validates the contract specification * @private * @returns {Boolean} validity */ Contract.prototype._validate = function() { return this._validator(this._properties); }; /** * Checks if the contract is complete * @private * @returns {Boolean} completed */ Contract.prototype._complete = function() { for (var prop in this._properties) { if (this._properties[prop] === null) { return false; } } return true; }; /** * Returns the string representation of the contract, minus the signature * fields, sorted alphanumerically for signing and verifying * @private * @returns {String} */ Contract.prototype._getSigningData = function() { var sorted = this.toObject(); delete sorted.renter_signature; delete sorted.farmer_signature; return stringify(sorted); }; /** * Signs the contract as the given actor * @param {String} actor - One of 'farmer' or 'renter' * @param {Buffer} secret - ECDSA private key * @returns {String} signature */ Contract.prototype.sign = function(actor, secret) { var property = actor + '_signature'; var message = Message(this._getSigningData()); var signature = message.sign(bitcore.PrivateKey.fromString(secret)); return this.set(property, signature); }; /** * Verify the contract signature for the given actor * @param {String} actor - One of 'farmer' or 'renter' * @param {Buffer} pubkeyhash - ECDSA nodeID * @returns {Boolean} validity */ Contract.prototype.verify = function(actor, pubkeyhash) { var property = actor + '_signature'; var message = Message(this._getSigningData()); var address = bitcore.Address.fromPublicKeyHash(Buffer(pubkeyhash, 'hex')); return message.verify(address, this.get(property)); }; /** * Applies the provided fields to the contract and validates it * @param {Object} fields - Contract properties to update * @returns {Contract} self */ Contract.prototype.update = function(fields) { for (var prop in fields) { this.set(prop, fields[prop]); } return this; }; /** * Returns the value for the given contract property * @param {String} field_name - Contract property to get * @returns {String|Number|null} value */ Contract.prototype.get = function(field_name) { return this._properties[field_name]; }; /** * Sets the contract property to the given value * @param {String} field_name - Contract property to get * @returns {String|Number|null} value */ Contract.prototype.set = function(field_name, field_value) { this._properties[field_name] = field_value; this._clean(); assert.ok(this._validate(), 'Invalid contract property supplied'); return this._properties[field_name]; }; /** * Calculates the SHA-256 hash of the serialized contract * @returns {Buffer} */ Contract.prototype.getHash = function() { return crypto.createHash('sha256').update(this.toBuffer()).digest(); }; /** * Converts the contract to a plain object * @returns {Object} */ Contract.prototype.toObject = function() { return JSON.parse(this.toJSON()); }; /** * Converts the contract to JSON string * @returns {String} */ Contract.prototype.toJSON = function() { return stringify(this._properties); }; /** * Converts the contract to Buffer * @returns {Buffer} */ Contract.prototype.toBuffer = function() { return new Buffer(this.toJSON(), 'utf8'); }; /** * Creates a contract from a plain object * @param {Object} object - Dictionary of contract data * @returns {Contract} */ Contract.fromObject = function(object) { return new Contract(object); }; /** * Creates a contract from a JSON string * @param {String} json - JSON encoded contract * @returns {Contract} */ Contract.fromJSON = function(json) { return new Contract(JSON.parse(json)); }; /** * Creates a contract from a Buffer * @param {Buffer} buffer - Raw binary blob of contract data * @returns {Contract} */ Contract.fromBuffer = function(buffer) { return new Contract(JSON.parse(buffer.toString('utf8'))); }; /** * Creates a validator function for data against the schema * @returns {Function} validator */ Contract.createValidator = function() { return JSONSchema(Contract.Schema); }; /** * Compares two contracts against each other * @param {Contract} c1 - Contract to compare * @param {Contract} c2 - Contract to compare * @returns {Boolean} */ Contract.compare = function(c1, c2) { var contract1 = c1.toObject(); var contract2 = c2.toObject(); var ignored = [ 'renter_id', 'renter_signature', 'farmer_id', 'farmer_signature', 'payment_destination' ]; ignored.forEach(function(prop) { delete contract1[prop]; delete contract2[prop]; }); return JSON.stringify(contract1) === JSON.stringify(contract2); }; module.exports = Contract; × Search results Close "},"lib_datachannel_client.js.html":{"id":"lib_datachannel_client.js.html","title":"Source: lib/datachannel/client.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/datachannel/client.js 'use strict'; var BinaryClient = require('binaryjs').BinaryClient; var assert = require('assert'); var events = require('events'); var inherits = require('util').inherits; var url = require('url'); var utils = require('../utils'); /** * Creates a data channel client for sending and receiving consigned file shards * @constructor * @param {Object} contact * @param {String} contact.address - The address of the target farmer * @param {Number} contact.port - The port of the target farmer */ function DataChannelClient(contact) { if (!(this instanceof DataChannelClient)) { return new DataChannelClient(contact); } assert.ok(contact, 'No contact was supplied to constructor'); assert(typeof contact.address === 'string', 'Invalid contact address'); assert(typeof contact.port === 'number', 'Invalid contact port'); events.EventEmitter.call(this); this._contact = contact; this._client = new BinaryClient(DataChannelClient.getChannelURL(contact)); this._client.on('open', this._handleChannelOpen.bind(this)); this._client.on('error', this._handleChannelError.bind(this)); } inherits(DataChannelClient, events.EventEmitter); /** * Creates a Readable Stream for the token and hash that receives the data * @param {String} token - The RETRIEVE token supplied by the farmer * @param {String} hash - The hash of the data to retrieve * @returns {stream.Readable} */ DataChannelClient.prototype.retrieve = function(token, hash) { var channel = this._client.send(null, { token: token, hash: hash, operation: 'PULL' }); return channel; }; /** * Creates a Writable Stream for the token and hash that stores the data * @param {String} token - The CONSIGN token supplied by the farmer * @param {Buffer} data - The data to store */ DataChannelClient.prototype.consign = function(token, data, callback) { var hash = utils.rmd160sha256(data); var channel = this._client.send(data, { token: token, hash: hash, operation: 'PUSH' }); channel.on('data', function(data) { if (data.error) { callback(new Error(data.message)); } else { callback(null, hash); } channel.end(); }); }; /** * Handles the open event from the underlying client * @private */ DataChannelClient.prototype._handleChannelOpen = function() { this.emit('open'); }; /** * Handles the open event from the underlying client * @private */ DataChannelClient.prototype._handleChannelError = function(err) { this.emit('error', err); }; /** * Returns the URI of the contact's data channel * @static * @param {Object} contact */ DataChannelClient.getChannelURL = function(contact) { return url.format({ protocol: 'ws', slashes: true, hostname: contact.address, port: contact.port }); }; module.exports = DataChannelClient; × Search results Close "},"lib_keypair.js.html":{"id":"lib_keypair.js.html","title":"Source: lib/keypair.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/keypair.js 'use strict'; var bitcore = require('bitcore-lib'); var ECIES = require('bitcore-ecies'); /** * Represents a ECDSA key pair * @constructor * @param {String|Buffer} privkey - WIF encoded ECDSA private key */ function KeyPair(privkey) { if (!(this instanceof KeyPair)) { return new KeyPair(privkey); } if (privkey) { this._privkey = bitcore.PrivateKey.fromString(privkey); } else { this._privkey = bitcore.PrivateKey.fromRandom(); } this._pubkey = this._privkey.toPublicKey(); this._cipher = ECIES().privateKey(this._privkey).publicKey(this._pubkey); } /** * Returns the private key * @returns {String} key */ KeyPair.prototype.getPrivateKey = function() { return this._privkey.toString(); }; /** * Returns the public key * @returns {String} key */ KeyPair.prototype.getPublicKey = function() { return this._pubkey.toString(); }; /** * Returns the NodeID derived from the public key * @returns {String} nodeID - RIPEMD160 hash of public key */ KeyPair.prototype.getNodeID = function() { return bitcore.crypto.Hash.sha256ripemd160( this._pubkey.toBuffer() ).toString('hex'); }; /** * Returns the bitcoin address version of the nodeID * @returns {String} address - Base58 encoded address */ KeyPair.prototype.getAddress = function() { return bitcore.Address.fromPublicKeyHash( new Buffer(this.getNodeID(), 'hex') ).toString(); }; /** * Encrypts the data * @param {Buffer|String} data * @returns {Buffer} */ KeyPair.prototype.encrypt = function(data) { return this._cipher.encrypt(data); }; /** * Decrypts the data * @param {Buffer|String} data * @returns {Buffer} */ KeyPair.prototype.decrypt = function(data) { return this._cipher.decrypt(data); }; module.exports = KeyPair; × Search results Close "},"lib_manager.js.html":{"id":"lib_manager.js.html","title":"Source: lib/manager.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/manager.js 'use strict'; var assert = require('assert'); var StorageAdapter = require('./storage/adapter'); var StorageItem = require('./storage/item'); /** * Interface for managing contracts, shards, and audits * @constructor * @param {StorageAdapter} storage - Storage adapter to use */ function Manager(storage) { if (!(this instanceof Manager)) { return new Manager(storage); } assert(storage instanceof StorageAdapter, 'Invalid storage adapter'); this._storage = storage; } /** * Loads the storage {@link Item} at the given key * @param {String} hash - Shard hash to load data for * @param {Function} callback - Called with error or {@link StorageItem} */ Manager.prototype.load = function(hash, callback) { assert(typeof hash === 'string', 'Invalid key supplied'); assert(hash.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); this._storage.get(hash, function(err, item) { if (err) { return callback(err); } if (!(item instanceof StorageItem)) { return callback(new Error('Storage adapter provided invalid result')); } callback(null, item); }); }; /** * Saves the storage {@link StorageItem} at the given key * @param {StorageItem} item - The {@link StorageItem} to store * @param {Function} callback - Called on complete */ Manager.prototype.save = function(item, callback) { assert(item instanceof StorageItem, 'Invalid storage item supplied'); assert(typeof callback === 'function', 'Callback function must be supplied'); this._storage.put(item, callback); }; module.exports = Manager; × Search results Close "},"lib_network_index.js.html":{"id":"lib_network_index.js.html","title":"Source: lib/network/index.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/network/index.js 'use strict'; var path = require('path'); var url = require('url'); var assert = require('assert'); var merge = require('merge'); var async = require('async'); var kad = require('kad'); var ms = require('ms'); var bitcore = require('bitcore-lib'); var constants = require('../constants'); var Message = require('bitcore-message'); var Quasar = require('kad-quasar').Protocol; var utils = require('../utils'); var KeyPair = require('../keypair'); var Manager = require('../manager'); var StorageItem = require('../storage/item'); var Protocol = require('./protocol'); var Contract = require('../contract'); var Audit = require('../audit'); var Verification = require('../verification'); var Transport = require('./transport'); var DataChannelServer = require('../datachannel/server'); var DataChannelClient = require('../datachannel/client'); /** * Storj network interface * @constructor * @param {Object} options * @param {KeyPair} options.keypair - Node's cryptographic identity * @param {Manager} options.manager - Persistence management interface * @param {Number} options.loglevel - Verbosity level 0 - 4 * @param {Array} options.seeds - List of seed URIs to join * @param {String} options.datadir - Directory path to store data * @param {Object} options.contact * @param {String} options.contact.address - Public node IP or hostname * @param {Number} options.contact.port - Listening port for RPC * @param {Boolean} options.farmer - Flag indicating desire for contracts * @param {Boolean} options.noforward - Flag for skipping traversal strategies */ function Network(options) { if (!(this instanceof Network)) { return new Network(options); } var self = this; assert(options.keypair instanceof KeyPair, 'Invalid keypair supplied'); assert(options.manager instanceof Manager, 'Invalid manager supplied'); this._pendingContracts = {}; this._keypair = options.keypair; this._manager = options.manager; this._options = merge(Object.create(Network.DEFAULTS), options); this._logger = new kad.Logger(this._options.loglevel, 'STORJ'); this._contact = new kad.contacts.AddressPortContact( merge(this._options.contact, { nodeID: this._keypair.getNodeID() }) ); this._transport = new Transport(this._contact, { logger: this._logger, cors: true, // TODO: make this configurable allow farmers to tunnel for others tunnelhost: 'http://tunnel.metadisk.org', noforward: options.noforward }); this._transport.after('open', function() { self._channel = new DataChannelServer({ transport: self._transport, manager: self._manager, logger: self._logger }); }); this._router = new kad.Router({ transport: this._transport, logger: this._logger }); this._pubsub = new Quasar(this._router, { logger: this._logger }); if (this._options.datadir) { this._storage = new kad.storage.FS( path.join(this._options.datadir, 'items') ); } else { this._storage = new kad.storage.MemStore(); } this._pubkeys = {}; this._open = false; } Network.DEFAULTS = { loglevel: 3, seeds: [], datadir: null, contact: { address: '127.0.0.1', port: 4000, }, farmer: false, noforward: false }; /** * Opens the connection to the network * @param {Function} callback - Called on successful network join */ Network.prototype.join = function(callback) { var self = this; var seeds = this._options.seeds.map(this._createContact); var protocol = new Protocol({ network: this }); assert(!this._open, 'Network interface already open'); this._transport.on('error', this._handleTransportError.bind(this)); this._transport.before('serialize', this._signMessage.bind(this)); this._transport.before('receive', this._verifyMessage.bind(this)); this._transport.before('receive', kad.hooks.protocol(protocol.handlers())); this._node = new kad.Node({ transport: this._transport, router: this._router, storage: this._storage, logger: this._logger }); this._open = true; async.each(seeds, function(contact, next) { self._node.connect(contact, function(err) { if (!err) { self._addPingInterval(contact, ms('1m')); } }); next(); }, function() { if (self._options.farmer) { self._farm(); } callback(null, self); }); }; /** * Disconnects from the network * @param {Function} callback - Called when successful disconnect */ Network.prototype.leave = function(callback) { this._removePingInterval(); this._node.disconnect(callback); }; /** * Look up the storage contract by the hash to find the node who has * the shard. Look up the appropriate challenge and send it to the node * for verification. If successful, invalidate the challenge and pass, * otherwise, invalidate the contract. * @param {String} hash - RIPEMD-160 SHA-256 hash of the file to audit * @param {Function} callback - Called with validity information */ Network.prototype.audit = function(hash, callback) { var self = this; self._manager.load(hash, function(err, item) { if (err) { return callback(err); } // TODO: Be smarter about which contract holder we choose if there is more // TODO: than a single farmer holding our shard. // TODO: Also, if one farmer fails to respond, we should try another var farmerID = Object.keys(item.contracts)[0]; self._router.findNode(farmerID, function(err, nodes) { if (err) { return callback(err); } var farmer = nodes.filter(function(node) { return node.nodeID === farmerID; })[0]; if (!farmer) { return callback(new Error('Could not find the farmer')); } var audit = item.challenges[farmer.nodeID]; var message = new kad.Message({ method: 'AUDIT', params: { data_hash: hash, challenge: audit.challenges[0], contact: self._contact } }); self._transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } if (!response.result.proof) { return callback(new Error('Invalid proof returned')); } var verification = new Verification(response.result.proof); callback(null, verification.verify(audit.root, audit.depth)); }); }); }); }; /** * Look up the storage contract by the hash to find the node who has * the shard, then execute a RETRIEVE RPC to the node and return the * data as a buffer. * @param {String} hash - RIPEMD-160 SHA-256 hash of the file to retrieve * @param {Function} callback - Called with an error or the file buffer */ Network.prototype.retrieve = function(hash, callback) { var self = this; self._manager.load(hash, function(err, item) { if (err) { return callback(err); } // TODO: Be smarter about which contract holder we choose if there is more // TODO: than a single farmer holding our shard. var farmerID = Object.keys(item.contracts)[0]; self._router.findNode(farmerID, function(err, nodes) { if (err) { return callback(err); } var farmer = nodes.filter(function(node) { return node.nodeID === farmerID; })[0]; if (!farmer) { return callback(new Error('Could not find the farmer')); } var message = new kad.Message({ method: 'RETRIEVE', params: { data_hash: hash, contact: self._contact } }); self._transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } var token = response.result.token; var channel = new DataChannelClient(response.result.contact); channel.on('open', function() { callback(null, channel.retrieve(token, hash)); }); }); }); }); }; /** * Create a contract from the data and options supplied and publish it * on the network. Keep track of the pending contract until it becomes * fulfilled by an OFFER, then issue a CONSIGN RPC to the offerer and * callback when the data is stored. * @param {Buffer} data - Raw binary blob to store * @param {String} duration - String representation of time for `ms` like &quot;2w&quot; * @param {Function} callback - Called on successful store */ Network.prototype.store = function(data, duration, callback) { assert(Buffer.isBuffer(data), 'Invalid data supplied'); assert(typeof duration === 'string', 'Invalid duration supplied'); assert(typeof callback === 'function', 'Callback is not a function'); data = new Buffer(data.toString('hex'), 'hex'); var self = this; var shardHash = utils.rmd160sha256(data); var contract = new Contract({ renter_id: this._keypair.getNodeID(), data_size: data.length, data_hash: shardHash, store_begin: Date.now(), store_end: Date.now() + ms(duration), audit_count: 12 // TODO: Make this configurable }); var audit = new Audit({ audits: 12, shard: data }); // Store a reference to this contract as a function to issue a CONSIGN this._pendingContracts[shardHash] = function(farmer) { var message = new kad.Message({ method: 'CONSIGN', params: { data_hash: contract.get('data_hash'), audit_tree: audit.getPublicRecord(), contact: self._contact } }); self._transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } var token = response.result.token; var channel = new DataChannelClient(response.result.contact); channel.on('open', function() { channel.consign(token, data, function(err, hash) { if (err) { return callback(err); } self._manager.load(shardHash, function(err, item) { if (err) { item = new StorageItem({ hash: shardHash }); } item.trees[farmer.nodeID] = audit.getPublicRecord(); item.challenges[farmer.nodeID] = audit.getPrivateRecord(); item.meta[farmer.nodeID] = {}; self._manager.save(item, function(err) { if (err) { return callback(err); } callback(null, hash); }); }); }); }); }); }; self._publish(Contract.DEFAULTS.type, contract); }; /** * Subscribes to all storage contracts and issues offers, for now this just * accepts the initial offer and signs it * @private */ Network.prototype._farm = function() { var self = this; // TODO: Refactor all of this. self._subscribe(Contract.DEFAULTS.type, function(contract) { contract.set('farmer_id', self._keypair.getNodeID()); contract.set('payment_destination', self._keypair.getAddress()); contract.sign('farmer', self._keypair.getPrivateKey()); var final; self._router.findNode(contract.get('renter_id'), function(err, nodes) { if (err) { return self._logger.error(err.message); } var renter = nodes.filter(function(node) { return node.nodeID === contract.get('renter_id'); })[0]; if (!renter) { return self._logger.error('Could not locate renter for offer'); } var message = new kad.Message({ method: 'OFFER', params: { contract: contract.toObject(), contact: self._contact } }); self._transport.send(renter, message, function(err, response) { if (err) { return self._logger.error(err.message); } if (response.error || !response.result.contract) { return self._logger.error( response.error ? response.error.message : 'Renter refused to sign' ); } try { final = Contract.fromObject(response.result.contract); } catch (err) { return self._logger.error('Renter responded with invalid contract'); } if (!final.verify('renter', contract.get('renter_id'))) { return self._logger.error('Renter signature is invalid'); } self._manager.load(contract.get('data_hash'), function(err, item) { if (err) { item = new StorageItem({ hash: contract.get('data_hash') }); } item.contracts[renter.nodeID] = contract.toObject(); item.meta[renter.nodeID] = {}; self._manager.save(item, function() {}); }); }); }); }); }; /** * Publishes a contract to the network * @private * @param {String} identifier * @param {Contract} contract */ Network.prototype._publish = function(identifier, contract) { assert(contract instanceof Contract, 'Invalid contract supplied'); return this._pubsub.publish(identifier, contract.toObject()); }; /** * Subscribes to a contract identifier on the network * @private * @param {String} identifier * @param {Function} handler */ Network.prototype._subscribe = function(identifier, handler) { return this._pubsub.subscribe(identifier, function(contract) { var contractObj; try { contractObj = Contract.fromObject(contract); } catch (err) { return false; // If the contract is invalid just drop it } handler(contractObj); }); }; /** * Connects to the node at the given URI * @private * @param {String} uri * @param {Function} callback */ Network.prototype._connect = function(uri, callback) { return this._node.connect(this._createContact(uri), callback); }; /** * Returns a Storj contact from the URI * @private * @param {String} uri */ Network.prototype._createContact = function(uri) { var parsed = url.parse(uri); return new kad.contacts.AddressPortContact({ address: parsed.hostname, port: Number(parsed.port), nodeID: parsed.path.substr(1) }); }; /** * Signs an outgoing message * @private * @param {kad.Message} message * @param {Function} callback */ Network.prototype._signMessage = function(message, callback) { var nonce = Date.now(); var target = message.id + nonce; var signature = Message(target).sign(this._keypair._privkey); if (kad.Message.isRequest(message)) { message.params.__nonce = nonce; message.params.__signature = signature; } else { message.result.__nonce = nonce; message.result.__signature = signature; } callback(); }; /** * Verifies an incoming message * @private * @param {kad.Message} message * @param {Contact} contact * @param {Function} callback */ Network.prototype._verifyMessage = function(message, contact, callback) { var nonce, signature; if (kad.Message.isRequest(message)) { nonce = message.params.__nonce; signature = message.params.__signature; } else { nonce = message.result.__nonce; signature = message.result.__signature; } if (Date.now() &gt; (constants.NONCE_EXPIRE + nonce)) { return callback(new Error('Message signature expired')); } var target = message.id + nonce; var addr = bitcore.Address.fromPublicKeyHash(Buffer(contact.nodeID, 'hex')); var compactSig = new Buffer(signature, 'base64'); var signobj = bitcore.crypto.Signature.fromCompact(compactSig); var signedmsg = Message(target); var ecdsa = new bitcore.crypto.ECDSA(); ecdsa.hashbuf = signedmsg.magicHash(); ecdsa.sig = signobj; this._pubkeys[contact.nodeID] = ecdsa.toPublicKey(); if (!signedmsg.verify(addr, signature)) { return callback(new Error('Signature verification failed')); } callback(); }; /** * Proxies error events from the underlying transport adapter * @private * @param {Error} error */ Network.prototype._handleTransportError = function(error) { this._logger.error(error.message); }; /** * Setup a PING message to the given contact on an interval * @private * @param {Contact} contact * @param {Number} interval */ Network.prototype._addPingInterval = function(contact, interval) { assert(typeof interval === 'number', 'Invalid interval supplied'); var self = this; if (!this._pingSeeds) { this._pingSeeds = {}; } function pingSeed() { self._transport.send(contact, new kad.Message({ method: 'PING', params: { contact: self._node._self } }), function noop() {}); } this._pingSeeds[contact.nodeID] = setInterval(pingSeed, interval); }; /** * Stop sending PING message to the given contact * @private * @param {Contact} contact */ Network.prototype._removePingInterval = function(contact) { if (!contact) { for (var nodeID in this._pingSeeds) { clearInterval(this._pingSeeds[nodeID]); } } else { clearInterval(this._pingSeeds[contact.nodeID]); } }; module.exports = Network; × Search results Close "},"lib_network_protocol.js.html":{"id":"lib_network_protocol.js.html","title":"Source: lib/network/protocol.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/network/protocol.js 'use strict'; var assert = require('assert'); var utils = require('../utils'); var Proof = require('../proof'); var Contract = require('../contract'); var StorageItem = require('../storage/item'); var stream = require('stream'); /** * Defines the Storj protocol methods and mounts on a {@link Network} instance * to handle Storj protocol messages * @constructor * @param {Object} options * @param {Network} options.network - Network instance to bind to */ function Protocol(opts) { if (!(this instanceof Protocol)) { return new Protocol(opts); } assert(typeof opts === 'object' , 'Invalid options supplied'); this._network = opts.network; } /** * Handles OFFER messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleOffer = function(params, callback) { var contract; try { contract = Contract.fromObject(params.contract); } catch (err) { return callback(new Error('Invalid contract format')); } // TODO: Ultimately we will need to create a robust decision engine that will // TODO: allow us to better determine if the received offer is in our best // TODO: interest. For now, we just make sure that we have the data_shard // TODO: from the OFFER and we wish to CONSIGN it. // For now, we just accept any storage offer we get that matches our own... var self = this; var key = contract.get('data_hash'); if (!self._network._pendingContracts[key]) { return callback(new Error('Contract no longer open to offers')); } if (!self._network._pendingContracts[key]) { return callback(new Error('Contract no longer open to offers')); } if (!contract.verify('farmer', params.contact.nodeID)) { return callback(new Error('Invalid signature from farmer')); } contract.sign('renter', self._network._keypair.getPrivateKey()); if (!contract._complete()) { return callback(new Error('Contract is not complete')); } if (!self._network._pendingContracts[key]) { return callback(new Error('Contract no longer open to offers')); } var doConsign = self._network._pendingContracts[key].bind( self._network, params.contact ); delete self._network._pendingContracts[key]; var item = new StorageItem({ hash: key }); item.contracts[params.contact.nodeID] = contract; self._network._manager.save(item, function(err) { if (err) { return callback(err); } callback(null, { contract: contract.toObject() }); doConsign(); }); }; /** * Handles AUDIT messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleAudit = function(params, callback) { var self = this; var shard = new Buffer([]); self._network._manager.load(params.data_hash, function(err, item) { if (err) { return callback(err); } if (item.shard instanceof stream.Writable) { return callback(new Error('Shard not found')); } item.shard.on('data', function(chunk) { shard = Buffer.concat([shard, chunk]); }); item.shard.on('end', function() { var proof = new Proof({ leaves: item.trees[params.contact.nodeID], shard: shard }); callback(null, { proof: proof.prove(params.challenge) }); }); }); }; /** * Handles CONSIGN messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleConsign = function(params, callback) { var self = this; var token = utils.generateToken(); self._network._manager.load(params.data_hash, function(err, item) { if (err) { return callback(err); } var contract = item.contracts[params.contact.nodeID]; var t = Date.now(); item.trees[contract.get('renter_id')] = params.audit_tree; try { assert( t &lt; contract.get('store_end') || t &gt; contract.get('store_begin'), 'Consignment violates contract store time' ); } catch (err) { return callback(err); } self._network._manager.save(item, function(err) { if (err) { return callback(err); } self._network._channel.accept(token, params.data_hash); callback(null, { token: token }); }); }); }; /** * Handles RETRIEVE messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleRetrieve = function(params, callback) { var self = this; var hash = params.data_hash; var token = utils.generateToken(); // TODO: We will need to increment the download count to track payments, as // TODO: well as make sure that the requester is allowed to fetch the shard // TODO: as part of the contract. self._network._manager.load(hash, function(err, item) { if (err) { return callback(err); } self._network._channel.accept(token, item.hash); callback(null, { token: token }); }); }; /** * Returns bound references to the protocol handlers */ Protocol.prototype.handlers = function() { return { OFFER: this._handleOffer.bind(this), AUDIT: this._handleAudit.bind(this), CONSIGN: this._handleConsign.bind(this), RETRIEVE: this._handleRetrieve.bind(this) }; }; module.exports = Protocol; × Search results Close "},"lib_network_transport.js.html":{"id":"lib_network_transport.js.html","title":"Source: lib/network/transport.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/network/transport.js 'use strict'; var inherits = require('util').inherits; var kad = require('kad'); var natupnp = require('nat-upnp').createClient(); var ip = require('ip'); var tunnel = require('localtunnel'); var url = require('url'); /** * Custom HTTP transport adapter * @constructor * @param {kad.Contact} * @param {Object} options * @param {Logger} options.logger * @param {Boolean} options.cors * @param {String} options.tunnelHost */ function Transport(contact, options) { if (!(this instanceof Transport)) { return new Transport(contact, options); } this._tunnelhost = options.tunnelhost; this._noforward = options.noforward; kad.transports.HTTP.call(this, contact, options); } inherits(Transport, kad.transports.HTTP); /** * Opens the transport, trying UPnP to become publicly addressable and falling * back to using a Tunnel * @private * @param {Function} callback */ Transport.prototype._open = function(callback) { var self = this; if (ip.isPublic(self._contact.address) || self._noforward) { return kad.transports.HTTP.prototype._open.call(self, callback); } self._log.warn( 'you are not bound to a public address, trying traversal strategies...' ); self._forwardPort(function(err) { if (err) { self._log.info('attempting to open connection tunnel...'); return tunnel(self._contact.port, { subdomain: self._contact.nodeID.substr(0, 8), host: self._tunnelhost }, function(err, client) { if (err) { self._log.warn( 'failed to tunnel connection, reason: %s', err.message ); return kad.transports.HTTP.prototype._open.call(self, callback); } self._log.info('established tunnel, you are: %s', client.url); var addr = url.parse(client.url); self._tunnel = client; kad.transports.HTTP.prototype._open.call(self, callback); self._contact.address = addr.hostname; self._contact.port = addr.protocol === 'https:' ? 443 : 80; }); } kad.transports.HTTP.prototype._open.call(self, callback); }); }; /** * Forwards a port and resolves the public IP * @private * @param {Function} callback */ Transport.prototype._forwardPort = function(callback) { var self = this; natupnp.portMapping({ public: self._contact.port, private: self._contact.port, ttl: 0 }, function(err) { if (err) { self._log.warn('could not connect to NAT device via UPnP'); return callback(err); } natupnp.externalIp(function(err, ip) { if (err) { self._log.warn('could not obtain public IP address'); return callback(err); } self._contact.address = ip; self._log.info('successfully traversed NAT via UPnP'); callback(null); }); }); }; module.exports = Transport; × Search results Close "},"lib_proof.js.html":{"id":"lib_proof.js.html","title":"Source: lib/proof.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/proof.js 'use strict'; var assert = require('assert'); var MerkleTree = require('mtree'); var utils = require('./utils'); /** * Provides interface for proving possession of a file for an {@link Audit} * @constructor * @param {Object} options * @param {Array} options.leaves - Bottom leaves of the audit merkle tree * @param {Buffer} options.shard - Binary shard data */ function Proof(options) { if (!(this instanceof Proof)) { return new Proof(options); } assert(Array.isArray(options.leaves), 'Merkle leaves must be an array'); assert(Buffer.isBuffer(options.shard), 'Invalid shard supplied'); this._shard = options.shard; this._tree = new MerkleTree( this._generateLeaves(options.leaves), utils.rmd160sha256 ); } /** * Calculate audit response * @param {String} challenge - Challenge string sent by auditor * @returns {Array} result - Challenge response */ Proof.prototype.prove = function(challenge) { var response = utils.rmd160sha256(challenge + this._shard.toString('hex')); var leaf = utils.rmd160sha256(response); var leaves = this._tree.level(this._tree.levels() - 1); var challengenum = leaves.indexOf(leaf); assert(challengenum !== -1, 'Failed to generate proof'); var branches = [response]; for (var i = (this._tree.levels() - 1); i &gt; 0; i--) { var level = this._tree.level(i); if (challengenum % 2 === 0) { branches = [branches, level[challengenum + 1]]; } else { branches = [level[challengenum - 1], branches]; } challengenum = Math.floor(challengenum / 2); } return branches; }; /** * Generates the bottom leaves of the tree to the next power of two * @private * @param {Array} leaves */ Proof.prototype._generateLeaves = function(leaves) { var numEmpty = utils.getNextPowerOfTwo(leaves.length) - leaves.length; var emptyLeaves = []; for (var i = 0; i &lt; numEmpty; i++) { emptyLeaves.push(utils.rmd160sha256('')); } return leaves.concat(emptyLeaves); }; module.exports = Proof; × Search results Close "},"lib_storage_adapter.js.html":{"id":"lib_storage_adapter.js.html","title":"Source: lib/storage/adapter.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/storage/adapter.js 'use strict'; var assert = require('assert'); var Item = require('./item'); /** * Abstract base class for storage adapter * @constructor */ function StorageAdapter() { if (!(this instanceof StorageAdapter)) { return new StorageAdapter(); } } /** * Calls the implemented {@link StorageAdapter#_get} and validates the result * @param {String} key - Shard hash to get metadata for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.get = function(key, callback) { assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); return this._get(key, callback); }; /** * Calls the implemented {@link StorageAdapter#_put} and validates the input * @param {StorageItem} item - Item to write to storage * @param {Function} callback - Called on complete write */ StorageAdapter.prototype.put = function(item, callback) { assert(item instanceof Item, 'Invalid storage item supplied'); assert(typeof callback === 'function', 'Callback function must be supplied'); return this._put(item.hash, item, callback); }; /** * Performs lookup and provides an {@link StorageItem} to the callback * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._get = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Stores the {@link StorageItem} * @abstract * @param {String} key - Shard hash * @param {Item} item - Item to store * @param {Function} callback - Called on complete */ StorageAdapter.prototype._put = function(/* item, callback */) { throw new Error('Method not implemented'); }; module.exports = StorageAdapter; × Search results Close "},"lib_storage_adapters_fs.js.html":{"id":"lib_storage_adapters_fs.js.html","title":"Source: lib/storage/adapters/fs.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/storage/adapters/fs.js 'use strict'; var async = require('async'); var inherits = require('util').inherits; var path = require('path'); var fs = require('fs'); var StorageAdapter = require('../adapter'); var StorageItem = require('../item'); var HOME_DIR = process.platform === 'win32' ? process.env.USERPROFILE : process.env.HOME; /* Example Directory Tree ====================== |- &lt;datadir&gt;/ | |- shards/ | | |- &lt;shard_hash&gt;/ | | | |- contracts/ | | | | |- renter_or_farmer_id_1 | | | | |- renter_or_farmer_id_2 | | | |- trees/ | | | | |- renter_or_farmer_id_1 | | | | |- renter_or_farmer_id_1 | | | |- challenges/ | | | | |- farmer_id_1 | | | | |- farmer_id_2 | | | |- meta/ | | | | |- renter_or_farmer_id_1 | | | | |- renter_or_farmer_id_1 | | | |- shard.data */ /** * Implements a file-system based storage adapter * @constructor * @extends {StorageAdapter} * @param {String} datadir - Directory path to store data */ function FSStorageAdapter(datadir) { if (!(this instanceof FSStorageAdapter)) { return new FSStorageAdapter(datadir); } this._datadir = datadir || path.join(HOME_DIR, '.storjnode'); this._sharddir = path.join(this._datadir, 'shards'); if (!fs.existsSync(this._datadir)) { fs.mkdirSync(this._datadir); } if (!fs.existsSync(this._sharddir)) { fs.mkdirSync(this._sharddir); } } inherits(FSStorageAdapter, StorageAdapter); /** * Implements the abstract {@link StorageAdapter#_get} * @private * @param {String} key * @param {Function} callback */ FSStorageAdapter.prototype._get = function(key, callback) { var self = this; var target = path.join(this._sharddir, key); var contracts = path.join(target, 'contracts'); var trees = path.join(target, 'trees'); var challenges = path.join(target, 'challenges'); var meta = path.join(target, 'meta'); var data = { hash: key, shard: null, contracts: null, trees: null, challenges: null, meta: null }; function checkTarget(done) { fs.exists(target, function(exists) { if (exists) { return done(); } done(new Error('Shard data not found')); }); } function getShard(done) { var shardpath = path.join(target, 'shard.data'); fs.exists(shardpath, function(exists) { if (exists) { data.shard = fs.createReadStream(shardpath); } else { data.shard = fs.createWriteStream(shardpath); } done(); }); } function getItemData(done) { async.parallel([ function getContracts(done) { self.__fromDirectory(contracts, function(err, result) { data.contracts = result; done(new Error('Failed to load the shard contracts')); }); }, function getTrees(done) { self.__fromDirectory(trees, function(err, result) { data.trees = result; done(new Error('Failed to load the shard audit trees')); }); }, function getChallenges(done) { self.__fromDirectory(challenges, function(err, result) { data.challenges = result; done(new Error('Failed to load the shard audit challenges')); }); }, function getMeta(done) { self.__fromDirectory(meta, function(err, result) { data.meta = result; done(new Error('Failed to load the shard metadata')); }); } ], done); } async.series([checkTarget, getShard, getItemData], function(err) { if (err) { return callback(err); } callback(null, new StorageItem(data)); }); }; /** * Implements the abstract {@link StorageAdapter#_put} * @private * @param {String} key * @param {StorageItem} item * @param {Function} callback */ FSStorageAdapter.prototype._put = function(key, item, callback) { var self = this; var target = path.join(this._sharddir, key); var contracts = path.join(target, 'contracts'); var trees = path.join(target, 'trees'); var challenges = path.join(target, 'challenges'); var meta = path.join(target, 'meta'); var directories = [target, contracts, trees, challenges, meta]; function checkTarget(done) { fs.exists(target, function(exists) { if (exists) { return done(); } async.eachSeries(directories, function(dirname, next) { fs.mkdir(dirname, function(err) { if (err) { return next(err); } next(); }); }, done); }); } function writeItemData(done) { async.parallel([ function writeContracts(done) { self.__toDirectory(contracts, item.contracts, done); }, function writeTrees(done) { self.__toDirectory(trees, item.trees, done); }, function writeChallenges(done) { self.__toDirectory(challenges, item.challenges, done); }, function writeMeta(done) { self.__toDirectory(meta, item.meta, done); } ], done); } async.series([checkTarget, writeItemData], function(err) { if (err) { return callback(new Error('Failed to write shard data')); } callback(null); }); }; /** * Loads the directory contents as an object where key is the file's basename * and value is the parsed JSON object * @private * @param {String} dirname * @param {Function} callback */ FSStorageAdapter.prototype.__fromDirectory = function(dirname, callback) { var result = {}; function onComplete(err) { if (err) { return callback(err); } callback(null, result); } function loadFile(filename, done) { fs.readFile(path.join(dirname, filename), function(err, buffer) { if (err) { return done(err); } try { result[path.basename(filename)] = JSON.parse(buffer.toString('utf8')); } catch (err) { return done(err); } done(); }); } fs.readdir(dirname, function(err, contents) { if (err) { return callback(err); } async.each(contents, loadFile, onComplete); }); }; /** * Writes the data object to the supplied directory * @private * @param {String} dirname * @param {Object} data * @param {Function} callback */ FSStorageAdapter.prototype.__toDirectory = function(dirname, data, callback) { var filenames = Object.keys(data); function writeFile(filename, next) { var buffer; try { buffer = new Buffer(JSON.stringify(data[filename])); } catch (err) { return next(err); } fs.writeFile(path.join(dirname, filename), buffer, next); } async.each(filenames, writeFile, callback); }; module.exports = FSStorageAdapter; × Search results Close "},"lib_storage_adapters_ram.js.html":{"id":"lib_storage_adapters_ram.js.html","title":"Source: lib/storage/adapters/ram.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/storage/adapters/ram.js 'use strict'; var inherits = require('util').inherits; var stream = require('stream'); var StorageAdapter = require('../adapter'); var StorageItem = require('../item'); /** * Implements an in-memory storage adapter * @extends {StorageAdapter} * @constructor */ function RAMStorageAdapter() { if (!(this instanceof RAMStorageAdapter)) { return new RAMStorageAdapter(); } this._items = {}; this._shards = {}; } inherits(RAMStorageAdapter, StorageAdapter); /** * Implements the abstract {@link StorageAdapter#_get} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._get = function(key, callback) { var self = this; var result = this._items[key]; if (!result) { return callback(new Error('Shard data not found')); } if (this._shards[key]) { result.shard = new stream.Readable({ read: function() { if (this._finished) { this.push(null); } else { this.push(self._shards[key]); this._finished = true; } } }); } else { result.shard = new stream.Writable({ write: function(data, encoding, next) { self._shards[key] = data; next(); } }); } callback(null, new StorageItem(result)); }; /** * Implements the abstract {@link StorageAdapter#_put} * @private * @param {String} key * @param {StorageItem} item * @param {Function} callback */ RAMStorageAdapter.prototype._put = function(key, item, callback) { this._items[key] = item; callback(); }; module.exports = RAMStorageAdapter; × Search results Close "},"lib_storage_item.js.html":{"id":"lib_storage_item.js.html","title":"Source: lib/storage/item.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/storage/item.js 'use strict'; var assert = require('assert'); var Contract = require('../contract'); /** * Represents a storage item, including contracts, challengs, the shard itself * along with metadata describing download count, payments, etc * @constructor * @param {Object} data * @param {String|null} data.hash - Shard hash to use as storage key * @param {Stream|null} data.shard - Raw binary blob of shard * @param {Object} data.contracts - Dictionary of nodeID:{@link Contract} * @param {Object} data.trees - Dictionary of nodeID:merkleLeaves * @param {Object} data.challenges - Dictionary of nodeID:privateAuditData * @param {Object} data.meta - Dictionary of arbitrary nodeID:metadata */ function StorageItem(data) { if (!(this instanceof StorageItem)) { return new StorageItem(data); } data = data || {}; this.hash = null; this.shard = null; this.contracts = {}; this.trees = data.trees || {}; this.challenges = data.challenges || {}; this.meta = data.meta || {}; this._init(data); } /** * Initializes the item values with the given data * @private * @param {Object} data * @returns {StorageItem} */ StorageItem.prototype._init = function(data) { assert(typeof data === 'object', 'Invalid item data supplied'); this.shard = data.shard || null; this.hash = data.hash || null; for (var nodeID in data.contracts) { this.contracts[nodeID] = new Contract(data.contracts[nodeID]); } return this; }; module.exports = StorageItem; × Search results Close "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/utils.js /** * @module storj/utils */ 'use strict'; var crypto = require('crypto'); /** * Returns the SHA-256 hash of the input * @param {String|Buffer} input - Data to hash * @returns {String} */ module.exports.sha256 = function(input) { return crypto.createHash('sha256').update(input).digest('hex'); }; /** * Returns the RIPEMD-160 hash of the input * @param {String|Buffer} input - Data to hash * @returns {String} */ module.exports.rmd160 = function(input) { return crypto.createHash('rmd160').update(input).digest('hex'); }; /** * Returns the RIPEMD-160 SHA-256 hash of this input * @param {String|Buffer} input - Data to hash * @returns {String} */ module.exports.rmd160sha256 = function(input) { return module.exports.rmd160(module.exports.sha256(input)); }; /** * Returns the next power of two number * @param {Number} number * @returns {Number} */ module.exports.getNextPowerOfTwo = function(num) { return Math.pow(2, Math.ceil(Math.log(num) / Math.log(2))); }; /** * Generates a unique token * @returns {String} */ module.exports.generateToken = function() { return module.exports.rmd160sha256(crypto.randomBytes(512)); }; /** * Returns a stringified URL from the supplied contact object * @param {Object} contact * @param {String} contact.address * @param {Number} contact.port * @param {String} contact.nodeID * @returns {String} */ module.exports.getContactURL = function(contact) { return [ 'storj://', contact.address, ':', contact.port, '/', contact.nodeID ].join(''); }; × Search results Close "},"lib_verification.js.html":{"id":"lib_verification.js.html","title":"Source: lib/verification.js","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Source: lib/verification.js 'use strict'; var assert = require('assert'); var utils = require('./utils'); /** * Interface for verifying the result of an audit proof * @constructor * @param {Array} proof - The result of {@link Proof#prove} */ function Verification(proof) { if (!(this instanceof Verification)) { return new Verification(proof); } assert(Array.isArray(proof), 'Proof must be an array'); this._proof = proof; } /** * Extracts the challenge response from the proof * @private * @param {Array} response - Challenge response received from farmer * @returns {String} leaf */ Verification.prototype._getChallengeResponse = function(tuple) { var data = tuple || this._proof; if (data.length === 1) { return utils.rmd160sha256(data[0]); } if (Array.isArray(data[0])) { return this._getChallengeResponse(data[0]); } else { return this._getChallengeResponse(data[1]); } }; /** * Verifies the proof given the merkle root and tree depth * @param {String} root - Merkle root * @param {Number} totaldepth - Depth of merkle tree * @returns {Array} result - Array with expected result and verified result */ Verification.prototype.verify = function(root, totaldepth) { function _collapse(proof, leaf, depth) { if (depth === 0) { assert(proof.length === 1, 'Invalid proof structure'); assert(utils.rmd160sha256(proof[0]) === leaf, 'Invalid proof value'); return leaf; } assert(proof.length === 2, 'Invalid proof structure'); var hashL, hashR; if (Array.isArray(proof[0])) { hashL = _collapse(proof[0], leaf, depth - 1); } else { hashL = proof[0]; } if (Array.isArray(proof[1])) { hashR = _collapse(proof[1], leaf, depth - 1); } else { hashR = proof[1]; } return utils.rmd160sha256(hashL + hashR); } return [ _collapse(this._proof, this._getChallengeResponse(), totaldepth - 1), root ]; }; module.exports = Verification; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Modules Classes Audit Contract DataChannelClient DataChannelServer KeyPair Manager Network Protocol Transport Proof StorageAdapter FSStorageAdapter RAMStorageAdapter StorageItem Verification × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Classes Classes Audit Contract DataChannelClient DataChannelServer KeyPair Manager Network Protocol Transport Proof StorageAdapter FSStorageAdapter RAMStorageAdapter StorageItem Verification × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Tutorials Classes Audit Contract DataChannelClient DataChannelServer KeyPair Manager Network Protocol Transport Proof StorageAdapter FSStorageAdapter RAMStorageAdapter StorageItem Verification × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Storj JS This package exposes a module that provides all of the tools needed to integrate with the Storj network. Complete documentation can be found here. Quick StartInstall Wget: apt-get install wgetInstall NVM, Node.js and NPM: wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.30.1/install.sh | bash source ~/.profile nvm install 4.2.3Using the Command Line InterfaceInstall globally as user with NPM: npm install storj --globalInstall globally as root with NPM: npm install storj --global --unsafe-permUsing the LibraryInstall locally as user with NPM: npm install storj --saveInstall locally as root with NPM: npm install storj --unsafe-perm --saveImport the storj module, generate a key pair, configure your persistence layer, and join the network in just a few lines of code: var storj = require('storj'); var keypair = new storj.KeyPair(/* existing_key */); var store = new storj.FSStorageAdapter('/path/to/datadir'); var manager = new storj.Manager(store); var network = new storj.Network({ keypair: keypair, manager: manager, contact: { address: 'ip.or.hostname', port: 4000 }, seeds: [ 'storj://api.metadisk.org:8443/593844dc7f0076a1aeda9a6b9788af17e67c1052' ], loglevel: 3, datadir: '/path/to/datadir', farmer: false }); network.join(function(err) { if (err) { return console.log('Failed to join network, reason: %s', err.message); } console.log('Connected to the Storj network!'); });Once you are connected to the network, you can store, audit, and retrieve arbitrary data shards. LicenseStorj JS - Implementation of the Storj protocol for Node.js Copyright (C) 2016 Storj Labs, Inc This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program. If not, see . × Search results Close "},"DataChannelServer.html":{"id":"DataChannelServer.html","title":"Class: DataChannelServer","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: DataChannelServer DataChannelServer new DataChannelServer(options) Creates a data channel server for sending and receiving consigned file shards Parameters: Name Type Description options Object Properties Name Type Description transport Transport Transport adapter from Network manager Manager The Manager from Network logger kad.Logger Logger to use from Network ttl Number Close after idle for this length of time Source: lib/datachannel/server.js, line 22 Methods accept(token, filehash) Begin accepting data for the given file hash and token Parameters: Name Type Description token String The authorization token created for transfer filehash String The shard hash to allow for the token Source: lib/datachannel/server.js, line 52 reject(token) Stop accepting data for the given token Parameters: Name Type Description token String The authorization token created for transfer Source: lib/datachannel/server.js, line 63 close() Closes the data channel and disconnects all clients Source: lib/datachannel/server.js, line 78 × Search results Close "},"module-storjnode.html":{"id":"module-storjnode.html","title":"Module: storjnode","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Module: storjnode Source: index.js, line 1 Members &lt;static&gt; DataChannelClient DataChannelClient Source: index.js, line 13 &lt;static&gt; DataChannelServer DataChannelServer Source: index.js, line 16 &lt;static&gt; Protocol Protocol Source: index.js, line 19 &lt;static&gt; Contract Contract Source: index.js, line 22 &lt;static&gt; Audit Audit Source: index.js, line 25 &lt;static&gt; Proof Proof Source: index.js, line 28 &lt;static&gt; Verification Verification Source: index.js, line 31 &lt;static&gt; Manager Manager Source: index.js, line 34 &lt;static&gt; StorageAdapter StorageAdapter Source: index.js, line 37 &lt;static&gt; FSStorageAdapter FSStorageAdapter Source: index.js, line 40 &lt;static&gt; RAMStorageAdapter RAMStorageAdapter Source: index.js, line 43 &lt;static&gt; StorageItem StorageItem Source: index.js, line 46 &lt;static&gt; KeyPair KeyPair Source: index.js, line 49 &lt;static&gt; constants constants Source: index.js, line 52 &lt;static&gt; utils utils Source: index.js, line 55 &lt;static&gt; Network Network Source: index.js, line 10 × Search results Close "},"Audit.html":{"id":"Audit.html","title":"Class: Audit","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: Audit Audit new Audit(options) Represents an auditing interface using a precomputed merkle tree Parameters: Name Type Description options Object Properties Name Type Description audits Number Total number of challenges to generate shard Buffer Data to create audit challenges for Source: lib/audit.js, line 17 Methods getPublicRecord() Returns the bottom leaves of the merkle tree for sending to farmer Source: lib/audit.js, line 45 Returns: leaves - Bottom merkle leaves of audit tree Type Array getPrivateRecord() Returns the challenges, the tree depth, and merkle root Source: lib/audit.js, line 53 Returns: challenge - Private audit record with challenges Type Object × Search results Close "},"module-storj_constants.html":{"id":"module-storj_constants.html","title":"Module: storj/constants","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Module: storj/constants Source: lib/constants.js, line 1 Members &lt;inner, constant&gt; PREFIX :Number NodeID prefix (same as bitcoin) Type: Number Source: lib/constants.js, line 8 &lt;inner, constant&gt; NONCE_EXPIRE :Number Time to honor a signed message Type: Number Source: lib/constants.js, line 10 &lt;inner, constant&gt; AUDIT_BYTES :Number Number of bytes for audit challenge Type: Number Source: lib/constants.js, line 12 × Search results Close "},"Contract.html":{"id":"Contract.html","title":"Class: Contract","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: Contract Contract new Contract(contract) Represents a storage contract between a renter and a farmer Parameters: Name Type Description contract Object Properties Name Type Description type String Unique identifier for the contract renter_id String Node ID of the renter renter_signature String Renter's cryptographic signature farmer_id String Node ID of the farmer farmer_signature String Farmer's cryptographic signature data_size Number Number of bytes to store data_hash String RIPEMD-160 SHA-256 hash of the data store_begin Number UNIX timestamp to start contract store_end Number UNIX timestamp to end the contract audit_count Number Number of audits renter will perform payment_storage_price Number Total price for storage payment_download_price Number Price per download payment_destination String Bitcoin address to send funds Version: 0 Source: lib/contract/index.js, line 30 Members &lt;static&gt; Schema Defines the JSON Schema of a Contract Source: lib/contract/index.js, line 46 &lt;static&gt; DEFAULTS Defines some default properties of a Contract Source: lib/contract/index.js, line 52 Methods sign(actor, secret) Signs the contract as the given actor Parameters: Name Type Description actor String One of 'farmer' or 'renter' secret Buffer ECDSA private key Source: lib/contract/index.js, line 130 Returns: signature Type String verify(actor, pubkeyhash) Verify the contract signature for the given actor Parameters: Name Type Description actor String One of 'farmer' or 'renter' pubkeyhash Buffer ECDSA nodeID Source: lib/contract/index.js, line 144 Returns: validity Type Boolean update(fields) Applies the provided fields to the contract and validates it Parameters: Name Type Description fields Object Contract properties to update Source: lib/contract/index.js, line 157 Returns: self Type Contract get(field_name) Returns the value for the given contract property Parameters: Name Type Description field_name String Contract property to get Source: lib/contract/index.js, line 170 Returns: value Type String | Number | null set(field_name) Sets the contract property to the given value Parameters: Name Type Description field_name String Contract property to get Source: lib/contract/index.js, line 179 Returns: value Type String | Number | null getHash() Calculates the SHA-256 hash of the serialized contract Source: lib/contract/index.js, line 192 Returns: Type Buffer toObject() Converts the contract to a plain object Source: lib/contract/index.js, line 200 Returns: Type Object toJSON() Converts the contract to JSON string Source: lib/contract/index.js, line 208 Returns: Type String toBuffer() Converts the contract to Buffer Source: lib/contract/index.js, line 216 Returns: Type Buffer &lt;static&gt; fromObject(object) Creates a contract from a plain object Parameters: Name Type Description object Object Dictionary of contract data Source: lib/contract/index.js, line 225 Returns: Type Contract &lt;static&gt; fromJSON(json) Creates a contract from a JSON string Parameters: Name Type Description json String JSON encoded contract Source: lib/contract/index.js, line 234 Returns: Type Contract &lt;static&gt; fromBuffer(buffer) Creates a contract from a Buffer Parameters: Name Type Description buffer Buffer Raw binary blob of contract data Source: lib/contract/index.js, line 243 Returns: Type Contract &lt;static&gt; createValidator() Creates a validator function for data against the schema Source: lib/contract/index.js, line 251 Returns: validator Type function &lt;static&gt; compare(c1, c2) Compares two contracts against each other Parameters: Name Type Description c1 Contract Contract to compare c2 Contract Contract to compare Source: lib/contract/index.js, line 261 Returns: Type Boolean × Search results Close "},"DataChannelClient.html":{"id":"DataChannelClient.html","title":"Class: DataChannelClient","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: DataChannelClient DataChannelClient new DataChannelClient(contact) Creates a data channel client for sending and receiving consigned file shards Parameters: Name Type Description contact Object Properties Name Type Description address String The address of the target farmer port Number The port of the target farmer Source: lib/datachannel/client.js, line 17 Methods retrieve(token, hash) Creates a Readable Stream for the token and hash that receives the data Parameters: Name Type Description token String The RETRIEVE token supplied by the farmer hash String The hash of the data to retrieve Source: lib/datachannel/client.js, line 43 Returns: Type stream.Readable consign(token, data) Creates a Writable Stream for the token and hash that stores the data Parameters: Name Type Description token String The CONSIGN token supplied by the farmer data Buffer The data to store Source: lib/datachannel/client.js, line 58 &lt;static&gt; getChannelURL(contact) Returns the URI of the contact's data channel Parameters: Name Type Description contact Object Source: lib/datachannel/client.js, line 98 × Search results Close "},"KeyPair.html":{"id":"KeyPair.html","title":"Class: KeyPair","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: KeyPair KeyPair new KeyPair(privkey) Represents a ECDSA key pair Parameters: Name Type Description privkey String | Buffer WIF encoded ECDSA private key Source: lib/keypair.js, line 11 Methods getPrivateKey() Returns the private key Source: lib/keypair.js, line 30 Returns: key Type String getPublicKey() Returns the public key Source: lib/keypair.js, line 38 Returns: key Type String getNodeID() Returns the NodeID derived from the public key Source: lib/keypair.js, line 46 Returns: nodeID - RIPEMD160 hash of public key Type String getAddress() Returns the bitcoin address version of the nodeID Source: lib/keypair.js, line 56 Returns: address - Base58 encoded address Type String encrypt(data) Encrypts the data Parameters: Name Type Description data Buffer | String Source: lib/keypair.js, line 67 Returns: Type Buffer decrypt(data) Decrypts the data Parameters: Name Type Description data Buffer | String Source: lib/keypair.js, line 76 Returns: Type Buffer × Search results Close "},"Manager.html":{"id":"Manager.html","title":"Class: Manager","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: Manager Manager new Manager(storage) Interface for managing contracts, shards, and audits Parameters: Name Type Description storage StorageAdapter Storage adapter to use Source: lib/manager.js, line 12 Methods load(hash, callback) Loads the storage Item at the given key Parameters: Name Type Description hash String Shard hash to load data for callback function Called with error or StorageItem Source: lib/manager.js, line 27 save(item, callback) Saves the storage StorageItem at the given key Parameters: Name Type Description item StorageItem The StorageItem to store callback function Called on complete Source: lib/manager.js, line 50 × Search results Close "},"Network.html":{"id":"Network.html","title":"Class: Network","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: Network Network new Network(options) Storj network interface Parameters: Name Type Description options Object Properties Name Type Description keypair KeyPair Node's cryptographic identity manager Manager Persistence management interface loglevel Number Verbosity level 0 - 4 seeds Array List of seed URIs to join datadir String Directory path to store data contact Object Properties Name Type Description address String Public node IP or hostname port Number Listening port for RPC farmer Boolean Flag indicating desire for contracts noforward Boolean Flag for skipping traversal strategies Source: lib/network/index.js, line 41 Methods join(callback) Opens the connection to the network Parameters: Name Type Description callback function Called on successful network join Source: lib/network/index.js, line 111 leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Source: lib/network/index.js, line 152 audit(hash, callback) Look up the storage contract by the hash to find the node who has the shard. Look up the appropriate challenge and send it to the node for verification. If successful, invalidate the challenge and pass, otherwise, invalidate the contract. Parameters: Name Type Description hash String RIPEMD-160 SHA-256 hash of the file to audit callback function Called with validity information Source: lib/network/index.js, line 165 retrieve(hash, callback) Look up the storage contract by the hash to find the node who has the shard, then execute a RETRIEVE RPC to the node and return the data as a buffer. Parameters: Name Type Description hash String RIPEMD-160 SHA-256 hash of the file to retrieve callback function Called with an error or the file buffer Source: lib/network/index.js, line 229 store(data, duration, callback) Create a contract from the data and options supplied and publish it on the network. Keep track of the pending contract until it becomes fulfilled by an OFFER, then issue a CONSIGN RPC to the offerer and callback when the data is stored. Parameters: Name Type Description data Buffer Raw binary blob to store duration String String representation of time for `ms` like &quot;2w&quot; callback function Called on successful store Source: lib/network/index.js, line 288 × Search results Close "},"Protocol.html":{"id":"Protocol.html","title":"Class: Protocol","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: Protocol Protocol new Protocol(options) Defines the Storj protocol methods and mounts on a Network instance to handle Storj protocol messages Parameters: Name Type Description options Object Properties Name Type Description network Network Network instance to bind to Source: lib/network/protocol.js, line 17 Methods handlers() Returns bound references to the protocol handlers Source: lib/network/protocol.js, line 194 × Search results Close "},"Transport.html":{"id":"Transport.html","title":"Class: Transport","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: Transport Transport new Transport(contact, options) Custom HTTP transport adapter Parameters: Name Type Description contact kad.Contact options Object Properties Name Type Description logger Logger cors Boolean tunnelHost String Source: lib/network/transport.js, line 19 × Search results Close "},"Proof.html":{"id":"Proof.html","title":"Class: Proof","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: Proof Proof new Proof(options) Provides interface for proving possession of a file for an Audit Parameters: Name Type Description options Object Properties Name Type Description leaves Array Bottom leaves of the audit merkle tree shard Buffer Binary shard data Source: lib/proof.js, line 14 Methods prove(challenge) Calculate audit response Parameters: Name Type Description challenge String Challenge string sent by auditor Source: lib/proof.js, line 35 Returns: result - Challenge response Type Array × Search results Close "},"StorageAdapter.html":{"id":"StorageAdapter.html","title":"Class: StorageAdapter","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: StorageAdapter StorageAdapter new StorageAdapter() Abstract base class for storage adapter Source: lib/storage/adapter.js, line 10 Methods get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Source: lib/storage/adapter.js, line 21 put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Source: lib/storage/adapter.js, line 34 &lt;abstract&gt; _get(key, callback) Performs lookup and provides an StorageItem to the callback Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js, line 47 &lt;abstract&gt; _put(key, item, callback) Stores the StorageItem Parameters: Name Type Description key String Shard hash item Item Item to store callback function Called on complete Source: lib/storage/adapter.js, line 58 × Search results Close "},"FSStorageAdapter.html":{"id":"FSStorageAdapter.html","title":"Class: FSStorageAdapter","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: FSStorageAdapter FSStorageAdapter new FSStorageAdapter(datadir) Implements a file-system based storage adapter Parameters: Name Type Description datadir String Directory path to store data Source: lib/storage/adapters/fs.js, line 41 Extends StorageAdapter Methods get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#get Source: lib/storage/adapter.js, line 21 put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Inherited From: StorageAdapter#put Source: lib/storage/adapter.js, line 34 × Search results Close "},"RAMStorageAdapter.html":{"id":"RAMStorageAdapter.html","title":"Class: RAMStorageAdapter","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: RAMStorageAdapter RAMStorageAdapter new RAMStorageAdapter() Implements an in-memory storage adapter Source: lib/storage/adapters/ram.js, line 13 Extends StorageAdapter Methods get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#get Source: lib/storage/adapter.js, line 21 put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Inherited From: StorageAdapter#put Source: lib/storage/adapter.js, line 34 × Search results Close "},"StorageItem.html":{"id":"StorageItem.html","title":"Class: StorageItem","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: StorageItem StorageItem new StorageItem(data) Represents a storage item, including contracts, challengs, the shard itself along with metadata describing download count, payments, etc Parameters: Name Type Description data Object Properties Name Type Description hash String | null Shard hash to use as storage key shard Stream | null Raw binary blob of shard contracts Object Dictionary of nodeID:Contract trees Object Dictionary of nodeID:merkleLeaves challenges Object Dictionary of nodeID:privateAuditData meta Object Dictionary of arbitrary nodeID:metadata Source: lib/storage/item.js, line 18 × Search results Close "},"module-storj_utils.html":{"id":"module-storj_utils.html","title":"Module: storj/utils","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Module: storj/utils Source: lib/utils.js, line 1 Methods &lt;static&gt; sha256(input) Returns the SHA-256 hash of the input Parameters: Name Type Description input String | Buffer Data to hash Source: lib/utils.js, line 14 Returns: Type String &lt;static&gt; rmd160(input) Returns the RIPEMD-160 hash of the input Parameters: Name Type Description input String | Buffer Data to hash Source: lib/utils.js, line 23 Returns: Type String &lt;static&gt; rmd160sha256(input) Returns the RIPEMD-160 SHA-256 hash of this input Parameters: Name Type Description input String | Buffer Data to hash Source: lib/utils.js, line 32 Returns: Type String &lt;static&gt; getNextPowerOfTwo(number) Returns the next power of two number Parameters: Name Type Description number Number Source: lib/utils.js, line 41 Returns: Type Number &lt;static&gt; generateToken() Generates a unique token Source: lib/utils.js, line 49 Returns: Type String &lt;static&gt; getContactURL(contact) Returns a stringified URL from the supplied contact object Parameters: Name Type Description contact Object Properties Name Type Description address String port Number nodeID String Source: lib/utils.js, line 61 Returns: Type String × Search results Close "},"Verification.html":{"id":"Verification.html","title":"Class: Verification","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Class: Verification Verification new Verification(proof) Interface for verifying the result of an audit proof Parameters: Name Type Description proof Array The result of Proof#prove Source: lib/verification.js, line 11 Methods verify(root, totaldepth) Verifies the proof given the merkle root and tree depth Parameters: Name Type Description root String Merkle root totaldepth Number Depth of merkle tree Source: lib/verification.js, line 47 Returns: result - Array with expected result and verified result Type Array × Search results Close "},"tutorial-cli-usage.html":{"id":"tutorial-cli-usage.html","title":"Tutorial: Command Line Interface","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Command Line Interface Install globally with NPM: [sudo] npm install -g storjOnce installed, you will have access to the storj command line interface. To make sure everything installed correctly, run: storj --helpThe first time you run the storj CLI, it will walk you through a setup wizard to generate a configuration file and an ECDSA private key which will be encrypted with a passphrase of your choice. &gt; $ storj Let's setup your Storj configuration! :STORJ: &gt;&gt; Enter your public hostname or IP address &gt;&gt; (127.0.0.1) :STORJ: &gt;&gt; Enter the port number the service should use &gt;&gt; (4000) :STORJ: &gt;&gt; Enter the level of verbosity for the logs (0-4) &gt;&gt; (3) :STORJ: &gt;&gt; Accept storage contracts from the network? (true/false) &gt;&gt; (false) :STORJ: &gt;&gt; Enter the URI of a known seed &gt;&gt; (storj://api.metadisk.org:8443/593844dc7f0076a1aeda9a6b9788af17e67c1052) :STORJ: &gt;&gt; Enter the path to store configuration and data &gt;&gt; (/home/gordon/.storjnode) :STORJ: &gt;&gt; Enter the path to store your encrypted private key &gt;&gt; (/home/gordon/.storjnode/id_ecdsa) :STORJ: &gt;&gt; Enter a password to protect your private key &gt;&gt; ********Once the setup wizard has completed, you will be asked to decrypt your key and the program will connect to the network. :STORJ: &gt;&gt; Unlock your private key to start storj &gt;&gt; ******** :STORJ: {info} node created with nodeID db3f125d82885c5e3b78790bd4ed46b3f214ec44 :STORJ: {info} sending FIND_NODE message to {&quot;address&quot;:&quot;dev.metadisk.org&quot;,&quot;port&quot;:7500,&quot;nodeID&quot;:&quot;9f7e84fa954ef691c1de73002ad1cfcd12b13a26&quot;,&quot;lastSeen&quot;:1456424333461} :STORJ: {info} received valid message from {&quot;address&quot;:&quot;162.243.118.98&quot;,&quot;port&quot;:7500,&quot;nodeID&quot;:&quot;9f7e84fa954ef691c1de73002ad1cfcd12b13a26&quot;,&quot;lastSeen&quot;:1456424333732} :STORJ: {info} sending FIND_NODE message to {&quot;address&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;c2ca92d532f2ddba789a83b12496b685df9912c4&quot;,&quot;lastSeen&quot;:1456424333801} :STORJ: {info} sending FIND_NODE message to {&quot;address&quot;:&quot;162.243.117.41&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;f67c29e5d555c8934b75292a136f545938bd3424&quot;,&quot;lastSeen&quot;:1456424333823} :STORJ: {info} sending FIND_NODE message to {&quot;address&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;03132edc1d1ad700f89282456020d84af5007feb&quot;,&quot;lastSeen&quot;:1456424333860} :STORJ: {info} received valid message from {&quot;address&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;db3f125d82885c5e3b78790bd4ed46b3f214ec44&quot;,&quot;lastSeen&quot;:1456424333894} :STORJ: {info} received FIND_NODE from {&quot;address&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;db3f125d82885c5e3b78790bd4ed46b3f214ec44&quot;,&quot;lastSeen&quot;:1456424333424} :STORJ: {info} replying to message to 617833726d3a676a7cd91bd9fb558d859e883272 :STORJ: {info} received valid message from {&quot;address&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;db3f125d82885c5e3b78790bd4ed46b3f214ec44&quot;,&quot;lastSeen&quot;:1456424333947} :STORJ: {info} received FIND_NODE from {&quot;address&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;db3f125d82885c5e3b78790bd4ed46b3f214ec44&quot;,&quot;lastSeen&quot;:1456424333424} :STORJ: {info} replying to message to 36a3e4746172c4ee239998e65248a5017c430814 :STORJ: {info} received valid message from {&quot;address&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;db3f125d82885c5e3b78790bd4ed46b3f214ec44&quot;,&quot;lastSeen&quot;:1456424333989} :STORJ: {info} received valid message from {&quot;address&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;db3f125d82885c5e3b78790bd4ed46b3f214ec44&quot;,&quot;lastSeen&quot;:1456424334014} :STORJ: {info} received valid message from {&quot;address&quot;:&quot;162.243.117.41&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;f67c29e5d555c8934b75292a136f545938bd3424&quot;,&quot;lastSeen&quot;:1456424334157} :STORJ: {info} sending FIND_NODE message to {&quot;address&quot;:&quot;162.243.110.37&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;3c425f6b359d86fdd15e8e7ea10194e905f5256b&quot;,&quot;lastSeen&quot;:1456424334209} :STORJ: {info} sending FIND_NODE message to {&quot;address&quot;:&quot;162.243.48.250&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;6addea0e9fda1373955a2e9deace3182145de60e&quot;,&quot;lastSeen&quot;:1456424334226} :STORJ: {info} received valid message from {&quot;address&quot;:&quot;162.243.110.37&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;3c425f6b359d86fdd15e8e7ea10194e905f5256b&quot;,&quot;lastSeen&quot;:1456424334348} :STORJ: {info} received valid message from {&quot;address&quot;:&quot;162.243.48.250&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;6addea0e9fda1373955a2e9deace3182145de60e&quot;,&quot;lastSeen&quot;:1456424334386} :STORJ: {info} sending FIND_NODE message to {&quot;address&quot;:&quot;162.243.117.41&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;f67c29e5d555c8934b75292a136f545938bd3424&quot;,&quot;lastSeen&quot;:1456424334413} :STORJ: {info} sending FIND_NODE message to {&quot;address&quot;:&quot;dev.metadisk.org&quot;,&quot;port&quot;:7500,&quot;nodeID&quot;:&quot;9f7e84fa954ef691c1de73002ad1cfcd12b13a26&quot;,&quot;lastSeen&quot;:1456424334436} :STORJ: {info} sending FIND_NODE message to {&quot;address&quot;:&quot;162.243.48.250&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;6addea0e9fda1373955a2e9deace3182145de60e&quot;,&quot;lastSeen&quot;:1456424334455} :STORJ: {info} received valid message from {&quot;address&quot;:&quot;162.243.48.250&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;6addea0e9fda1373955a2e9deace3182145de60e&quot;,&quot;lastSeen&quot;:1456424334611} :STORJ: {info} received valid message from {&quot;address&quot;:&quot;162.243.117.41&quot;,&quot;port&quot;:4000,&quot;nodeID&quot;:&quot;f67c29e5d555c8934b75292a136f545938bd3424&quot;,&quot;lastSeen&quot;:1456424334659}You can run multiple instances by specifying a different data directory using the --datadir option. If no configuration has been created for the given data directory, then the setup wizard will run again. × Search results Close "},"tutorial-data-channels.html":{"id":"tutorial-data-channels.html","title":"Tutorial: Transferring File Shards","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Transferring File Shards TODO × Search results Close "},"tutorial-protocol-spec.html":{"id":"tutorial-protocol-spec.html","title":"Tutorial: Protocol Specification","body":" Storj JS Modules storjnodestorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Command Line InterfaceTransferring File ShardsProtocol Specification Protocol Specification Nodes communicate with each other using JSON-RPC 2.0 over HTTPS. This requires farmers (nodes who are contracted by renter to store data) to be publicly addressable and enables access to content from web browsers, mobile phones, and any other devices that speak HTTP (hint: everything). This document outlines the specification for the RPC interface by defining the message structure, required methods, and expected response formats that are needed for a Storj protocol compliant implementation. Request FormatRequests are formed according to the JSON-RPC 2.0 specification and are issued via HTTP POST. The Storj protocol requires the use of named parameters - positional parameters are not supported. Example: { &quot;method&quot;: &quot;PING&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;89cc3ddb4209c6e7e301c10c0257adf4fd85f253&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;3045022100de2e162d017a1e9d0ebfe2a94df3fc847b68281a9882...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The receiving node for this request would then respond with the result, which in the case of a PING message, is simply an acknowledgement that includes the recipient's contact information and required __signature and __nonce: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }In the event that an error occurs, an error property must be added to the response. You still need to include your contact data in the result property of the response: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;OH GOD THERE'S SO MUCH BLOOD&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Joining the NetworkTo join the Storj network, one must only know the contact information for a single &quot;seed&quot; node. A node's contact information is defined as the following three properties: address - hostname, domain, or IP port - port number on which the node is listening nodeID - hash of the node's public key (see below) This information can be expressed as a URI in the following format: storj://10.0.0.2:1337/89cc3ddb4209c6e7e301c10c0257adf4fd85f253In addition to knowing this information about the seed, you also will need to know this information about yourself, so that it can be provided to the nodes with which you are communicating. Your &quot;contact card&quot; must be provided as the contact parameter in every message sent (both requests and responses). This is because messages must be signed with your private key and your nodeID is used by recipients to verify two things: That you own the private key corresponding to your claimed nodeID That the message was in fact sent by you and not an attacker In the Storj network, nodes are identified by the hash of the public portion of an ECDSA key pair. Key pairs are generated using curve SECP256K1 and a node's nodeID is the &quot;pubkeyhash&quot;, defined as: RIPEMD160(SHA256(public_key))This pubkeyhash, combined with a message and signature is enough data to reconstruct the complete public key and is used in the Storj network to sign and verify messages. This ensures that nodes are unable to assume the identity of another node by claiming it has the same nodeID. Joining the network begins with a FIND_NODE request sent to one or more known seeds. The request must include a key, contact (you), along with a __signature and __nonce. FIND_NODEWhen issuing a FIND_NODE request, you provide a key that represents the nodeID of the contact of which you would like to their neighbors. When joining the network, this value is your own nodeID. { &quot;method&quot;: &quot;FIND_NODE&quot;, &quot;params&quot;: { &quot;key&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When a node receives a FIND_NODE RPC message, it must perform a lookup in it's routing table and respond with a nodes array containing the known contacts that are &quot;closest&quot; to the provided key. This is based on the XOR metric as the Storj network uses a Kademlia-based overlay. In addition, if the receiving node is not already aware of the requesting node, it may add the requester to it's own routing table to later inform other requesters. { &quot;result&quot;: { &quot;nodes&quot;: [ { &quot;address&quot;: &quot;10.0.0.4&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, { &quot;address&quot;: &quot;10.0.0.5&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, { &quot;address&quot;: &quot;10.0.0.6&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of the FIND_NODE response, the node attempting to join the network may iteratively send the same FIND_NODE request to contacts that have been newly added to the routing table to build out a wider view of the network. Once the joining node is satisfied with the size of the routing table (or there are no more nodes to discover), this is considered a successful join. Soliciting StorageOnce a node has a sufficiently complete routing table and view of the network, it's time to buddy up with it's neighbors to cooperate in the sharing and relay of publications. A &quot;publication&quot; is essentially a request for storage. When a node in the network wishes to store some data, it notifies it's closest neighbors who, if interested, will respond to negotiate a storage contract. If the neighbors are not offering storage or do not wish to fulfill the terms of the storage contract, they must check to see if any of their neighbors are and forward the publication to them. If no known neighbors are interested, then the publication is sent to a random node in that neighbor's routing table and the process repeats until an interested node fulfills the contract. SUBSCRIBEIn order to know what publications in which your neighbors are interested, we select the 3 nodes in our routing table that are identified by a nodeID that is closest to ours and we issue a SUBSCRIBE message to each of them: { &quot;method&quot;: &quot;SUBSCRIBE&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }To properly handle a SUBSCRIBE message, the recipient must respond with an attenuated bloom filter, with a size 160 bits and a depth of 3. This data structure represents 3 sets of topics to which the recipient's neighbors are subscribed 3 &quot;hops&quot; away. { &quot;result&quot;: { &quot;filters&quot;: [ &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When the original requesting node receives this response, it must update it's local attenuated bloom filter to reflect this response, starting at it's filter at index 1 (since index 0 is reserved for topic to which the node itself is interested). UPDATEAfter the requester updates it's local view of it's neighbor's publication subscriptions, it must in turn update it's neighbors with it's own publication subscriptions by providing it's own attenuated bloom filter: { &quot;method&quot;: &quot;UPDATE&quot;, &quot;params&quot;: { &quot;filters&quot;: [ &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }This method is essentially the &quot;push&quot; version of the SUBSCRIBE message, where instead of providing subscription information as a response, we provide it as a request. Whenever a node subscribes to a new publication topic, it should initiate another SUBSCRIBE/UPDATE loop with it's neighbors to ensure that it may cooperate in publication relay effectively. PUBLISHOnce a node has a view of the publications to which it's neighbors are subscribed, it is capable of issuing a PUBLISH message containing a topic and some content. This message is sent to the node's nearest neighbors, who then relay it to their neighbors based upon their own view of nearby subscriptions. The topic property and the corresponding contents data is arbitrary, but this mechanism is used for publishing &quot;asks&quot; for storage contracts. In this case, the topic is equal to the unique Contract type and the contents is equal to the proposed contract itself: { &quot;method&quot;: &quot;PUBLISH&quot;, &quot;params&quot;: { &quot;uuid&quot;: &quot;7f0c40a2-e465-4f3e-b617-3d53460e34f7&quot;, &quot;topic&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;contents&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: null, &quot;farmer_id&quot;: null, &quot;farmer_signature&quot;: null, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: null }, &quot;publishers&quot;: [ &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; ], &quot;ttl&quot;: 1455228597837, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of a PUBLISH message, a node must first check to make sure it has not already received the publication. This is done by caching the uuid of received publications. If the node has already seen the publication, it should respond with an error message indicating such. The node should also make sure that the publication has not expired by checking the ttl against the current UNIX time. If the node has not previously seen the publication and the message has not expired, then it must check to see if the publication topic is of interest to itself by testing it's attenuated bloom filter at index 0 for the topic. If the node is interested in the publication, it may take action accordingly. In the case of storage contract, the node may begin communicating directly with the original publisher to finalize the contract. Regardless of whether or not the node is interested in the publication, it should acknowledge receipt of the publication to the forwarder: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Then, it must append negative information to the publication message by adding it's own nodeID to the publishers property. Once the message has been updated with the negative information, the node must check it's attenuated bloom filter to see if any of it's neighbors are also interested and, if so, forward the message along to them. If no neighbors are interested, the node must select a random contact from the routing table and forward the message to that contact. Negotiating Storage ContractsWhen a node receives a contract proposal in the form of a PUBLISH message and that proposal meets the recipient's criteria, it can send an OFFER message to the original publisher. OFFERThe offer message must contain the original contract, supplemented with the information that is required of the offering node, which at minimum must include farmer_id, farmer_signature, and payment_destination. The *_signature property value should be the hex-encoded signature of the JSON string representation of the contract, minus both signature fields and with keys sorted alphanumerically. In addition to these fields, the offering node (or &quot;farmer&quot;) may modify the other fields in the contract to their liking if they wish to counter the original offer: { &quot;method&quot;: &quot;OFFER&quot;, &quot;params&quot;: { &quot;contract&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: null, &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The receiving node must check the offer and determine whether or not the modified contract terms are satisfactory. If so, it may finalize the contract by adding it's signature to the renter_signature field: { &quot;result&quot;: { &quot;contract&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: &quot;304402202ccc152ee81fbff7e802c290cabea0c62384bb12...&quot;, &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Alternatively, the receiving node may counter the offer by modifying any of the fields and returning those in the response. The farmer must check the contract against it's signature to determine if the terms of the contract have been changed. This counter offer loop can continue until one party abandons the offer loop or until both parties have signed the same contract. Once a contract has been finalized, each node should store a copy locally that can be keyed by the data_hash. Executing a Storage ContractOnce a storage contract has been signed by both parties, the renter may execute the terms of the contract by issuing a CONSIGN message to the farmer. The purpose of this message is to deliver the data referenced by the contract for the farmer to store. The consign message must contain the hex-encoded data_shard itself, the contract_hash, as well as an audit_tree that contains the bottom leaves of the audit strategy's merkle tree (see Auditing a Storage Contract below). { &quot;method&quot;: &quot;CONSIGN&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;audit_tree&quot;: [ &quot;40a98e19c298631cba19d6c19691360ce08ccf36&quot;, &quot;02f0d971096305e797da9165cd50d4d1bb19590b&quot;, &quot;a44ad75d8aa118cdd73df77ae2543d3e87f94576&quot;, &quot;d84e8bfac28a98df418d0c3029f77a4d9f338e9e&quot;, &quot;7408bb5b0a9eefa56f3234fc83d2423f76c4b857&quot;, &quot;d1b71886c910d34b31cee9e23316abded9ef3fe0&quot;, &quot;0ac89686a12e26aaf952180c0fec5373224c4c1e&quot;, &quot;98c304116e7eb89839ff6c96202eb4c3cbdaf8e0&quot;, &quot;c7937b8a1be9da426e076eff70c5b4edf8a66270&quot;, &quot;c6c2c5cdafb99e4d62185d42e59522d15c33d676&quot;, &quot;1f87ca29e75944aa36e676b3ddf27e49a8ca4fe2&quot;, &quot;8585e356a517535b8a36ec9222b955c5b61a5227&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of a CONSIGN message, the farmer must lookup the reference contract by the supplied data_hash and verify that the renter is authorized to store the data and that the number of items in the audit_tree is equal to the next power of 2 of the audit_count supplied in the original contract. Once verified, the farmer must respond with a generated token that the renter can use to open a data channel with the farmer (via websocket) to deliver the data as a binary stream. In addition, the farmer should verify that the current UNIX time is greater than or equal to the agreed upon store_begin and less than the agreed upon store_end. If everything checks out, the farmer must store the consigned data in such a way that it may later be retrieved by it's hash. Once the farmer has done this, it must acknowledge the renter to confirm: { &quot;result&quot;: { &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Auditing a Storage ContractBefore a renter issues a CONSIGN RPC, it must pre-calculate a series of &quot;challenges&quot;, the number of which must equal the audit_count defined in the negotiated contract. A challenge is simply 32 random bytes encoded as hex. The generated challenges must not be shared until the renter wishes to issue an AUDIT request. When issuing a CONSIGN request, the renter must include an audit_tree which contains the bottom leaves of a merkle tree. Each of the bottom leaves of the tree must be equal to the double RIPEMD160(SHA256(challenge + shard)) encoded as hex. In order to ensure that the resulting merkle tree is properly &quot;balanced&quot;, the number of bottom leaves must be equal to the next power of 2 of the audit count. To ensure this, the additional leaves can simply be the double RIPEMD160(SHA256('')) (the same hash function for an audit, but applied to an empty buffer). To audit a farmer is to request proof that it is still honoring the terms of the storage contract without the need to have them supply the entire data_shard. To do this, the renter must supply the farmer with one of the secret pre-calculated challenges: { &quot;method&quot;: &quot;AUDIT&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;challenge&quot;: &quot;6290bb9e1766bf3fc00eea3bb14146925611026d453e1aa95c32973f8baa5c98&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of an AUDIT request, the farmer must lookup the data_shard by the supplied data_hash, then calculate the single RIPEMD160(SHA256(challenge + shard)). The result of this operation should hash again to match one of the items supplied in the audit_tree property of the original CONSIGN request. In addition to supplying this value as proof that the farmer is still honoring the terms of the contract, the farmer must also provide the uncles required to rebuild the merkle tree. This proof response is specified as a series of nested JSON arrays: { &quot;result&quot;: { &quot;proof&quot;: [ [ [ [ [ &quot;6a2f02144c461e178dc4496c263313e64d7a56ab&quot; ], &quot;efb0dfa48813e3289ba8d16e9e23cf1efa1a99fd&quot; ], &quot;dfb8877b84e7a7496a4b08b2aef6ffd02ccbfccc&quot; ], &quot;82c60f546bcaaabeb908c911b1fadb816e039409&quot; ], &quot;5e265b0256cd471c6af22bd66b59ed9242067654&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of the farmer's proof, the renter must verify that the proof is valid by using it to rebuild the merkle tree. See Verification#verify for an implementation example. If the proof is verified successfully, then the renter is expected to issue a payment to the payment_destination defined in the original contract. The amount of the payment should be equal to: (payment_storage_price / audit_count) + (payment_download_price * downloads_since_last_audit)If the verification fails then the contract is null and no payment is required. Conversely, if the verification succeeds and the renter does not issue the payment in a timely manner, then the contract is also null and the farmer may decide to cease storage of the data. Downloading Consigned DataWhen a renter wishes to retrieve data that is stored under contract, it can issue a RETRIEVE RPC message that includes the data_hash to the farmer storing the data: { &quot;method&quot;: &quot;RETRIEVE&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }After the recipient of the RETRIEVE message verifies the sender's signature it must lookup the storage contract by the supplied data_hash and verify that the sender is the party with which the contract was negotiated. If all tests pass, then the farmer must respond with a generated token to allow the renter to open a data channel (via websocket) to retrieve the data as a binary stream. After the data shard is delivered successfully, the farmer must increment it's record of the downloads_since_last_audit (which must be reset after the next audit). { &quot;result&quot;: { &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; }, &quot;__nonce&quot;: 1455216323786, &quot;__signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }In addition, the renter must check the integrity of the returned data_shard by calculating the hash and checking it against the expected data_hash. If the test fails, then this effectively a failed audit and the contract is null. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
