<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_audit-tools_audit-stream.js.html":{"id":"lib_audit-tools_audit-stream.js.html","title":"Source: lib/audit-tools/audit-stream.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/audit-tools/audit-stream.js 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var constants = require('../constants'); var MerkleTree = require('mtree'); var utils = require('../utils'); var stream = require('readable-stream'); var inherits = require('util').inherits; /** * Represents a streaming audit challenge generator * @constructor * @license LGPL-3.0 * @param {Number} audits - Total number of challenges to generate * @emits AuditStream#finish */ function AuditStream(audits) { if (!(this instanceof AuditStream)) { return new AuditStream(audits); } assert(typeof audits === 'number', 'Invalid number of audits supplied'); assert(!Number.isNaN(audits), 'Invalid number of audits supplied'); assert(Number.isFinite(audits), 'Invalid number of audits supplied'); this._audits = audits; this._finished = false; this._challenges = []; this._inputs = this._prepareChallenges(); stream.Writable.call(this); this.on('finish', this._generateTree.bind(this)); } /** * Triggered when the stream has ended * @event AuditStream#finish */ inherits(AuditStream, stream.Writable); /** * Returns the bottom leaves of the merkle tree for sending to farmer * @returns {Array} leaves - Bottom merkle leaves of audit tree */ AuditStream.prototype.getPublicRecord = function() { assert(this._finished, 'Challenge generation is not finished'); return this._tree.level(this._tree.levels() - 1); }; /** * Returns the challenges, the tree depth, and merkle root * @returns {Object} challenge - Private audit record with challenges */ AuditStream.prototype.getPrivateRecord = function() { assert(this._finished, 'Challenge generation is not finished'); return { root: this._tree.root(), depth: this._tree.levels(), challenges: this._challenges }; }; /** * Implements the underlying write method * @private */ AuditStream.prototype._write = function(bytes, encoding, next) { var self = this; this._inputs.forEach(function(input, i) { if (i &lt; self._audits) { input.update(bytes.toString('hex')); } }); next(); }; /** * Prepares the challenge hasher instances * @private */ AuditStream.prototype._prepareChallenges = function() { var iterations = 0; var inputs = []; while (iterations &lt; this._audits) { var challenge = this._generateChallenge(); var input = this._createResponseInput(challenge); this._challenges.push(challenge); inputs.push(input); iterations++; } while (iterations &lt; utils.getNextPowerOfTwo(this._audits)) { inputs.push(utils.rmd160sha256('')); iterations++; } return inputs; }; /** * Generate the audit merkle tree from a series of challenges * @private */ AuditStream.prototype._generateTree = function() { var self = this; this._finished = true; this._tree = new MerkleTree(this._inputs.map(function(input, i) { if (i &gt;= self._audits) { return input; } else { return utils.rmd160sha256(utils.rmd160(input.digest('hex'))); } }), utils.rmd160sha256); }; /** * Generate a random challenge buffer * @private * @returns {String} Hex encoded random bytes */ AuditStream.prototype._generateChallenge = function() { return crypto.randomBytes(constants.AUDIT_BYTES).toString('hex'); }; /** * Create a challenge response input to merkle tree * @private */ AuditStream.prototype._createResponseInput = function(challenge) { return crypto.createHash('sha256').update(challenge); }; /** * Returns a new instance from the predefined challenges and tree * @param {Array} challenges - The precomputed challenges * @param {Array} tree - The bottom leaves of the existing merkle tree * @returns {AuditStream} */ AuditStream.fromRecords = function(challenges, tree) { assert(Array.isArray(challenges), 'Invalid challenges supplied'); assert(Array.isArray(tree), 'Invalid tree supplied'); assert( tree.length === utils.getNextPowerOfTwo(challenges.length), 'Challenges and tree do not match' ); var auditor = new AuditStream(challenges.length); auditor._challenges = challenges; auditor._tree = new MerkleTree(tree, utils.rmd160sha256); auditor._finished = true; return auditor; }; module.exports = AuditStream; Ã— Search results Close "},"lib_bridge-client_blacklist.js.html":{"id":"lib_bridge-client_blacklist.js.html","title":"Source: lib/bridge-client/blacklist.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/bridge-client/blacklist.js 'use strict'; var assert = require('assert'); var fs = require('fs'); var utils = require('../utils'); var path = require('path'); /** * Manage a blacklist file containing an object with key value pairs of * nodeids: timestamp * @constructor * @license LGPL-3.0 * @see https://github.com/storj/bridge * @param {String} path - blacklist folder location */ function Blacklist(folder) { if (!(this instanceof Blacklist)) { return new Blacklist(folder); } assert.ok(utils.existsSync(folder), 'Invalid Blacklist Folder'); this.blacklistFile = path.join(folder,'.blacklist'); this.blacklist = this._loadFromDisk(); } Blacklist.TTL = 86400000; /** * Push node to blacklist * @param {String} nodeid - Node id to be added to blacklist */ Blacklist.prototype.push = function(nodeid) { this.blacklist[nodeid] = Date.now(); this._saveToDisk(); }; /** * Save blacklist to disk * @private */ Blacklist.prototype._saveToDisk = function() { fs.writeFileSync(this.blacklistFile, JSON.stringify(this.blacklist)); }; /** * Read blacklist from disk and Reap old nodeids * @private */ Blacklist.prototype._loadFromDisk = function() { if (!utils.existsSync(this.blacklistFile)) { fs.writeFileSync(this.blacklistFile, JSON.stringify([])); } return this._reap(JSON.parse(fs.readFileSync(this.blacklistFile))); }; /** * Reap old nodeids from blacklist * @private */ Blacklist.prototype._reap = function(blacklist) { var now = Date.now(); for (var nodeid in blacklist) { if ((blacklist[nodeid] - now) &gt; Blacklist.TTL) { delete blacklist[nodeid]; } } this.blacklist = blacklist; return blacklist; }; /** * Return list of blacklisted nodeids */ Blacklist.prototype.toObject = function() { return Object.keys(this._reap(this.blacklist)); }; module.exports = Blacklist; Ã— Search results Close "},"lib_bridge-client_index.js.html":{"id":"lib_bridge-client_index.js.html","title":"Source: lib/bridge-client/index.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/bridge-client/index.js 'use strict'; var assert = require('assert'); var fs = require('fs'); var querystring = require('querystring'); var request = require('request'); var utils = require('../utils'); var FileDemuxer = require('../file-handling/file-demuxer'); var FileMuxer = require('../file-handling/file-muxer'); var AuditStream = require('../audit-tools/audit-stream'); var DataChannelClient = require('../data-channels/client'); var Contact = require('../network/contact'); var crypto = require('crypto'); var path = require('path'); var mime = require('mime'); var uuid = require('node-uuid'); var merge = require('merge'); var Logger = require('kad-logger-json'); var EventEmitter = require('events').EventEmitter; var UploadState = require('./upload-state'); var Blacklist = require('./blacklist'); var stream = require('readable-stream'); var async = require('async'); /** * Represents a client interface to a given bridge server * @constructor * @license LGPL-3.0 * @see https://github.com/storj/bridge * @see https://storj.io/api.html * @param {String} [uri=https://api.storj.io] - API base URI * @param {Object} options * @param {KeyPair} options.keyPair - KeyPair instance for request signing * @param {Object} options.logger - Logger instance * @param {Number} options.transferConcurrency - Upload concurrency limit * @param {Number} options.transferRetries - Limit number of shard transfer * retries before getting a new contract * @param {Object} options.basicAuth * @param {String} options.basicAuth.email - Email address for HTTP basic auth * @param {String} options.basicAuth.password - Password for HTTP basic auth */ function BridgeClient(uri, options) { if (!(this instanceof BridgeClient)) { return new BridgeClient(uri, options); } this._options = this._checkOptions(uri, options); this._blacklist = new Blacklist(this._options.blacklistFolder); this._logger = this._options.logger; this._transferConcurrency = this._options.transferConcurrency; } /** * Check the options supplied to the constructor * @private */ BridgeClient.prototype._checkOptions = function(uri, options) { options = merge({ baseURI: uri || process.env.STORJ_BRIDGE || 'https://api.storj.io', logger: new Logger(0), transferConcurrency: 6, transferRetries: 3, blacklistFolder: utils.tmpdir() }, options); assert.ok(utils.validateLogger(options.logger), 'Invalid logger supplied'); return options; }; /** * Get the remote Storj Bridge API documentation and version as JSON * @param {Function} callback */ BridgeClient.prototype.getInfo = function(callback) { return this._request('GET', '/', {}, callback); }; /** * Fetches the list of known contacts filtered according to the options * @param {Object} options * @param {Number} options.page - The page number of the contact list to fetch * @param {Boolean} options.connected - Filter results by connection status * @param {Function} callback */ BridgeClient.prototype.getContactList = function(options, callback) { return this._request('GET', '/contacts', options, callback); }; /** * Get the contact information for the given nodeID * @param {String} nodeId - The nodeID of the contact * @param {Function} callback */ BridgeClient.prototype.getContactByNodeId = function(nodeId, callback) { return this._request('GET', '/contacts/' + nodeId, {}, callback); }; /** * Registers a user account * @param {Object} options * @param {String} options.email - Email address for verification email * @param {String} options.password - Password to register (auto hashed) * @param {String} options.redirect - URL to redirect to after verification * @param {String} options.pubkey - Optional ECDSA public key to register * @param {Function} callback */ BridgeClient.prototype.createUser = function(options, callback) { return this._request('POST', '/users', { email: options.email, password: utils.sha256(options.password, 'utf8'), redirect: options.redirect, pubkey: options.pubkey }, callback); }; /** * Deactivates a user account * @param {Object} options * @param {String} options.email - Email address of user to deactivate * @param {String} options.redirect - URL to redirect after verification * @param {Function} callback */ BridgeClient.prototype.destroyUser = function(options, callback) { return this._request('DELETE', '/users/' + options.email, { redirect: options.redirect }, callback); }; /** * Requests a password reset * @param {Object} options * @param {String} options.email - Email address of user to reset password * @param {String} options.password - The cleartext password to reset to * @param {String} options.redirect - URL to redirect adter confirmation * @param {Function} callback */ BridgeClient.prototype.resetPassword = function(options, callback) { return this._request('PATCH', '/users/' + options.email, { password: utils.sha256(options.password, 'utf8'), redirect: options.redirect }, callback); }; /** * Returns list of associated public keys * @param {Function} callback */ BridgeClient.prototype.getPublicKeys = function(callback) { return this._request('GET', '/keys', {}, callback); }; /** * Registers a public key for the caller * @param {String} pubkey - Hex encoded ECDSA (secp256k1) public key * @param {Function} callback */ BridgeClient.prototype.addPublicKey = function(pubkey, callback) { return this._request('POST', '/keys', { key: pubkey }, callback); }; /** * Disassociates the public key from the caller * @param {String} pubkey - Hex encoded ECDSA (secp256k1) public key * @param {Function} callback */ BridgeClient.prototype.destroyPublicKey = function(pubkey, callback) { return this._request('DELETE', '/keys/' + pubkey, {}, callback); }; /** * Lists the caller's file buckets * @param {Function} callback */ BridgeClient.prototype.getBuckets = function(callback) { return this._request('GET', '/buckets', {}, callback); }; /** * Returns the bucket information by ID * @param {String} id - Unique bucket ID * @param {Function} callback */ BridgeClient.prototype.getBucketById = function(id, callback) { return this._request('GET', '/buckets/' + id, {}, callback); }; /** * Creates a new file bucket * @param {Object} data - Bucket parameters for creation * @param {Function} callback */ BridgeClient.prototype.createBucket = function(data, callback) { return this._request('POST', '/buckets', data, callback); }; /** * Removes the bucket * @param {String} id - Unique bucket ID * @param {Function} callback */ BridgeClient.prototype.destroyBucketById = function(id, callback) { return this._request('DELETE', '/buckets/' + id, {}, callback); }; /** * Updates the bucket * @param {String} id - Unique bucket ID * @param {Object} updates - Bucket update parameters * @param {Function} callback */ BridgeClient.prototype.updateBucketById = function(id, updates, callback) { return this._request('PATCH', '/buckets/' + id, updates, callback); }; /** * Lists the files stored in a bucket * @param {String} id - Unique bucket ID * @param {Function} callback */ BridgeClient.prototype.listFilesInBucket = function(id, callback) { return this._request('GET', '/buckets/' + id + '/files', {}, callback); }; /** * Create bucket token * @param {String} id - Unique bucket ID * @param {String} operation - PUSH or PULL (file operation) * @param {Function} callback */ BridgeClient.prototype.createToken = function(id, operation, callback) { return this._request('POST', '/buckets/' + id + '/tokens', { operation: operation }, callback); }; /** * Removes a file from a bucket * @param {String} id - Unique bucket ID * @param {String} file - ID of the file to remove from bucket * @param {Function} callback */ BridgeClient.prototype.removeFileFromBucket = function(id, file, callback) { return this._request( 'DELETE', '/buckets/' + id + '/files/' + file, {}, callback ); }; /** * Creates a file staging frame * @param {Function} callback */ BridgeClient.prototype.createFileStagingFrame = function(callback) { return this._request('POST', '/frames', {}, callback); }; /** * List all of the file staging frames * @param {Function} callback */ BridgeClient.prototype.getFileStagingFrames = function(callback) { return this._request('GET', '/frames', {}, callback); }; /** * Gets the frame by it's ID * @param {String} id - Unique file ID * @param {Function} callback */ BridgeClient.prototype.getFrameFromFile = function(bucket, file, callback) { var self = this; self.listFilesInBucket(bucket, function(err, files) { if (err) { return callback(err); } function _extractFrame(err, frame) { if (err) { return callback(err); } callback(null, frame); } for (var i = 0; i &lt; files.length; i++) { if (files[i].id === file) { return self.getFileStagingFrameById(files[i].frame, _extractFrame); } } callback(new Error('Failed to find file staging frame')); }); }; /** * Fetch an existing file staging frame by it's ID * @param {String} id - Unique frame ID * @param {Function} callback */ BridgeClient.prototype.getFileStagingFrameById = function(id, callback) { return this._request('GET', '/frames/' + id, {}, callback); }; /** * Destroy an existing file staging frame * @param {String} id - Unique frame ID * @param {Function} callback */ BridgeClient.prototype.destroyFileStagingFrameById = function(id, callback) { return this._request('DELETE', '/frames/' + id, {}, callback); }; /** * Adds the given shard metadata to the file staging frame * @param {String} id - Unique frame ID * @param {Object} shard - The shard metadata * @param {Object} options * @param {Number} options.retry - Retry the request this many times if failed * @param {Function} callback */ BridgeClient.prototype.addShardToFileStagingFrame = function(f, s, opt, cb) { var self = this; var retries = 0; var pendingReq = null; if (typeof arguments[2] === 'function') { cb = opt; opt = { retry: 24 }; } function _addShard() { self._logger.info( 'Querying bridge for contract for %s (retry: %s)', s.hash, retries ); pendingReq = self._request('PUT', '/frames/' + f, s, function(err, result) { if (err) { if (opt.retry &gt; retries) { retries++; return _addShard(); } return cb(err); } cb(null, result); }); } _addShard(); return { cancel: function() { opt.retry = 0; pendingReq.abort(); } }; }; /** * Instructs the bridge to find N mirroring farmers for redundancy * @param {String} id - Unique bucket ID * @param {String} token - Token from {@link BridgeClient#createToken} * @param {String} file - Path to file to store * @param {Number} concurrency - Upload concurrency * @param {Function} callback */ BridgeClient.prototype.replicateFileFromBucket = function(id, file, n, cb) { if (typeof n === 'function') { cb = n; n = undefined; } return this._request('POST', '/buckets/' + id + '/mirrors', { file: file, redundancy: n }, cb); }; /** * Stores a file in the bucket * @param {String} id - Unique bucket ID * @param {String} token - Token from {@link BridgeClient#createToken} * @param {String} file - Path to file to store * @param {Function} callback */ BridgeClient.prototype.storeFileInBucket = function(id, token, file, cb) { var self = this; var fileSize = fs.statSync(file).size; if (fileSize &lt;= 0) { return cb(new Error(fileSize +' bytes is not a supported file size.')); } var shardSize = FileDemuxer.getOptimalShardSize( { fileSize: fileSize, shardConcurrency: this._transferConcurrency } ); var uploadState = new UploadState({ id: id, file: file, onComplete: cb, worker: this._shardUploadWorker.bind(this), numShards: Math.ceil(fileSize / shardSize), concurrency: this._transferConcurrency }); self.createFileStagingFrame(function(err, frame) { if (err) { return cb(err); } var demuxer = new FileDemuxer(file, { shardSize: shardSize }); demuxer.on('shard', function(shardStream, index) { self._handleShardStream(shardStream, index, frame, uploadState); }).on('error', cb); }); }; BridgeClient.prototype._shardUploadWorker = function(task, done) { var self = this; self._logger.info( 'Trying to upload shard %s index %s', task.meta.tmpName, task.meta.index ); task.state.cleanQueue.push(task.meta.tmpName); task.shard.on('data', function(data) { task.meta.size += data.length; task.meta.hasher.update(data); task.tmpFile.write(data); }).resume(); task.shard.on('end', task.tmpFile.end.bind(task.tmpFile)); task.tmpFile.on('finish', function() { task.meta.hash = task.meta.hasher.digest(); self._handleShardTmpFileFinish(task.state, task.meta, done); }); }; /** * Handles a demuxed shard and writes it to tmp and updates the state * @private * @param {stream.Readable} shard - Shard stream * @param {Number} i - Index of the demuxed shard * @param {Object} frame - Frame object returned from bridge * @param {UploadState} state - The upload state machine */ BridgeClient.prototype._handleShardStream = function(shard, i, frame, state) { var tmpdir = utils.tmpdir(); var meta = { frame: frame, tmpName: path.join(tmpdir, crypto.randomBytes(6).toString('hex')), size: 0, index: i, hasher: crypto.createHash('sha256'), hash: null, excludeFarmers: this._blacklist.toObject(), transferRetries: 0 }; var tmpFile = fs.createWriteStream(meta.tmpName); var passthrough = new stream.PassThrough(); passthrough.pause(); state.queue.push({ state: state, tmpFile: tmpFile, meta: meta, shard: shard.pipe(passthrough) }); }; /** * Generate audits for shard and add to frame * @private * @param {UploadState} state - The shard upload state machine * @param {Object} meta - Shard metadata reference * @param {Function} done - To be called on task complete */ BridgeClient.prototype._handleShardTmpFileFinish = function(state, meta, done) { var self = this; var hash = utils.rmd160(meta.hash); var auditGenerator = new AuditStream(3); var shardFile = fs.createReadStream(meta.tmpName); self._logger.info('Hash for this shard is: %s', hash); function _handleError(err) { self._logger.warn('Failed to upload shard...'); state.cleanup(); return state.callback(err); } function _teardownAuditListeners() { auditGenerator.removeAllListeners(); } shardFile.on('error', _handleError); state.on('killed', _teardownAuditListeners); shardFile.pipe(auditGenerator).on('finish', function() { if (state.killed) { return done(); } var challenges = auditGenerator.getPrivateRecord().challenges; var tree = auditGenerator.getPublicRecord(); self._logger.info('Audit generation for shard done.'); self._logger.info('Waiting on a storage offer from the network...'); var addShardToFrame = self.addShardToFileStagingFrame(meta.frame.id, { hash: hash, size: meta.size, index: meta.index, challenges: challenges, tree: tree, exclude: self._blacklist.toObject() }, function(err, pointer) { if (state.killed) { return done(); } if (err) { return _handleError(err); } self._startTransfer(pointer, state, meta, done); }); state.removeListener('killed', _teardownAuditListeners); state.on('killed', addShardToFrame.cancel); }); }; /** * Starts a retryable shard transfer operation * @private * @param {Object} pointer - Pointer object returned from bridge * @param {UploadState} state - Upload state machine * @param {Object} meta - Shard metadata reference * @param {Function} done - Task complete callback */ BridgeClient.prototype._startTransfer = function(pointer, state, meta, done) { var self = this; var transferStatus = self._transferShard( new EventEmitter(), meta.tmpName, pointer, state ); state.on('killed', function() { transferStatus.removeAllListeners(); }); self._logger.info('Contract negotiated with: %j', pointer.farmer); transferStatus.on('retry', function() { if (meta.transferRetries &lt; self._options.transferRetries) { meta.transferRetries++; self._logger.info('Retrying shard transfer, pointer: %j', pointer); self._transferShard(transferStatus, meta.tmpName, pointer, state); } else { self._logger.info( 'Shard transfer failed %s times, getting another contract...', meta.transferRetries ); transferStatus.removeAllListeners(); self._blacklist.push(pointer.farmer.nodeID); meta.transferRetries = 0; self._handleShardTmpFileFinish(state, meta, done); } }); transferStatus.on('finish', self._shardTransferComplete.bind( self, state, meta.frame, done )); }; /** * Finalizes shard transfer and if all complete adds entry to bucket * @private * @param {UploadState} state - Shard upload state machine * @param {Object} frame - Frame object returned from bridge * @param {Function} done - Task completion callback */ BridgeClient.prototype._shardTransferComplete = function(state, frame, done) { state.completed++; this._logger.info( 'Shard transfer completed! %s remaining...', state.numShards - state.completed ); done(); if (state.completed !== state.numShards) { return; } // NB: use the original filename if called from cli var origFileName = path.basename(state.file).split('.crypt')[0]; state.cleanup(); this._logger.info('Transfer finished, creating entry...'); this._request('POST', '/buckets/' + state.bucketId + '/files', { frame: frame.id, mimetype: mime.lookup(origFileName), filename: origFileName }, state.callback); }; /** * Transfers a shard to a specified farmer * @private * @param {events.EventEmitter} emitter - For getting status events * @param {String} tmpName - Path to shard file * @param {Object} pointer - Farmer Contact information * @param {UploadState} state - The upload state machine */ BridgeClient.prototype._transferShard = function(evt, name, pointer, state) { var self = this; var shardFile = fs.createReadStream(name); var client = new DataChannelClient(Contact(pointer.farmer)); function _onErr(err) { self._logger.warn('Failed to transfer shard, reason: %s', err.message); client.removeAllListeners(); evt.emit('retry', name, pointer); } state.on('killed', client.removeAllListeners.bind(client)); client.on('error', _onErr).on('open', function() { self._logger.info('Data channel opened, transferring shard...'); var datachannel = client.createWriteStream( pointer.token, pointer.hash ); function _onStateKilled() { shardFile.unpipe(datachannel); datachannel.end(); datachannel.destroy(); evt.emit('finish'); } state.dataChannels.push(datachannel); shardFile.pipe(datachannel).on('error', _onErr).on('finish', function() { state.removeListener('killed', _onStateKilled); evt.emit('finish'); }); state.on('killed', _onStateKilled); }); return evt; }; /** * Retrieves a series of file pointers from the bucket * @param {Object} options * @param {String} options.bucket - Unique bucket ID * @param {String} options.token - Token from {@link BridgeClient#createToken} * @param {String} options.file - The unique file pointer ID * @param {Number} options.skip - The starting index of pointers to resolve * @param {Number} options.limit - The number of pointers to resolve * @param {Function} callback */ BridgeClient.prototype.getFilePointers = function(options, cb) { var self = this; request({ method: 'GET', baseUrl: self._options.baseURI, uri: '/buckets/' + options.bucket + '/files/' + options.file, headers: { 'x-token': options.token }, qs: { skip: options.skip, limit: options.limit, exclude: Array.isArray(options.exclude) ? options.exclude.join() : null }, json: true }, function(err, res, body) { self._logger.debug('Body: %s', JSON.stringify(body)); if (err) { return cb(err); } if (res.statusCode !== 200 &amp;&amp; res.statusCode !== 304) { return cb(new Error(body.error || body)); } cb(null, body); }); }; /** * Create a readable datachannel stream from the supplied file pointer * @private * @param {Object} pointer * @param {Function} callback */ BridgeClient.prototype._createInputFromPointer = function(pointer, callback) { var dcx = new DataChannelClient(new Contact(pointer.farmer)); dcx.on('open', function() { callback(null, dcx.createReadStream(pointer.token, pointer.hash)); }); dcx.on('error', function(err) { dcx.removeAllListeners('open'); callback(err); }); }; /** * Open a series of data channels based on the returned value of * {@link BridgeClient#getFilePointers} to resolve all the shards and * reassemble them together as a binary stream * @param {Array} pointers - Result of {@link BridgeClient#getFilePointers} * @param {Function} callback */ BridgeClient.prototype.resolveFileFromPointers = function(pointers, callback) { var self = this; var muxer = new FileMuxer({ shards: pointers.length, length: pointers.reduce(function(a, b) { return { size: a.size + b.size }; }, { size: 0 }).size }); var prematureMuxerError = null; function _addInputToMultiplexer(pointer, onInputAdded) { if (!pointer) { return onInputAdded(); } self._createInputFromPointer(pointer, function(err, inputStream) { if (err) { err.pointer = pointer; muxer.emit('error', err); return onInputAdded(); } // NB: Trick the multiplexer into letting us incrementally modify it's // NB: internal state so we can add input sources after initialization if (muxer._added === muxer._shards) { muxer._length += pointer.size; muxer._shards++; } muxer.addInputSource(inputStream); onInputAdded(); }); } var queue = async.queue(_addInputToMultiplexer, 1); function _addPointerToInputQueue(done) { queue.push(pointers.shift(), done); } function _handlePrematureMuxerError(err) { prematureMuxerError = err; } muxer.on('error', _handlePrematureMuxerError); muxer.on('drain', _addPointerToInputQueue.bind(null, null)); async.times( this._transferConcurrency, function addInputSource(n, next) { _addPointerToInputQueue(next); }, function onInputsAdded() { if (prematureMuxerError) { return callback(prematureMuxerError); } muxer.removeListener('error', _handlePrematureMuxerError); callback(null, muxer, queue); } ); }; /** * Create a readable stream from the given bucket and file id * @param {String} bucket - The unique bucket ID * @param {String} file - The unique file ID * @param {Object} [options] * @param {Array} [options.exlude] - Exclude these nodeID's from pointers * @param {Function} callback - Receives (err, stream) */ BridgeClient.prototype.createFileStream = function(bucket, file, opt, cb) { var self = this; var skip = -6; var limit = 6; var resolved = false; if (typeof opt === 'function') { cb = opt; opt = {}; } function _getPullToken(done) { self._logger.info('Creating retrieval token...'); self.createToken(bucket, 'PULL', function(err, token) { if (err) { return done(err); } done(null, token.token); }); } function _getPointerSlice(token, done) { self._logger.info('Resolving %s file pointers...', limit); self.getFilePointers({ bucket: bucket, token: token, file: file, skip: skip += limit, limit: limit, exclude: opt.exclude }, function(err, pointers) { if (err) { return done(err); } done(null, pointers); }); } function _createStreamAndQueue(pointers, done) { self.resolveFileFromPointers(pointers, function(err, stream, queue) { if (err) { return done(err); } done(null, stream, queue); }); } function _resolveNextSlice(queue, done) { _getPullToken(function(err, token) { if (err) { return done(err); } _getPointerSlice(token, function(err, pointers) { if (err) { return done(err); } if (pointers.length === 0) { resolved = true; return done(); } self._logger.info( 'Downloading file slice from %s channels.', pointers.length ); async.eachSeries(pointers, queue.push.bind(queue), done); }); }); } async.waterfall([ _getPullToken, _getPointerSlice, _createStreamAndQueue ], function(err, stream, queue) { if (err) { return cb(err); } cb(null, stream); // NB: Provide the stream as soon as it is ready async.until(function _pointersAreExhausted() { return resolved; }, _resolveNextSlice.bind(null, queue), function(err) { if (err) { stream.emit('error', err); } }); }); }; /** * Create a stream for a given slice of a file * @param {Object} options * @param {String} options.bucket - The bucket ID * @param {String} options.file - The file ID * @param {Number} options.start - The byte position to start slice * @param {Number} options.end - The byte position to end slice */ BridgeClient.prototype.createFileSliceStream = function(options, callback) { var self = this; self.getFrameFromFile(options.bucket, options.file, function(err, frame) { if (err) { return callback(err); } var sliceOpts = self._getSliceParams(frame, options.start, options.end); self.createToken(options.bucket, 'PULL', function(err, token) { if (err) { return callback(err); } self.getFilePointers({ bucket: options.bucket, token: token.token, file: options.file, skip: sliceOpts.skip, limit: sliceOpts.limit }, function(err, pointers) { if (err) { return callback(err); } self.resolveFileFromPointers(pointers, function(err, stream) { if (err) { return callback(err); } callback(null, stream.pipe(utils.createStreamTrimmer( sliceOpts.trimFront, options.end - options.start ))); }); }); }); }); }; /** * Sends a request to the storj bridge * @private * @param {String} method - HTTP verb * @param {String} path - Endpoint path * @param {Object} params - Request parameters * @param {Function} callback - Return the raw response stream? */ BridgeClient.prototype._request = function(method, path, params, callback) { var self = this; var opts = { baseUrl: this._options.baseURI, uri: path, method: method }; params.__nonce = uuid.v4(); if (['GET', 'DELETE'].indexOf(method) !== -1) { opts.qs = params; opts.json = true; } else { opts.json = params; } this._authenticate(opts); self._logger.debug('Request: %s', JSON.stringify(opts)); return request(opts, function(err, res, body) { self._logger.debug('Body: %s', JSON.stringify(body)); if (err) { return callback(err); } if (res.statusCode &gt;= 400) { return callback(new Error(body.error || body)); } callback(null, body); }); }; /** * Adds authentication headers to request object * @private * @param {Object} opts - Options parameter passed to request * @return {Object} */ BridgeClient.prototype._authenticate = function(opts) { if (this._options.keyPair) { var payload = ['GET', 'DELETE'].indexOf(opts.method) !== -1 ? querystring.stringify(opts.qs) : JSON.stringify(opts.json); var contract = [opts.method, opts.uri, payload].join('\\n'); opts.headers = opts.headers || {}; opts.headers['x-pubkey'] = this._options.keyPair.getPublicKey(); opts.headers['x-signature'] = this._options.keyPair.sign(contract, { compact: false }); } else if (this._options.basicauth) { opts.auth = { user: this._options.basicauth.email, pass: utils.sha256(this._options.basicauth.password, 'utf8') }; } return opts; }; /** * Returns the skip/limit params for downloading a file slice * @private * @param {Object} frame - The frame object from the bridge * @param {Number} bytesStart - The starting byte for slice * @param {Number} bytesEnd - The ending byte for slice */ BridgeClient.prototype._getSliceParams = function(frame, bytesStart, bytesEnd) { var skip = 0; var limit = 0; var count = 0; var trimFront = 0; var trimBack = 0; var trimFrontSet = false; var trimBackSet = false; frame.shards.forEach(function(shard) { count += shard.size; if (bytesStart &gt; count) { skip++; } else if (!trimFrontSet) { trimFront = count - bytesStart; trimFrontSet = true; } if (bytesEnd &gt; count) { limit++; } else if (!trimBackSet){ trimBack = count - bytesEnd; trimBackSet = true; } }); return { skip: skip, limit: limit, trimFront: trimFront, trimBack: trimBack }; }; module.exports = BridgeClient; Ã— Search results Close "},"lib_network_contact.js.html":{"id":"lib_network_contact.js.html","title":"Source: lib/network/contact.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/contact.js 'use strict'; var kad = require('kad'); var inherits = require('util').inherits; var version = require('../version'); /** * Represents a Storj contact (or peer) * @constructor * @license LGPL-3.0 * @param {Object} contact * @param {String} contact.address - Hostname of IP address * @param {Number} contact.port - RPC port number * @param {String} contact.nodeID - 160 bit node ID (hex) * @param {String} [contact.userAgent] - User agent identifier * @param {String} contact.protocol - Semver tag for compatibility */ function Contact(options) { if (!(this instanceof Contact)) { return new Contact(options); } this.userAgent = options.userAgent || version.software; this.protocol = options.protocol || version.protocol; kad.contacts.AddressPortContact.call(this, options); } inherits(Contact, kad.contacts.AddressPortContact); module.exports = Contact; Ã— Search results Close "},"lib_network_contact-checker.js.html":{"id":"lib_network_contact-checker.js.html","title":"Source: lib/network/contact-checker.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/contact-checker.js 'use strict'; var Contact = require('./contact'); var net = require('net'); var assert = require('assert'); var merge = require('merge'); /** * Handles checking if a contact is reachable * @constructor * @license AGPL-3.0 * @param {Object} options * @param {Number} [options.timeout=2000] - Milliseconds to wait for timeout * @extends {EventEmitter} */ function ContactChecker(options) { if (!(this instanceof ContactChecker)) { return new ContactChecker(options); } this._options = merge(Object.create(ContactChecker.DEFAULTS), options); } ContactChecker.DEFAULTS = { timeout: 2000 }; /** * Opens a connection to the contact to ensure it's reachable * @param {Contact} contact - The contact to check * @param {ContactChecker~checkCallback} */ ContactChecker.prototype.check = function(contact, callback) { assert(contact instanceof Contact, 'Invalid contact supplied'); var conn = null; var timeout = setTimeout(function() { conn.destroy(); callback(new Error('Host is not reachable')); }, this._options.timeout); function _connectListener() { clearTimeout(timeout); conn.destroy(); callback(null); } function _errorListener(err) { clearTimeout(timeout); conn.destroy(); callback(err); } conn = net.connect(contact.port, contact.address, _connectListener); conn.on('error', _errorListener); }; /** * @callback ContactChecker~checkCallback * @param {Error} [error] */ module.exports = ContactChecker; Ã— Search results Close "},"lib_contract_index.js.html":{"id":"lib_contract_index.js.html","title":"Source: lib/contract/index.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/contract/index.js 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var merge = require('merge'); var JSONSchema = require('jsen'); var stringify = require('json-stable-stringify'); var bitcore = require('bitcore-lib'); var constants = require('../constants'); var Message = require('bitcore-message'); var ms = require('ms'); /** * Represents a storage contract between a renter and a farmer * @constructor * @license AGPL-3.0 * @version 0 * @param {Object} contract * @param {String} contract.type - Unique identifier for the contract * @param {String} contract.renter_id - Node ID of the renter * @param {String} contract.renter_signature - Renter's cryptographic signature * @param {String} contract.farmer_id - Node ID of the farmer * @param {String} contract.farmer_signature - Farmer's cryptographic signature * @param {Number} contract.data_size - Number of bytes to store * @param {String} contract.data_hash - RIPEMD-160 SHA-256 hash of the data * @param {Number} contract.store_begin - UNIX timestamp to start contract * @param {Number} contract.store_end - UNIX timestamp to end the contract * @param {Number} contract.audit_count - Number of audits renter will perform * @param {Number} contract.payment_storage_price - Total price for storage * @param {Number} contract.payment_download_price - Price per download * @param {String} contract.payment_destination - Bitcoin address to send funds * @param {Object} criteria * @param {Number} criteria.size - Criteria degree OPCODE * @param {Number} criteria.duration - Criteria degree OPCODE * @param {Number} criteria.availability - Criteria degree OPCODE * @param {Number} criteria.speed - Criteria degree OPCODE */ function Contract(contract, criteria) { if (!(this instanceof Contract)) { return new Contract(contract, criteria); } this._properties = merge(Object.create(Contract.DEFAULTS), contract); this._validator = Contract.createValidator(); this._criteria = this._inferCriteria(criteria); this._clean(); assert.ok(this._validate(), 'Invalid contract specification was supplied'); } /** * Defines the JSON Schema of a {@link Contract} * @static */ Contract.Schema = require('./schema.json'); /** * Defines some default properties of a {@link Contract} * @static */ Contract.DEFAULTS = { version: 0, renter_id: null, renter_signature: null, farmer_id: null, farmer_signature: null, data_size: 1234, data_hash: null, store_begin: 2000000000, store_end: 3000000000, audit_count: 10, payment_storage_price: 0, payment_download_price: 0, payment_destination: null }; /** * Defines some default criteria of a {@link Contract} * @static */ Contract.CRITERIA = { size: constants.OPCODE_DEG_MED, duration: constants.OPCODE_DEG_MED, availability: constants.OPCODE_DEG_MED, speed: constants.OPCODE_DEG_MED }; /** * Defines the criteria matrix for a {@link Contract} * @static */ Contract.MATRIX = { size: function(size) { if (size &gt; 0 &amp;&amp; size &lt;= (32 * 1024 * 1024)) { return constants.OPCODE_DEG_LOW; } if (size &gt; (32 * 1024 * 1024) &amp;&amp; size &lt;= (512 * 1024 * 1024)) { return constants.OPCODE_DEG_MED; } if (size &gt; (512 * 1024 * 1024) &amp;&amp; size &lt;= (4096 * 1024 * 1024)) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, duration: function(duration) { if (duration &gt; 0 &amp;&amp; duration &lt;= ms('30d')) { return constants.OPCODE_DEG_LOW; } if (duration &gt; ms('30d') &amp;&amp; duration &lt;= ms('90d')) { return constants.OPCODE_DEG_MED; } if (duration &gt; ms('90d') &amp;&amp; duration &lt;= ms('320d')) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, availability: function(availability) { if (availability &gt;= 0.5 &amp;&amp; availability &lt;= 0.7) { return constants.OPCODE_DEG_LOW; } if (availability &gt; 0.7 &amp;&amp; availability &lt;= 0.9) { return constants.OPCODE_DEG_MED; } if (availability &gt; 0.9 &amp;&amp; availability &lt;= 1) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, speed: function(speed) { if (speed &gt; 0 &amp;&amp; speed &lt;= 6) { return constants.OPCODE_DEG_LOW; } if (speed &gt; 6 &amp;&amp; speed &lt;= 12) { return constants.OPCODE_DEG_MED; } if (speed &gt; 12 &amp;&amp; speed &lt;= 32) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; } }; /** * Removes all properties not in the schema from contract * @private * @param {Object} criteria - Criteria degree opcodes * @returns {Object} */ Contract.prototype._inferCriteria = function(criteria) { var opcodes = Object.create(Contract.CRITERIA); opcodes.size = Contract.MATRIX.size(this.get('data_size')); opcodes.duration = Contract.MATRIX.duration( this.get('store_end') - this.get('store_begin') ); // NB: Do not try to infer availability or speed, should be explicit return merge(opcodes, criteria); }; /** * Removes all properties not in the schema from contract * @private * @returns {Contract} self */ Contract.prototype._clean = function() { var keys = Object.keys(Contract.Schema.properties); for (var field in this._properties) { if (keys.indexOf(field) === -1) { delete this._properties[field]; } } return this; }; /** * Validates the contract specification * @private * @returns {Boolean} validity */ Contract.prototype._validate = function() { return this._validator(this._properties); }; /** * Checks if the contract is complete * @returns {Boolean} completed */ Contract.prototype.isComplete = function() { for (var prop in this._properties) { if (this._properties[prop] === null) { return false; } } return true; }; /** * Returns the string representation of the contract, minus the signature * fields, sorted alphanumerically for signing and verifying * @private * @returns {String} */ Contract.prototype._getSigningData = function() { var sorted = this.toObject(); delete sorted.renter_signature; delete sorted.farmer_signature; return stringify(sorted); }; /** * Signs the contract as the given actor * @param {String} actor - One of 'farmer' or 'renter' * @param {Buffer} secret - ECDSA private key * @returns {String} signature */ Contract.prototype.sign = function(actor, secret) { var property = actor + '_signature'; var message = Message(this._getSigningData()); var signature = message.sign(bitcore.PrivateKey.fromString(secret)); return this.set(property, signature); }; /** * Verify the contract signature for the given actor * @param {String} actor - One of 'farmer' or 'renter' * @param {Buffer} pubkeyhash - ECDSA nodeID * @returns {Boolean} validity */ Contract.prototype.verify = function(actor, pubkeyhash) { if (!pubkeyhash) { return false; } var property = actor + '_signature'; var message = Message(this._getSigningData()); var address = bitcore.Address.fromPublicKeyHash(Buffer(pubkeyhash, 'hex')); return message.verify(address, this.get(property)); }; /** * Applies the provided fields to the contract and validates it * @param {Object} fields - Contract properties to update * @returns {Contract} self */ Contract.prototype.update = function(fields) { for (var prop in fields) { this.set(prop, fields[prop]); } return this; }; /** * Returns the value for the given contract property * @param {String} field_name - Contract property to get * @returns {String|Number|null} value */ Contract.prototype.get = function(field_name) { return this._properties[field_name]; }; /** * Sets the contract property to the given value * @param {String} field_name - Contract property to get * @returns {String|Number|null} value */ Contract.prototype.set = function(field_name, field_value) { this._properties[field_name] = field_value; this._clean(); assert.ok(this._validate(), 'Invalid contract property supplied'); return this._properties[field_name]; }; /** * Calculates the SHA-256 hash of the serialized contract * @returns {Buffer} */ Contract.prototype.getHash = function() { return crypto.createHash('sha256').update(this.toBuffer()).digest(); }; /** * Return OPCODE byte sequence for contract publication topic * @returns {Buffer} */ Contract.prototype.getTopicBuffer = function() { return Contract.createTopic(this._criteria); }; /** * Return OPCODE byte sequence for contract publication topic as hex string * @returns {String} */ Contract.prototype.getTopicString = function() { return this.getTopicBuffer().toString('hex'); }; /** * Converts the contract to a plain object * @returns {Object} */ Contract.prototype.toObject = function() { return JSON.parse(this.toJSON()); }; /** * Converts the contract to JSON string * @returns {String} */ Contract.prototype.toJSON = function() { return stringify(this._properties); }; /** * Converts the contract to Buffer * @returns {Buffer} */ Contract.prototype.toBuffer = function() { return new Buffer(this.toJSON(), 'utf8'); }; /** * Creates a contract from a plain object * @param {Object} object - Dictionary of contract data * @returns {Contract} */ Contract.fromObject = function(object) { return new Contract(object); }; /** * Creates a contract from a JSON string * @param {String} json - JSON encoded contract * @returns {Contract} */ Contract.fromJSON = function(json) { return new Contract(JSON.parse(json)); }; /** * Creates a contract from a Buffer * @param {Buffer} buffer - Raw binary blob of contract data * @returns {Contract} */ Contract.fromBuffer = function(buffer) { return new Contract(JSON.parse(buffer.toString('utf8'))); }; /** * Creates a validator function for data against the schema * @returns {Function} validator */ Contract.createValidator = function() { return JSONSchema(Contract.Schema); }; /** * Create a topical OPCODE byte sequence from the provided criteria * @param {Object} criteria * @param {Number} criteria.size - Criteria degree OPCODE * @param {Number} criteria.duration - Criteria degree OPCODE * @param {Number} criteria.availability - Criteria degree OPCODE * @param {Number} criteria.speed - Criteria degree OPCODE * @returns {Buffer} */ Contract.createTopic = function(criteria) { criteria = merge(Object.create(Contract.CRITERIA), criteria); return new Buffer([ constants.OPCODE_CONTRACT_PREFIX, criteria.size, criteria.duration, criteria.availability, criteria.speed ]); }; /** * Compares two contracts against each other * @param {Contract} c1 - Contract to compare * @param {Contract} c2 - Contract to compare * @returns {Boolean} */ Contract.compare = function(c1, c2) { var contract1 = c1.toObject(); var contract2 = c2.toObject(); var ignored = [ 'renter_id', 'renter_signature', 'farmer_id', 'farmer_signature', 'payment_destination' ]; ignored.forEach(function(prop) { delete contract1[prop]; delete contract2[prop]; }); return JSON.stringify(contract1) === JSON.stringify(contract2); }; module.exports = Contract; Ã— Search results Close "},"lib_data-channels_client.js.html":{"id":"lib_data-channels_client.js.html","title":"Source: lib/data-channels/client.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/data-channels/client.js 'use strict'; var WebSocketClient = require('ws'); var assert = require('assert'); var events = require('events'); var inherits = require('util').inherits; var url = require('url'); var DataChannelPointer = require('./pointer'); var WritableDataChannelStream = require('./writable-stream'); var ReadableDataChannelStream = require('./readable-stream'); /** * Creates a data channel client for sending and receiving consigned file shards * @constructor * @license LGPL-3.0 * @param {Object} contact * @param {String} contact.address - The address of the target farmer * @param {Number} contact.port - The port of the target farmer */ function DataChannelClient(contact) { if (!(this instanceof DataChannelClient)) { return new DataChannelClient(contact); } assert.ok(contact, 'No contact was supplied to constructor'); assert(typeof contact.address === 'string', 'Invalid contact address'); assert(typeof contact.port === 'number', 'Invalid contact port'); events.EventEmitter.call(this); this.contact = contact; this._client = new WebSocketClient(DataChannelClient.getChannelURL(contact)); this._client.on('open', this._handleChannelOpen.bind(this)); this._client.on('error', this._handleChannelError.bind(this)); } /** * Triggered when the connection is opened * @event DataChannelClient#open */ /** * Triggered when a error occurs * @event DataChannelClient#error * @param {Error} error - The error object */ inherits(DataChannelClient, events.EventEmitter); /** * Creates a readable stream from the remote farmer for retrieval of a shard * @param {String} token - The RETRIEVE token supplied by the farmer * @param {String} hash - The hash of the data to retrieve * @returns {stream.Readable} */ DataChannelClient.prototype.createReadStream = function(token, hash) { return new ReadableDataChannelStream(this, token, hash); }; /** * Creates a writable stream from the remote farmer for consignment of a shard * @param {String} token - The CONSIGN token supplied by the farmer * @param {String} hash - The hash of the data to consign * @returns {WritableDataChannelStream} */ DataChannelClient.prototype.createWriteStream = function(token, hash) { return new WritableDataChannelStream(this, token, hash); }; /** * Handles the open event from the underlying client * @private */ DataChannelClient.prototype._handleChannelOpen = function() { this.emit('open'); }; /** * Handles the open event from the underlying client * @private */ DataChannelClient.prototype._handleChannelError = function(err) { this.emit('error', err); }; /** * Returns the URI of the contact's data channel * @static * @param {Object} contact */ DataChannelClient.getChannelURL = function(contact) { return url.format({ protocol: 'ws', slashes: true, hostname: contact.address.trim(), port: contact.port }); }; /** * Creates a Readable or Writable stream from a {@link DataChannelPointer} * @static * @param {DataChannelPointer} pointer - The pointer to create stream * @param {DataChannelClient~getStreamFromPointerCallback} callback */ DataChannelClient.getStreamFromPointer = function(pointer, callback) { assert(pointer instanceof DataChannelPointer, 'Invalid pointer supplied'); var dcx = new DataChannelClient(pointer.farmer); dcx.on('error', callback).on('open', function() { dcx.removeAllListeners('error'); if (pointer.operation === 'PUSH') { callback(null, dcx.createWriteStream(pointer.token, pointer.hash)); } else { callback(null, dcx.createReadStream(pointer.token, pointer.hash)); } }); return dcx; }; /** * This callback is called when the client is open and stream is created * @callback DataChannelClient~getStreamFromPointerCallback * @param {Error|null} err - If opening client failed, an error object * @param {stream.Writable|stream.Readable} stream - The data channel stream */ module.exports = DataChannelClient; Ã— Search results Close "},"lib_data-channels_pointer.js.html":{"id":"lib_data-channels_pointer.js.html","title":"Source: lib/data-channels/pointer.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/data-channels/pointer.js 'use strict'; var assert = require('assert'); var Contact = require('../network/contact'); /** * Represents a pointer for opening a {@link DataChannelClient} stream * @constructor * @license LGPL-3.0 * @param {Contact} contact - The farmer the pointer is for * @param {String} hash - The hash of the data to consign or retrieve * @param {String} token - The authorization token fot the operation * @param {String} [operation=PULL] - The type of operation (PUSH or PULL) */ function DataChannelPointer(contact, hash, token, operation) { if (!(this instanceof DataChannelPointer)) { return new DataChannelPointer(contact, hash, token, operation); } assert(contact instanceof Contact, 'Invalid contact supplied'); assert(typeof hash === 'string', 'Invalid hash supplied'); assert(hash.length === 40, 'Invalid hash supplied'); assert(typeof token === 'string', 'Invalid token supplied'); assert(token.length === 40, 'Invalid token supplied'); this.farmer = contact; this.hash = hash; this.token = token; this.operation = operation || 'PULL'; } module.exports = DataChannelPointer; Ã— Search results Close "},"lib_data-channels_server.js.html":{"id":"lib_data-channels_server.js.html","title":"Source: lib/data-channels/server.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/data-channels/server.js 'use strict'; var ws = require('ws'); var PassThrough = require('readable-stream').PassThrough; var assert = require('assert'); var StorageManager = require('../storage/manager'); var events = require('events'); var inherits = require('util').inherits; var crypto = require('crypto'); var utils = require('../utils'); var constants = require('../constants'); var DataChannelErrors = require('./error-codes'); /** * Creates a data channel server for sending and receiving consigned file shards * @constructor * @license AGPL-3.0 * @param {Object} options * @param {http.Server} options.server - A http(s).Server instance * @param {StorageManager} options.storageManager - Storage manager backend * @param {kad.Logger} options.logger - Logger to use from {@link Network} * @param {Number} [options.tokenTtl=86400000] - Close after idle */ function DataChannelServer(options) { if (!(this instanceof DataChannelServer)) { return new DataChannelServer(options); } this._checkOptions(options); events.EventEmitter.call(this); this._server = options.server; this._manager = options.storageManager; this._log = options.logger; this._ttl = options.tokenTtl || constants.TOKEN_EXPIRE; this._server = new ws.Server({ server: this._server }); this._allowed = {}; this._server.on('connection', this._handleConnection.bind(this)); this._server.on('error', this._handleError.bind(this)); } /** * Triggered when a shard has finished uploading to this instance * @event DataChannelServer#shardUploaded * @param {StorageItem} item - The item associated with the upload */ /** * Triggered when a shard has finished downloading from this instance * @event DataChannelServer#shardDownloaded * @param {StorageItem} item - The item associated with the download */ /** * Triggered when a connection is opened * @event DataChannelServer#connection * @param {WebSocket} socket - The socket connection opened */ /** * Triggered when a error occurs * @event DataChannelServer#error * @param {Error} error - The error object */ inherits(DataChannelServer, events.EventEmitter); /** * Begin accepting data for the given file hash and token * @param {String} token - The authorization token created for transfer * @param {String} filehash - The shard hash to allow for the token */ DataChannelServer.prototype.accept = function(token, filehash) { assert(typeof token === 'string', 'Invalid token supplied'); assert(typeof filehash === 'string', 'Invalid filehash supplied'); this._allowed[token] = { hash: filehash, client: null, expires: Date.now() + this._ttl }; }; /** * Stop accepting data for the given token * @param {String} token - The authorization token created for transfer */ DataChannelServer.prototype.reject = function(token) { assert(typeof token === 'string', 'Invalid token supplied'); if (this._allowed[token] &amp;&amp; this._allowed[token].client) { var client = this._allowed[token].client; if ([ws.CONNECTING, ws.OPEN].indexOf(client.readyState) !== -1) { this._allowed[token].client.close( DataChannelErrors.UNAUTHORIZED_TOKEN, 'The authorization token was rejected' ); } } delete this._allowed[token]; }; /** * Closes the data channel and disconnects all clients */ DataChannelServer.prototype.close = function() { return this._server.close(); }; /** * Checks the options supplied to constructor * @private */ DataChannelServer.prototype._checkOptions = function(options) { assert.ok(options, 'No options were supplied to constructor'); assert( options.storageManager instanceof StorageManager, 'Invalid manager supplied' ); assert.ok(options.logger, 'Invalid logger supplied'); }; /** * Handles incoming connections * @private * @param {Socket} socket - The connected socket object */ DataChannelServer.prototype._handleConnection = function(socket) { var self = this; var token = null; this._log.info('data channel connection opened'); this.emit('connection', socket); socket.on('error', function(err) { self._log.error('data channel connection error: %s', err.message); socket.close(DataChannelErrors.UNEXPECTED, err.message); }); socket.on('message', function(data) { try { data = JSON.parse(data); } catch (err) { return socket.close( DataChannelErrors.INVALID_MESSAGE, 'Failed to parse message' ); } token = data.token; try { self._authorize(token, data.hash); } catch (err) { return socket.close(DataChannelErrors.UNAUTHORIZED_TOKEN, err.message); } self._allowed[token].client = socket; socket.removeAllListeners('message'); switch (data.operation) { case 'PUSH': return self._handleConsignStream(socket, token); case 'PULL': return self._handleRetrieveStream(socket, token); default: return self._handleUnknownStream(socket, token); } }); }; /** * Validates the given token * @private */ DataChannelServer.prototype._authorize = function(token, hash) { var self = this; assert.ok(token, 'You did not supply a token'); assert.ok(self._allowed[token], 'The supplied token is not accepted'); assert.ok(hash, 'You did not supply the data hash'); assert(self._allowed[token].expires &gt; Date.now(), 'Token has expired'); assert(self._allowed[token].client === null, 'Channel is already active'); assert(self._allowed[token].hash === hash, 'Token not valid for hash'); }; /** * Receives the data stream and writes it to storage * @private * @param {stream.Readable} socket - The connected socket * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleConsignStream = function(socket, token) { var self = this; var hasher = crypto.createHash('sha256'); var hash = this._allowed[token].hash; var passthrough = new PassThrough(); var received = 0; passthrough.pause(); socket.on('message', function(data) { received += data.length; passthrough.write(data); }); this._manager.load(hash, function(err, item) { if (err) { socket.close(DataChannelErrors.UNEXPECTED, err.message); return self.reject(token); } var contract = Object.keys(item.contracts)[0]; var shardsize = item.contracts[contract].get('data_size'); if (socket.readyState !== ws.OPEN) { return self.reject(token); } socket.resume(); // If the shard is not writable, it means we already have it, so let's // just respond with a success message if (typeof item.shard.write !== 'function') { return self._closeSocketSuccess(socket, 'Consignment completed', token); } passthrough.on('data', function(chunk) { hasher.update(chunk); item.shard.write(chunk); if (received &gt; shardsize) { socket.removeAllListeners('message'); passthrough.removeAllListeners().end(); item.shard.destroy(); return socket.close( DataChannelErrors.FAILED_INTEGRITY, 'The data transferred exceeds the amount defined in the contract' ); } if (received === shardsize) { socket.removeAllListeners('message'); passthrough.end(); } }).resume(); passthrough.on('end', function() { var calculatedHash = utils.rmd160(hasher.digest()); if (calculatedHash !== hash) { self._log.warn('calculated hash does not match the expected result'); item.shard.destroy(); socket.close( DataChannelErrors.FAILED_INTEGRITY, 'Calculated hash does not match the expected result' ); return self.reject(token); } self._log.debug('Shard upload completed'); item.shard.end(); self._closeSocketSuccess(socket, 'Consignment completed', token); self.emit('shardUploaded', item); }); }); }; /** * Pumps the data through to the client * @private * @param {stream.Readable} socket - The incoming data stream * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleRetrieveStream = function(socket, token) { var self = this; var hash = this._allowed[token].hash; this._manager.load(hash, function(err, item) { if (err) { socket.close(DataChannelErrors.UNEXPECTED, err.message); return self.reject(token); } var filestream = item.shard; filestream.on('data', function(data) { filestream.pause(); if (socket.readyState !== ws.OPEN) { filestream.removeAllListeners(); return self.reject(token); } socket.send(data, { binary: true }, function() { filestream.resume(); }); }); filestream.on('end', function() { self._closeSocketSuccess(socket, 'File transfer complete', token); self.emit('shardDownloaded', item); }); }); }; /** * Closes the stream if it cannot be handled * @private * @param {stream.Readable} stream - The incoming data stream * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleUnknownStream = function(stream, token) { var client = this._allowed[token].client; client.close( DataChannelErrors.INVALID_OPERATION, 'Failed to handle the defined operation' ); this.reject(token); }; /** * Handles binary server errors * @private * @param {Error} err - The error object */ DataChannelServer.prototype._handleError = function(err) { this._log.error('data channel server encountered an error: %s', err.message); this.emit('error', err); }; /** * Sends a success message for operation and rejects the token * @private */ DataChannelServer.prototype._closeSocketSuccess = function(sock, msg, token) { sock.close(1000, msg); this.reject(token); }; module.exports = DataChannelServer; Ã— Search results Close "},"lib_crypto-tools_cipher-key-iv.js.html":{"id":"lib_crypto-tools_cipher-key-iv.js.html","title":"Source: lib/crypto-tools/cipher-key-iv.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/crypto-tools/cipher-key-iv.js 'use strict'; var crypto = require('crypto'); var utils = require('../utils'); /** * Create a new random cipher key and initialization vector * @constructor * @license LGPL-3.0 * @param {String|Buffer} [password] - The unique cipher password * @param {String|Buffer} [salt] - The unique salt */ function DataCipherKeyIv(pass, salt) { if (!(this instanceof DataCipherKeyIv)) { return new DataCipherKeyIv(pass, salt); } if (!pass &amp;&amp; !salt) { pass = crypto.randomBytes(DataCipherKeyIv.PASS_BYTES); salt = crypto.randomBytes(DataCipherKeyIv.SALT_BYTES); } this._pass = Buffer.isBuffer(pass) ? pass : Buffer(pass, 'hex'); this._salt = Buffer.isBuffer(salt) ? salt : Buffer(salt, 'hex'); this._pbkdf2 = crypto.pbkdf2Sync( this._pass, this._salt, 25000, 512, 'sha512' ); } DataCipherKeyIv.PASS_BYTES = 512; DataCipherKeyIv.SALT_BYTES = 32; /** * Returns the cipher key and iv in an array * @returns {Array} */ DataCipherKeyIv.prototype.getCipherKeyIv = function() { return [ Buffer(utils.sha256(this._pbkdf2), 'hex'), Buffer(utils.rmd160(this._salt), 'hex').slice(0, 16) ]; }; /** * Returns the key and iv as an array * @returns {Array} */ DataCipherKeyIv.prototype.toObject = function() { return { pass: this._pass.toString('hex'), salt: this._salt.toString('hex') }; }; /** * Returns the a {@link DataCipherKeyIv} from an object * @param {Object} object * @param {Buffer|String} object.pass - The unique password * @param {Buffer|String} object.salt - The unique salt * @returns {DataCipherKeyIv} */ DataCipherKeyIv.fromObject = function(object) { return new DataCipherKeyIv(object.pass, object.salt); }; module.exports = DataCipherKeyIv; Ã— Search results Close "},"lib_crypto-tools_decrypt-stream.js.html":{"id":"lib_crypto-tools_decrypt-stream.js.html","title":"Source: lib/crypto-tools/decrypt-stream.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/crypto-tools/decrypt-stream.js 'use strict'; var constants = require('../constants'); var inherits = require('util').inherits; var assert = require('assert'); var crypto = require('crypto'); var stream = require('readable-stream'); var DataCipherKeyIv = require('../crypto-tools/cipher-key-iv'); /** * Represents a duplex stream capable of taking encrypted data as input and * producing output decrypted by a {@link DataCipherKeyIv} * @constructor * @license LGPL-3.0 * @param {DataCipherKeyIv} keyiv - Object to use for derivation function * @emits DecryptStream#data * @emits DecryptStream#end */ function DecryptStream(keyiv) { if (!(this instanceof DecryptStream)) { return new DecryptStream(keyiv); } assert(keyiv instanceof DataCipherKeyIv, 'Invalid cipher object supplied'); this._decipher = crypto.createDecipheriv.apply( this, [constants.CIPHER_ALG].concat(keyiv.getCipherKeyIv()) ); stream.Transform.call(this); } inherits(DecryptStream, stream.Transform); /** * Writes to the underlying decipher * @private */ DecryptStream.prototype._transform = function(chunk, enc, callback) { this._decipher.write(chunk); callback(null, this._decipher.read()); }; /** * Ensures there is no more data to be read from decipher * @private */ DecryptStream.prototype._flush = function(callback) { callback(null, this._decipher.read()); }; /** * Triggered when some input bytes have become decrypted output bytes * @event DecryptStream#data * @type {Buffer} */ /** * Triggered when the stream has ended * @event DecryptStream#end */ module.exports = DecryptStream; Ã— Search results Close "},"lib_storage_adapters_embedded.js.html":{"id":"lib_storage_adapters_embedded.js.html","title":"Source: lib/storage/adapters/embedded.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/adapters/embedded.js 'use strict'; var inherits = require('util').inherits; var StorageAdapter = require('../adapter'); var StorageItem = require('../item'); var levelup = require('levelup'); var kfs = require('kfs'); var merge = require('merge'); var path = require('path'); var assert = require('assert'); var utils = require('../../utils'); var mkdirp = require('mkdirp'); /** * Implements an LevelDB/KFS storage adapter interface * @extends {StorageAdapter} * @param {String} storageDirPath - Path to store the level db * @constructor * @license AGPL-3.0 */ function EmbeddedStorageAdapter(storageDirPath) { if (!(this instanceof EmbeddedStorageAdapter)) { return new EmbeddedStorageAdapter(storageDirPath); } this._validatePath(storageDirPath); this._path = storageDirPath; this._db = levelup(path.join(this._path, 'contracts.db'), { maxOpenFiles: EmbeddedStorageAdapter.MAX_OPEN_FILES }); this._fs = kfs(path.join(this._path, 'sharddata.kfs')); this._isOpen = true; } EmbeddedStorageAdapter.SIZE_START_KEY = '0'; EmbeddedStorageAdapter.SIZE_END_KEY = 'z'; EmbeddedStorageAdapter.MAX_OPEN_FILES = 1000; inherits(EmbeddedStorageAdapter, StorageAdapter); /** * Validates the storage path supplied * @private */ EmbeddedStorageAdapter.prototype._validatePath = function(storageDirPath) { if (!utils.existsSync(storageDirPath)) { mkdirp.sync(storageDirPath); } assert(utils.isDirectory(storageDirPath), 'Invalid directory path supplied'); }; /** * Implements the abstract {@link StorageAdapter#_get} * @private * @param {String} key * @param {Function} callback */ EmbeddedStorageAdapter.prototype._get = function(key, callback) { var self = this; this._db.get(key, { fillCache: false }, function(err, value) { if (err) { return callback(err); } var result = new StorageItem(JSON.parse(value)); self._fs.exists(key, function(err, exists) { if (err) { return callback(err); } function _getShardStreamPointer(callback) { var getStream = exists ? self._fs.createReadStream.bind(self._fs) : self._fs.createWriteStream.bind(self._fs); getStream(key, function(err, stream) { if (err) { return callback(err); } result.shard = stream; callback(null, result); }); } _getShardStreamPointer(callback); }); }); }; /** * Implements the abstract {@link StorageAdapter#_peek} * @private * @param {String} key * @param {Function} callback */ EmbeddedStorageAdapter.prototype._peek = function(key, callback) { this._db.get(key, { fillCache: false }, function(err, value) { if (err) { return callback(err); } callback(null, new StorageItem(JSON.parse(value))); }); }; /** * Implements the abstract {@link StorageAdapter#_put} * @private * @param {String} key * @param {StorageItem} item * @param {Function} callback */ EmbeddedStorageAdapter.prototype._put = function(key, item, callback) { var self = this; item.shard = null; // NB: Don't store any shard data here this._db.get(key, { fillCache: false }, function(err, existing) { if (err) { existing = JSON.stringify({}); } var plain = JSON.parse(JSON.stringify(item)); var value = merge.recursive(JSON.parse(existing), plain); self._db.put(key, JSON.stringify(value), { sync: true }, function(err) { if (err) { return callback(err); } callback(null); }); }); }; /** * Implements the abstract {@link StorageAdapter#_del} * @private * @param {String} key * @param {Function} callback */ EmbeddedStorageAdapter.prototype._del = function(key, callback) { var self = this; this._db.del(key + '.info', function(err) { if (err) { return callback(err); } self._fs.unlink(key, function(err) { if (err) { return callback(err); } callback(null); }); }); }; /** * Implements the abstract {@link StorageAdapter#_size} * @private * @param {Function} callback */ EmbeddedStorageAdapter.prototype._size = function(callback) { var self = this; this._db.db.approximateSize( EmbeddedStorageAdapter.SIZE_START_KEY, EmbeddedStorageAdapter.SIZE_END_KEY, function(err, contractDbSize) { if (err) { return callback(err); } self._fs.stat(function(err, stats) { if (err) { return callback(err); } var kfsUsedSpace = stats.reduce(function(stat1, stat2) { return { sBucketStats: { size: stat1.sBucketStats.size + stat2.sBucketStats.size } }; }, { sBucketStats: { size: 0 } }).sBucketStats.size; callback(null, kfsUsedSpace + contractDbSize); }); } ); }; /** * Implements the abstract {@link StorageAdapter#_keys} * @private * @param {Function} callback */ EmbeddedStorageAdapter.prototype._keys = function(callback) { var keys = []; var stream = this._db.createKeyStream(); stream.on('data', function(key) { keys.push(key); }); stream.on('end', function() { stream.removeAllListeners('error'); callback(null, keys); }); stream.on('error', function(err) { stream.removeAllListeners('end'); stream.removeAllListeners('data'); callback(err); }); }; /** * Implements the abstract {@link StorageAdapter#_open} * @private * @param {Function} callback */ EmbeddedStorageAdapter.prototype._open = function(callback) { var self = this; if (!this._isOpen) { return this._db.open(function(err) { if (err) { return callback(err); } self._isOpen = true; callback(null); }); } callback(null); }; /** * Implements the abstract {@link StorageAdapter#_close} * @private * @param {Function} callback */ EmbeddedStorageAdapter.prototype._close = function(callback) { var self = this; if (this._isOpen) { return this._db.close(function(err) { if (err) { return callback(err); } self._isOpen = false; callback(null); }); } callback(null); }; module.exports = EmbeddedStorageAdapter; Ã— Search results Close "},"lib_storage_adapter.js.html":{"id":"lib_storage_adapter.js.html","title":"Source: lib/storage/adapter.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/adapter.js 'use strict'; var stream = require('readable-stream'); var assert = require('assert'); var Item = require('./item'); var Contract = require('../contract'); var EventEmitter = require('events').EventEmitter; var inherits = require('util').inherits; /** * Abstract base class for storage adapter * @constructor * @license AGPL-3.0 */ function StorageAdapter() { if (!(this instanceof StorageAdapter)) { return new StorageAdapter(); } EventEmitter.call(this); } /** * Triggered when the adapter is ready * @event StorageAdapter#ready */ /** * Triggered when a new item is added * @event StorageAdapter#add * @param {StorageItem} item */ /** * Triggered when an item is deleted * @event StorageAdapter#delete * @param {StorageItem} item */ /** * Triggered when an existing item is updated * @event StorageAdapter#update * @param {StorageItem} itemBeforeUpdate * @param {StorageItem} itemAfterUpdate */ inherits(StorageAdapter, EventEmitter); /** * Calls the implemented {@link StorageAdapter#_get} and validates the result * @param {String} key - Shard hash to get metadata for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.get = function(key, callback) { assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); return this._get(key, callback); }; /** * Calls the implemented {@link StorageAdapter#_peek} and validates the result * @param {String} key - Shard hash to get metadata for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.peek = function(key, callback) { assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); return this._peek(key, callback); }; /** * Calls the implemented {@link StorageAdapter#_put} and validates the input * @param {StorageItem} item - Item to write to storage * @param {Function} callback - Called on complete write */ StorageAdapter.prototype.put = function(item, callback) { var self = this; assert(item instanceof Item, 'Invalid storage item supplied'); assert(typeof callback === 'function', 'Callback function must be supplied'); for (var nodeID in item.contracts) { if (item.contracts[nodeID] instanceof Contract) { item.contracts[nodeID] = item.contracts[nodeID].toObject(); } } item.updateTimestamp(); return this.peek(item.hash, function(doesNotExist, existingItem) { self._put(item.hash, item, function(err) { if (err) { return callback(err); } if (doesNotExist) { self.emit('add', item); } else { self.emit('update', existingItem, item); } callback(null); }); }); }; /** * Calls the implemented {@link StorageAdapter#_del} * @param {String} key - Shard hash to delete the data for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.del = function(key, callback) { var self = this; assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); this.peek(key, function(err, item) { if (err) { return callback(err); } return self._del(key, function(err) { if (err) { return callback(err); } self.emit('delete', item); callback(null); }); }); }; /** * Calls the implemented {@link StorageAdapter#_size} * @param {Function} callback - Called with error or number of bytes stored */ StorageAdapter.prototype.size = function(callback) { assert(typeof callback === 'function', 'Callback function must be supplied'); return this._size(callback); }; /** * Calls the implemented {@link StorageAdapter#_keys} and returns a readable * stream containing each stored item * @return {ReadableStream} */ StorageAdapter.prototype.createReadStream = function() { var self = this; var keys = null; var current = 0; return new stream.Readable({ objectMode: true, read: function() { var rstream = this; function handleError(err) { rstream.emit('error', err); rstream.push(null); } if (!keys) { return self._keys(function(err, result) { if (err) { return handleError(err); } keys = result; if (!keys[current]) { return rstream.push(null); } self.peek(keys[current], function(err, item) { if (err) { return handleError(err); } current++; rstream.push(item); }); }); } if (!keys[current]) { return rstream.push(null); } self.peek(keys[current], function(err, item) { if (err) { return handleError(err); } current++; rstream.push(item); }); } }); }; /** * Performs lookup and provides an {@link StorageItem} to the callback * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._get = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Performs lookup and provides an {@link StorageItem} to the callback but does * not initialize any shard read/write stream * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._peek = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Delete the shard data at the given key * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._del = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Stores the {@link StorageItem} * @abstract * @param {String} key - Shard hash * @param {Item} item - Item to store * @param {Function} callback - Called on complete */ StorageAdapter.prototype._put = function(/* item, callback */) { throw new Error('Method not implemented'); }; /** * Returns the hashes of all shards stored * @abstract * @param {Function} callback - Called on complete */ StorageAdapter.prototype._keys = function(/* callback */) { throw new Error('Method not implemented'); }; /** * Returns the number of bytes stored * @abstract * @param {Function} callback - Called on complete */ StorageAdapter.prototype._size = function(/* callback */) { throw new Error('Method not implemented'); }; /** * Opens the storage adapter * @abstract * @param {Function} callback - Called on complete */ StorageAdapter.prototype._open = function(callback) { callback(null); }; /** * Closes the storage adapter * @abstract * @param {Function} callback - Called on complete */ StorageAdapter.prototype._close = function(callback) { callback(null); }; module.exports = StorageAdapter; Ã— Search results Close "},"lib_crypto-tools_encrypt-stream.js.html":{"id":"lib_crypto-tools_encrypt-stream.js.html","title":"Source: lib/crypto-tools/encrypt-stream.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/crypto-tools/encrypt-stream.js 'use strict'; var constants = require('../constants'); var assert = require('assert'); var crypto = require('crypto'); var stream = require('readable-stream'); var inherits = require('util').inherits; var DataCipherKeyIv = require('../crypto-tools/cipher-key-iv'); /** * Represents a duplex stream capable of taking cleartext data as input and * producing output encrypted with {@link DataCipherKeyIv} * @constructor * @license LGPL-3.0 * @param {DataCipherKeyIv} keyiv - Object to use for derivation function * @emits EncryptStream#data * @emits EncryptStream#end */ function EncryptStream(keyiv) { if (!(this instanceof EncryptStream)) { return new EncryptStream(keyiv); } assert(keyiv instanceof DataCipherKeyIv, 'Invalid cipher object supplied'); this._cipher = crypto.createCipheriv.apply( this, [constants.CIPHER_ALG].concat(keyiv.getCipherKeyIv()) ); stream.Transform.call(this); } inherits(EncryptStream, stream.Transform); /** * Writes to the internal cipheriv * @private */ EncryptStream.prototype._transform = function(chunk, enc, callback) { this._cipher.write(chunk); callback(null, this._cipher.read()); }; /** * Ensures that there is no remaining bytes to be read from cipher * @private */ EncryptStream.prototype._flush = function(callback) { callback(null, this._cipher.read()); }; /** * Triggered when some input bytes have become encrypted output bytes * @event EncryptStream#data * @type {Buffer} */ /** * Triggered when the stream has ended * @event EncryptStream#end */ module.exports = EncryptStream; Ã— Search results Close "},"lib_network_interfaces_farmer.js.html":{"id":"lib_network_interfaces_farmer.js.html","title":"Source: lib/network/interfaces/farmer.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/interfaces/farmer.js 'use strict'; var kad = require('kad'); var Network = require('..'); var inherits = require('util').inherits; var StorageItem = require('../../storage/item'); var Contract = require('../../contract'); var merge = require('merge'); var constants = require('../../constants'); var utils = require('../../utils'); /** * Creates and a new farmer interface * @constructor * @license AGPL-3.0 * @extends {Network} * @param {Object} options * @param {String} options.paymentAddress - Optional payment address * @param {Array} options.opcodeSubscriptions - Contract opcodes to farm * @param {Number} options.maxOfferConcurrency - Max offers to have pending * @param {FarmerInterface~negotiator} options.contractNegotiator * @param {KeyPair} options.keyPair - Node's cryptographic identity * @param {StorageManager} options.storageManager - Storage manager backend * @param {String} options.bridgeUri - URL for bridge server seed lookup * @param {Object} options.logger - Logger instance * @param {Array} options.seedList - List of seed URIs to join * @param {String} options.rpcAddress - Public node IP or hostname * @param {Number} options.rpcPort - Listening port for RPC * @param {Boolean} options.doNotTraverseNat - Skip NAT traversal strategies * @param {Number} options.maxTunnels - Max number of tunnels to provide * @param {Number} options.tunnelServerPort - Port for tunnel server to use * @param {Object} options.tunnelGatewayRange * @param {Number} options.tunnelGatewayRange.min - Min port for gateway binding * @param {Number} options.tunnelGatewayRange.max - Max port for gateway binding * @param {Object} [options.rateLimiterOpts] - Options for {@link RateLimiter} * @param {String[]} [options.renterWhitelist] - Node IDs to offer storage to * @emits Network#ready * @property {KeyPair} keyPair * @property {StorageManager} storageManager * @property {kad.Node} node - The underlying DHT node * @property {TriggerManager} triggerManager * @property {BridgeClient} bridgeClient * @property {Contact} contact * @property {Transport} transportAdapter * @property {kad.Router} router - The underlying DHT router * @property {DataChannelServer} dataChannelServer */ function FarmerInterface(options) { if (!(this instanceof FarmerInterface)) { return new FarmerInterface(options); } options = merge.recursive(Object.create(FarmerInterface.DEFAULTS), options); this._hasFreeSpace = true; this._negotiator = options.contractNegotiator; this._pendingOffers = []; this._renterWhitelist = Array.isArray(options.renterWhitelist) ? options.renterWhitelist : null; Network.call(this, options); this._listenForCapacityChanges(options.storageManager); } inherits(FarmerInterface, Network); /** * Called when a contract is found that meets subscription criteria and allows * us to modify the contract terms if we desire and then uses the return value * to determine if we should send the renter an offer * @callback FarmerInterface~negotiator * @param {Contract} contract - The contract object to negotiate * @returns {Boolean} */ FarmerInterface.Negotiator = function(contract, callback) { var self = this; if (this._renterWhitelist) { var renterIsInWhitelist = this._renterWhitelist.indexOf( contract.get('renter_id') ) !== -1; self._logger.debug('renter is whitelisted: %s', renterIsInWhitelist); if (!renterIsInWhitelist) { return callback(false); } } // NB: Only bid on contracts for data we don't have this.storageManager.load(contract.get('data_hash'), function(err, item) { if (err) { self._logger.debug('no storage item available for this shard'); return callback(true); } var renters = Object.keys(item.contracts); if (renters.indexOf(contract.get('renter_id')) === -1) { self._logger.debug('no contract currently staged for this shard'); return callback(true); } if (typeof item.shard.write === 'function') { self._logger.debug('no data currently stored for this shard'); return callback(true); } callback(false); }); }; FarmerInterface.DEFAULTS = { renterWhitelist: null, paymentAddress: '', opcodeSubscriptions: ['0f01020202', '0f02020202', '0f03020202'], contractNegotiator: FarmerInterface.Negotiator, maxOfferConcurrency: constants.MAX_CONCURRENT_OFFERS }; /** * Wraps the super call to {@link Network#join} to listen for contract after * successfully establishing a connection to the network * @param {Function} callback - Called on successful join */ FarmerInterface.prototype.join = function(callback) { var self = this; Network.prototype.join.call(this, function(err) { if (err) { return callback(err); } self._listenForContracts(self._options.opcodeSubscriptions); callback(); }); }; /** * Sends the given contract as an offer to the specified renter * @private * @param {Contract} contract - The contract to include in offer * @param {Contact} renter - The renter who originally published the contract */ FarmerInterface.prototype._sendOfferForContract = function(contract, contact) { var self = this; var message = new kad.Message({ method: 'OFFER', params: { contract: contract.toObject(), contact: self.contact } }); self._logger.debug('Sending offer for contract'); self.transport.send(contact, message, function(err, response) { self._removeContractFromPendingList(contract); if (err) { return self._logger.warn(err.message); } if (response.error || !response.result.contract) { return self._logger.warn( response.error ? response.error.message : 'Renter refused to sign' ); } self._handleOfferRes(response, contract, contact); }); }; /** * Returns the payment address supplied or the derived one from keypair * @returns {String} */ FarmerInterface.prototype.getPaymentAddress = function() { return this._options.paymentAddress || this.keyPair.getAddress(); }; /** * Handles a received contract and negotiates storage * @private * @param {Contract} contract */ FarmerInterface.prototype._negotiateContract = function(contract) { var self = this; contract.set('farmer_id', self.keyPair.getNodeID()); contract.set('payment_destination', self.getPaymentAddress()); contract.sign('farmer', self.keyPair.getPrivateKey()); var item = new StorageItem({ hash: contract.get('data_hash') }); var renterId = contract.get('renter_id'); item.contracts[renterId] = contract.toObject(); item.meta[renterId] = {}; self.storageManager.save(item, function(err) { if (err) { self._removeContractFromPendingList(contract); return self._logger.error(err.message); } if (self.router.getContactByNodeID(renterId)) { return self._sendOfferForContract( contract, self.router.getContactByNodeID(renterId) ); } self.router.findNode(renterId, function(err, nodes) { if (err) { self._removeContractFromPendingList(contract); return self._logger.error(err.message); } var renter = nodes.filter(function(node) { return node.nodeID === renterId; })[0]; if (!renter) { self._removeContractFromPendingList(contract); return self._logger.warn('could not locate renter for offer'); } self._sendOfferForContract(contract, renter); }); }); }; /** * Checks if we should send an offer by checking the pending offers and running * the optional custom negotiator function * @private * @param {Contract} contract * @param {Function} callback */ FarmerInterface.prototype._shouldSendOffer = function(contract, callback) { var self = this; var pendingOffersLength = this._pendingOffers.length; var conOffer = (pendingOffersLength &lt; this._options.maxOfferConcurrency); this._logger.debug( 'pending offers %s is less than concurrency %s: %s', pendingOffersLength, conOffer, this._options.maxOfferConcurrency ); this._negotiator.call(this, contract, function(shouldNegotiate) { self._logger.debug('negotiator returned: %s', shouldNegotiate); self._logger.debug('we have enough free space: %s', self._hasFreeSpace); self.storageManager._storage.size(function(err, usedSpace) { if (err) { self._logger.error('Could not get usedSpace: %s',err.message); return callback(false); } var freeSpace = self.storageManager._options.maxCapacity - usedSpace; callback( (self._pendingOffers.length &lt; self._options.maxOfferConcurrency) &amp;&amp; shouldNegotiate &amp;&amp; self._hasFreeSpace &amp;&amp; (contract.get('data_size') &lt;= freeSpace) ); }); }); }; /** * Adds the contract data hash to the pending offers list * @private * @param {Contract} contract - The contract being negotiated */ FarmerInterface.prototype._addContractToPendingList = function(contract) { var id = contract.get('data_hash') + contract.get('renter_id'); if (this._pendingOffers.indexOf(id) !== -1) { return 0; } return this._pendingOffers.push(id); }; /** * Removes the contract data hash to the pending offers list * @param {Contract} contract - The contract being negotiated * @private */ FarmerInterface.prototype._removeContractFromPendingList = function(contract) { var index = this._pendingOffers.indexOf( contract.get('data_hash') + contract.get('renter_id') ); if (index === -1) { return; } this._pendingOffers.splice(index, 1); }; /** * Handles an offer response from a renter * @private */ FarmerInterface.prototype._handleOfferRes = function(res, contract, renter) { var self = this; var final = null; try { final = Contract.fromObject(res.result.contract); } catch (err) { return self._logger.warn('renter responded with invalid contract'); } if (!final.verify('renter', contract.get('renter_id'))) { return self._logger.warn('renter signature is invalid'); } self.storageManager.load(contract.get('data_hash'), function(err, item) { if (err) { item = new StorageItem({ hash: contract.get('data_hash') }); } item.contracts[renter.nodeID] = contract.toObject(); item.meta[renter.nodeID] = {}; self.storageManager.save(item, utils.noop); }); }; /** * Subscribes to a contract identifier on the network * @private * @param {Array} opcodes */ FarmerInterface.prototype._listenForContracts = function(opcodes) { this.subscribe(opcodes, this._handleContractPublication.bind(this)); }; /** * Updates the internal tracker of free space * @private * @param {StorageManager} manager - The storage manager passed to the interface */ FarmerInterface.prototype._listenForCapacityChanges = function(manager) { var self = this; manager.on('locked', function() { self._hasFreeSpace = false; }); manager.on('unlocked', function() { self._hasFreeSpace = true; }); manager.on('error', function(err) { self._logger.warn('error in storage manager: %s', err.message); }); }; /** * Handles received contract publications * @private * @param {Object} contract - The raw contract object */ FarmerInterface.prototype._handleContractPublication = function(contract) { var self = this; var contractObj; this._logger.debug('received contract offer...'); try { contractObj = Contract.fromObject(contract); } catch (err) { return; // If the contract is invalid just drop it } this._shouldSendOffer(contractObj, function(shouldSendOffer) { if (!shouldSendOffer) { return self._logger.debug('not sending an offer for the contract'); } self._addContractToPendingList(contractObj); self._negotiateContract(contractObj); }); }; module.exports = FarmerInterface; Ã— Search results Close "},"lib_network_index.js.html":{"id":"lib_network_index.js.html","title":"Source: lib/network/index.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/index.js 'use strict'; var url = require('url'); var assert = require('assert'); var merge = require('merge'); var async = require('async'); var kad = require('kad'); var bitcore = require('bitcore-lib'); var constants = require('../constants'); var Message = require('bitcore-message'); var Quasar = require('kad-quasar').Protocol; var utils = require('../utils'); var KeyPair = require('../crypto-tools/keypair'); var StorageManager = require('../storage/manager'); var Protocol = require('./protocol'); var Contact = require('./contact'); var Transport = require('./transport'); var DataChannelServer = require('../data-channels/server'); var TunnelClient = require('../tunnel/client'); var EventEmitter = require('events').EventEmitter; var inherits = require('util').inherits; var RateLimiter = require('./rate-limiter'); var ms = require('ms'); var shuffle = require('knuth-shuffle').knuthShuffle; var BridgeClient = require('../bridge-client'); var ContactChecker = require('./contact-checker'); var TriggerManager = require('../sips').SIP0003.TriggerManager; /** * Storj network interface * @constructor * @license AGPL-3.0 * @param {Object} options * @param {KeyPair} options.keyPair - Node's cryptographic identity * @param {StorageManager} options.storageManager - Storage manager backend * @param {String} options.bridgeUri - URL for bridge server seed lookup * @param {Object} options.logger - Logger instance * @param {Array} options.seedList - List of seed URIs to join * @param {String} options.rpcAddress - Public node IP or hostname * @param {Number} options.rpcPort - Listening port for RPC * @param {Boolean} options.doNotTraverseNat - Skip NAT traversal strategies * @param {Number} options.maxTunnels - Max number of tunnels to provide * @param {Number} options.tunnelServerPort - Port for tunnel server to use * @param {Object} options.tunnelGatewayRange * @param {Number} options.tunnelGatewayRange.min - Min port for gateway bind * @param {Number} options.tunnelGatewayRange.max - Max port for gateway bind * @param {Object} options.rateLimiterOpts - Options for {@link RateLimiter} * @emits Network#ready * @property {KeyPair} keyPair * @property {StorageManager} storageManager * @property {kad.Node} node - The underlying DHT node * @property {TriggerManager} triggerManager * @property {BridgeClient} bridgeClient * @property {Contact} contact * @property {Transport} transportAdapter * @property {kad.Router} router - The underlying DHT router * @property {DataChannelServer} dataChannelServer */ function Network(options) { if (!(this instanceof Network)) { return new Network(options); } this.keyPair = options.keyPair; this.storageManager = options.storageManager; this._pendingContracts = {}; this._tunnelers = kad.Bucket(); this._options = this._checkOptions(options); this._logger = options.logger; this._storage = new kad.storage.MemStore(); this._pubkeys = {}; this._open = false; this._initNetworkInterface(); } inherits(Network, EventEmitter); /** * Triggered when the transport's network interface is ready * @event Network#ready */ /** * Triggered when the node has entered the overlay network * @event Network#connected */ /** * Triggered when the node has exited the overlay network * @event Network#disconnected */ /** * Triggered when an error occurs * @event Network#error */ /** * Triggered when a valid offer is received, but we are not waiting for one * @event Network#unhandledOffer * @param {Contract} contract - The complete contract, signed by us and farmer * @param {Contact} contact - The farmer contact the offer is from */ Network.DEFAULTS = { bridgeUri: 'https://api.storj.io', seedsList: [], rpcAddress: '127.0.0.1', rpcPort: 4000, doNotTraverseNat: false, maxTunnels: 3, tunnelServerPort: 4001, tunnelGatewayRange: { min: 4002, max: 4004 } }; Network.RPC_VALIDATION_EXEMPT = [ 'PROBE', 'FIND_TUNNEL', 'OPEN_TUNNEL' ]; /** * Check the options supplied to the constructor * @private */ Network.prototype._checkOptions = function(options) { assert(options.keyPair instanceof KeyPair, 'Invalid keypair supplied'); assert( options.storageManager instanceof StorageManager, 'Invalid manager supplied' ); assert.ok(this._validateLogger(options.logger), 'Invalid logger supplied'); return merge(Object.create(Network.DEFAULTS), options); }; /** * Validates the logger object supplied * @private */ Network.prototype._validateLogger = function(logger) { return logger &amp;&amp; logger.debug &amp;&amp; logger.warn &amp;&amp; logger.info &amp;&amp; logger.error; }; /** * Binds the transport adapter's hooks and events * @private */ Network.prototype._bindTransportHooks = function() { this.transport.on('error', this._handleTransportError.bind(this)); this.transport.before('serialize', this._signMessage.bind(this)); this.transport.before('receive', this._verifyMessage.bind(this)); this.transport.before('receive', this._checkRateLimiter.bind(this)); this.transport.before('receive', kad.hooks.protocol( this._protocol.getRouteMap() )); this.transport.after('receive', this._updateActivityCounter.bind(this)); }; /** * Opens the connection to the network * @param {Function} callback - Called on successful network join */ Network.prototype.join = function(callback) { var self = this; if (!this._ready) { return this.once('ready', this.join.bind(this, callback)); } this.node = new kad.Node({ transport: this.transport, router: this.router, storage: this._storage, logger: this._logger }); if (typeof callback === 'function') { self.once('error', callback); self.once('connected', function() { if (self.transport._isPublic) { self._listenForTunnelers(); } self.removeListener('error', callback); callback(null, self); }); } function onJoinComplete(err) { if (err) { return self.emit('error', err); } self.emit('connected'); } async.series( [ this._warnIfClockNotSynced.bind(this), // TODO: Make this not fail hard this.storageManager.open.bind(this.storageManager), this._setupTunnelClient.bind(this), ], function(err) { if (err) { return self.emit('error', err); } self._enterOverlay(onJoinComplete); } ); }; /** * Iteratively attempt connection to network via supplied seeds * @private */ Network.prototype._enterOverlay = function(callback) { var self = this; function _trySeeds() { async.detectSeries(self._options.seedList, function(uri, next) { self._logger.info('attempting to join network via %s', uri); self.connect(uri, function(err) { if (err) { self._logger.warn('failed to connect to seed %s', uri); next(false); } else { self._logger.info('connected to the storj network via %s', uri); next(true); } }); }, function(result) { if (!result) { return callback(new Error('Failed to join the network')); } callback(null); }); } if (this._options.seedList.length) { return _trySeeds(); } if (this._options.bridgeUri === null) { self._logger.warn('no bridge uri or seeds provided, not connected'); return callback(null); } this._logger.info('resolving seeds from %s', this._options.bridge); this.bridgeClient.getContactList({ connected: true }, function(err, seeds) { if (err) { return callback( new Error('Failed to discover seeds from bridge: ' + err.message) ); } self._options.seedList = shuffle(seeds).map(utils.getContactURL); _trySeeds(); }); }; /** * Disconnects from the network * @param {Function} callback - Called when successful disconnect */ Network.prototype.leave = function(callback) { var self = this; if (self._tunnelClient &amp;&amp; self._tunnelClient.readyState === TunnelClient.OPEN) { self._tunnelClient.removeAllListeners(); self._tunnelClient.close(); } if (typeof callback === 'function') { this.once('error', callback); this.once('disconnected', function() { this.removeListener('error', callback); callback(null); }); } this.storageManager.close(function(err) { if (err) { return self.emit('error', err); } self.node.disconnect(function(err) { if (err) { return self.emit('error', err); } self.emit('disconnected'); }); }); }; /** * Publishes a topic with content to the network * @param {String} topic - The serialized opcode topic * @param {Object} contents - Arbitrary publication contents * @param {Object} options - Options to pass to kad-quasar */ Network.prototype.publish = function(topic, contents, options) { return this._pubsub.publish(topic, contents, options); }; /** * Subscribes to a topic on the network * @param {String} topic - The serialized opcode topic * @param {Object} handler - Function to handle received publications */ Network.prototype.subscribe = function(topic, handler) { return this._pubsub.subscribe(topic, handler); }; /** * Connects to the node at the given URI * @param {String} uri - The storj protocol URI to connect * @param {Function} callback - Called on connection or error */ Network.prototype.connect = function(uri, callback) { return this.node.connect(this._createContact(uri), callback); }; /** * Returns a Storj contact from the URI * @private * @param {String} uri */ Network.prototype._createContact = function(uri) { var parsed = url.parse(uri); return new Contact({ address: parsed.hostname, port: Number(parsed.port), nodeID: parsed.path.substr(1) }); }; /** * Initilizes the network interface * @private */ Network.prototype._initNetworkInterface = function() { EventEmitter.call(this); this.triggerManager = new TriggerManager(); this.bridgeClient = new BridgeClient(this._options.bridgeUri, { logger: this._logger }); this.contact = new Contact({ address: this._options.rpcAddress, port: this._options.rpcPort, nodeID: this.keyPair.getNodeID() }); this.transport = new Transport(this.contact, { logger: this._logger, cors: true, maxTunnels: this._options.maxTunnels, tunnelServerPort: this._options.tunnelServerPort, tunnelGatewayRange: this._options.tunnelGatewayRange, doNotTraverseNat: this._options.doNotTraverseNat }); this.router = new kad.Router({ transport: this.transport, logger: this._logger }); this._protocol = new Protocol({ network: this }); this._rateLimiter = new RateLimiter(this._options.rateLimiterOpts); this.transport.after('open', this._onTransportOpen.bind(this)); this._startRouterCleaner(); }; /** * Checks the rate limiter and updates it appropriately * @private */ Network.prototype._checkRateLimiter = function(message, contact, next) { if (kad.Message.isResponse(message)) { return next(); // NB: Ignore rate limiter if this is a response message } if (!this._rateLimiter.isLimited(contact.nodeID)) { this._rateLimiter.updateCounter(contact.nodeID); return next(); } var timeLeft = ms(this._rateLimiter.getResetTime()); var response = new kad.Message({ id: message.id, result: {}, error: new Error('Rate limit exceeded, please wait ' + timeLeft) }); this.transport.send(contact, response); }; /** * Set up {@link DataChannelServer} after transport is ready * @private */ Network.prototype._onTransportOpen = function() { this._bindTransportHooks(); this._ready = true; this.dataChannelServer = new DataChannelServer({ server: this.transport._server, storageManager: this.storageManager, logger: this._logger }); this._pubsub = new Quasar(this.router, { logger: this._logger, randomRelay: true }); this.emit('ready'); }; /** * Signs an outgoing message * @private * @param {kad.Message} message * @param {Function} callback */ Network.prototype._signMessage = function(message, callback) { var nonce = Date.now(); var target = message.id + nonce; var signature = null; try { signature = this.keyPair.sign(target); } catch(err) { return callback(err); } if (kad.Message.isRequest(message)) { message.params.nonce = nonce; message.params.signature = signature; } else { message.result.nonce = nonce; message.result.signature = signature; } callback(); }; /** * Verifies that the supplied contact is valid and compatible * @private * @param {Contact} contact */ Network.prototype._validateContact = function(contact, callback) { if (!utils.isCompatibleVersion(contact.protocol)) { this.router.removeContact(contact); return callback(new Error('Protocol version is incompatible')); } if (!utils.isValidContact(contact, process.env.STORJ_ALLOW_LOOPBACK)) { this.router.removeContact(contact); return callback(new Error('Invalid contact data supplied')); } callback(null); }; /** * Verifies an incoming message * @private * @param {kad.Message} message * @param {Contact} contact * @param {Function} callback */ Network.prototype._verifyMessage = function(message, contact, callback) { var self = this; this._validateContact(contact, function(err) { if (err &amp;&amp; Network.RPC_VALIDATION_EXEMPT.indexOf(message.method) === -1) { return callback(err); } var messagekey = kad.Message.isRequest(message) ? 'params' : 'result'; var nonce = message[messagekey].nonce; var signature = message[messagekey].signature; if (Date.now() &gt; (constants.NONCE_EXPIRE + nonce)) { return callback(new Error('Message signature expired')); } var addr = bitcore.Address.fromPublicKeyHash(Buffer(contact.nodeID, 'hex')); var signobj = self._createSignatureObject(signature); self._verifySignature({ message: message, nonce: nonce, signobj: signobj, address: addr, contact: contact, signature: signature }, callback); }); }; /** * Verifies the validity of the supplied signature * @private */ Network.prototype._verifySignature = function(options, callback) { if (!options.signobj) { return callback(new Error('Invalid signature supplied')); } var signedmsg = Message(options.message.id + options.nonce); var ecdsa = new bitcore.crypto.ECDSA(); ecdsa.hashbuf = signedmsg.magicHash(); ecdsa.sig = options.signobj; try { this._pubkeys[options.contact.nodeID] = ecdsa.toPublicKey(); } catch (err) { return callback(err); } if (!signedmsg.verify(options.address, options.signature)) { return callback(new Error('Signature verification failed')); } callback(null); }; /** * Creates a signature object from signature string * @private */ Network.prototype._createSignatureObject = function(signature) { var compactSig; var signobj; try { compactSig = new Buffer(signature, 'base64'); signobj = bitcore.crypto.Signature.fromCompact(compactSig); } catch (err) { return null; } return signobj; }; /** * Proxies error events from the underlying transport adapter * @private * @param {Error} error */ Network.prototype._handleTransportError = function(error) { this._logger.error(error.message); }; /** * Subscribe to tunneler opcodes to manage known tunnelers * @private */ Network.prototype._listenForTunnelers = function() { var self = this; var tunserver = self.transport.tunnelServer; var prefix = Buffer([constants.OPCODE_TUNNELER_PREFIX], 'hex'); var available = Buffer([constants.OPCODE_DEG_LOW], 'hex'); var unavailable = Buffer([constants.OPCODE_DEG_NULL], 'hex'); function announce() { self._pubsub.publish( Buffer.concat([ prefix, tunserver.hasTunnelAvailable() ? available : unavailable ]).toString('hex'), self.contact ); setTimeout(announce, constants.TUNNEL_ANNOUNCE_INTERVAL); } if (this._options.maxTunnels) { announce(); } var tunUp = Buffer.concat([prefix, available]).toString('hex'); var tunDown = Buffer.concat([prefix, unavailable]).toString('hex'); this._pubsub.subscribe([tunUp, tunDown], function(contact, topic) { if (topic === tunUp) { if (!self._tunnelers.addContact(Contact(contact))) { self._tunnelers.removeContact(self._tunnelers.getContact(0)); self._tunnelers.addContact(Contact(contact)); } } else { self._tunnelers.removeContact(Contact(contact)); } }); }; /** * Determines if tunnel is needed * @private * @param {Function} callback */ Network.prototype._setupTunnelClient = function(callback) { var self = this; if (this.transport._isPublic) { return callback(null); } var neighbors = this._options.seedList.map(this._createContact); function _discoverIfReachable() { self._logger.info('requesting probe from nearest neighbor'); self._requestProbe(neighbors[0], function(err, result) { if (err || result.error) { return self._findTunnel(neighbors, callback); } self._logger.info( 'you are publicly reachable, skipping tunnel establishment' ); callback(null); }); } if (!neighbors.length) { if (this._options.bridgeUri === null) { return callback( new Error('Could not find a neighbor to query for probe') ); } return this.bridgeClient.getInfo(function(err, result) { if (err) { return callback(new Error('Failed to get seeds for probe')); } neighbors = result.info['x-network-seeds'].map(self._createContact); _discoverIfReachable(); }); } _discoverIfReachable(); }; /** * Requests a probe from the nearest neighbor * @private */ Network.prototype._requestProbe = function(neighbor, callback) { var message = new kad.Message({ method: 'PROBE', params: { contact: this.contact } }); this.transport.send(neighbor, message, callback); }; /** * Finds a potential tunneler * @private * @param {Array} neighbors * @param {Function} callback */ Network.prototype._findTunnel = function(neighbors, callback) { var self = this; var tunnelers = []; var message = new kad.Message({ method: 'FIND_TUNNEL', params: { contact: this.contact, relayers: [] } }); // NB: If we are going to be tunneled, we better not accept any tunnel // NB: connections from other nodes, so let's override our maxTunnels. this._options.maxTunnels = 0; this.transport.tunnelServer._options.maxTunnels = 0; if (!neighbors.length) { return callback( new Error('Could not find a neighbor to query for tunnels') ); } async.detectSeries(neighbors, function(neighbor, callback) { self._logger.info('requesting tunnelers from neighbor'); self.transport.send(neighbor, message, function(err, resp) { if (err) { return callback(false); } if (!resp.result.tunnels.length) { return callback(false); } tunnelers = tunnelers.concat(resp.result.tunnels); callback(true); }); }, function() { if (!tunnelers.length) { return callback( new Error('Failed to find tunnels from neighbors') ); } self._establishTunnel(tunnelers, callback); }); }; /** * Creates a tunnel to a public node * @private * @param {Function} callback */ Network.prototype._establishTunnel = function(tunnels, callback) { var self = this; var tunnel = null; var alias = null; function established() { return tunnel &amp;&amp; alias; } function openTunnel(done) { if (!tunnels.length) { return done(new Error('No tunnelers were returned')); } var tun = new Contact(tunnels[0]); var msg = kad.Message({ method: 'OPEN_TUNNEL', params: { contact: self.contact } }); tunnels.shift(); self.transport.send(tun, msg, function(err, resp) { if (err) { return done(); } tunnel = resp.result.tunnel; alias = resp.result.alias; done(); }); } async.until(established, openTunnel, function(err) { if (err) { return callback( new Error('Failed to establish tunnel, reason: ' + err.message) ); } var tunnelWasOpened = false; var localAddress = self.transport._server.address(); if (!localAddress) { return callback(new Error( 'Local transport not initialized, refusing to establish new tunnel' )); } self._tunnelClient = new TunnelClient( tunnel, 'http://127.0.0.1:' + localAddress.port, { logger: self._logger } ); self._tunnelClient.on('open', function() { self._logger.info('tunnel successfully established: %j', alias); self.contact.address = alias.address; self.contact.port = alias.port; self._logger.info('testing newly established tunnel: %j', alias); ContactChecker().check(self.contact, function(err) { if (err) { self._logger.warn('tunnel test failed, establishing new tunnel'); return self._tunnelClient.close(); } tunnelWasOpened = true; callback(); }); }); self._tunnelClient.on('close', function onTunnelClosed() { self._logger.warn('tunnel connection closed'); self._tunnelClient.removeAllListeners('error'); self._establishTunnel(tunnels, tunnelWasOpened ? utils.noop : callback); }); self._tunnelClient.on('error', function onTunnelError(err) { self._logger.warn( 'tunnel connection lost, reason: %s', err.message ); self._tunnelClient.removeAllListeners(); self._establishTunnel(tunnels, tunnelWasOpened ? utils.noop : callback); }); self._tunnelClient.open(); }); }; /** * Cleans invalid contacts from routing table * @private */ Network.prototype._cleanRoutingTable = function() { var dropped = []; for (var k in this.router._buckets) { var bucket = this.router._buckets[k]; var bucketList = bucket.getContactList(); for (var i = 0; i &lt; bucketList.length; i++) { var isValidContact = utils.isValidContact( bucketList[i], process.env.STORJ_ALLOW_LOOPBACK ); var isValidProtocol = utils.isCompatibleVersion(bucketList[i].protocol); if (!isValidContact || !isValidProtocol) { dropped.push(bucketList[i]); bucket.removeContact(bucketList[i]); } } } return dropped; }; /** * Cleans the routing table on an interval * @private */ Network.prototype._startRouterCleaner = function() { var self = this; setInterval(function() { self._logger.debug('cleaning bad contacts from routing table'); var dropped = self._cleanRoutingTable(); self._logger.debug('dropping %s bad contacts from router', dropped.length); }, constants.ROUTER_CLEAN_INTERVAL); }; /** * Resets the countdown until network re-entry due to inactivity * @private */ Network.prototype._updateActivityCounter = function() { clearTimeout(this._reentranceCountdown); this._reentranceCountdown = setTimeout( this._enterOverlay.bind(this, utils.noop), constants.NET_REENTRY ); }; /** * Warns the user if their clock is not synchronized with NTP server * @private */ Network.prototype._warnIfClockNotSynced = function(callback) { var self = this; utils.ensureNtpClockIsSynchronized(function(err, delta) { if (err) { self._logger.warn(err.message); } else { self._logger.info('clock is synchronized with ntp, delta: %s', delta); } callback(null); }); }; module.exports = Network; Ã— Search results Close "},"lib_file-handling_file-demuxer.js.html":{"id":"lib_file-handling_file-demuxer.js.html","title":"Source: lib/file-handling/file-demuxer.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/file-handling/file-demuxer.js 'use strict'; var inherits = require('util').inherits; var assert = require('assert'); var stream = require('readable-stream'); var fs = require('fs'); var EventEmitter = require('events').EventEmitter; var merge = require('merge'); var utils = require('../utils'); var os = require('os'); /** * Takes a single file read stream and outputs several output streams, used for * &quot;shredding&quot; a file and creating muliple out destination interfaces * @constructor * @license LGPL-3.0 * @param {String} filePath - Path the file to demultiplex * @param {Object} options * @param {Number} options.shardSize - Size of each shard * @fires FileDemuxer#shard */ function FileDemuxer(filePath, options) { if (!(this instanceof FileDemuxer)) { return new FileDemuxer(filePath, options); } assert( utils.existsSync(filePath), 'File does not exist at the supplied path' ); options = merge(Object.create(FileDemuxer.DEFAULTS), options); this._fileSize = fs.statSync(filePath).size; this._filePosition = 0; this._shardSize = options.shardSize; this._source = fs.createReadStream(filePath); this._currentShardIndex = 0; EventEmitter.call(this); setImmediate(this._openStream.bind(this)); } FileDemuxer.SHARD_MULTIPLES_BACK = 5; FileDemuxer.DEFAULTS = { shardSize: 1024 * 1024 * 8 }; /** * Triggered when the demuxer has a shard ready to stream * @event FileDemuxer#shard * @param {ReadableStream} shard - The file shard as a readable stream */ /** * Triggered when the demuxer has finished writing to all shards * @event FileDemuxer#finish */ inherits(FileDemuxer, EventEmitter); /** * Opens the underyling readable stream * @private */ FileDemuxer.prototype._openStream = function() { if (this._fileSize === 0) { this._currentOutput = new stream.Readable({ read: utils.noop }); return this.emit('error', new Error('File size cannot be 0 Bytes.')); } this._source.on('data', this._handleSourceBytes.bind(this)); this._source.on('end', this._handleSourceEnded.bind(this)); }; /** * Handles incoming data from the source stream * @private */ FileDemuxer.prototype._handleSourceBytes = function(chunk) { if (!this._currentOutput) { this._currentOutput = new stream.Readable({ read: utils.noop }); this.emit('shard', this._currentOutput, this._currentShardIndex); } if (this._needsNewOutputStream()) { this._closeCurrentOutput(); this._currentOutput = new stream.Readable({ read: utils.noop }); this.emit('shard', this._currentOutput, ++this._currentShardIndex); } setImmediate(this._pushBytesToOutput.bind(this, chunk)); }; /** * Closes the current output source and emits a finish event * @private */ FileDemuxer.prototype._handleSourceEnded = function() { this._closeCurrentOutput(); this.emit('finish'); }; /** * Simply pushes the given bytes to the current output * @private */ FileDemuxer.prototype._pushBytesToOutput = function(bytes) { if (bytes) { this._filePosition += bytes.length; } this._currentOutput.push(bytes); }; /** * Simply closes the output stream * @private */ FileDemuxer.prototype._closeCurrentOutput = function() { this._pushBytesToOutput(null); }; /** * Returns a boolean indicating if we should create a new shard stream * @private */ FileDemuxer.prototype._needsNewOutputStream = function() { var expectedIndex = Math.floor(this._filePosition / this._shardSize); return this._currentShardIndex &lt; expectedIndex; }; /** * Determine the optimal shard size given an arbitrary file size in bytes * @param {Object} fileInfo * @param {Number} fileInfo.fileSize - The number of bytes in the given file * @param {Number} fileInfo.shardConcurrency - Num of shards uploaded at once * @param {Number} [acc=1] - Accumulator (number of recursions) * @returns {Number} shardSize */ FileDemuxer.getOptimalShardSize = function(fileInfo, acc) { var accumulator = typeof acc === 'undefined' ? 0 : acc; // Determine hops back by accumulator var hops = (accumulator - FileDemuxer.SHARD_MULTIPLES_BACK) &lt; 0 ? 0 : accumulator - FileDemuxer.SHARD_MULTIPLES_BACK; // Calculate bytemultiple shard size by hops back var shardSize = function(hops) { return (8 * (1024 * 1024)) * Math.pow(2, hops); }; var byteMultiple = shardSize(accumulator); var check = fileInfo.fileSize / byteMultiple; // Determine if bytemultiple is highest bytemultiple that is still &lt;= fileSize if (check &gt; 0 &amp;&amp; check &lt;= 1) { // Certify the number of concurrency * shardSize doesn't exceed freemem while ( hops &gt; 0 &amp;&amp; (os.freemem() / shardSize(hops) &lt;= fileInfo.shardConcurrency) ) { hops = hops - 1 &lt;= 0 ? 0 : hops - 1; } return shardSize(hops); } return this.getOptimalShardSize(fileInfo, ++accumulator); }; module.exports = FileDemuxer; Ã— Search results Close "},"lib_file-handling_file-muxer.js.html":{"id":"lib_file-handling_file-muxer.js.html","title":"Source: lib/file-handling/file-muxer.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/file-handling/file-muxer.js 'use strict'; var assert = require('assert'); var stream = require('readable-stream'); var inherits = require('util').inherits; var merge = require('merge'); /** * Accepts multiple ordered input sources and exposes them as a single * contiguous readable stream. Used for re-assembly of shards. * @constructor * @license LGPL-3.0 * @param {Object} options * @param {Number} options.shards - Number of total shards to be multiplexed * @param {Number} options.length - Number of total bytes of input * @param {Number} options.sourceDrainWait - Time to wait for a new input after * all inputs are drained before entire stream is consumed * @param {Number} options.sourceIdleWait - Time to wait for source to make * more data available between next read * @fires FileMuxer#drain */ function FileMuxer(options) { if (!(this instanceof FileMuxer)) { return new FileMuxer(options); } this._checkOptions(options); this._shards = options.shards; this._length = options.length; this._inputs = []; this._bytesRead = 0; this._added = 0; this._options = merge(Object.create(FileMuxer.DEFAULTS), options); stream.Readable.call(this); } FileMuxer.DEFAULTS = { sourceDrainWait: 2000, sourceIdleWait: 50 }; /** * Triggered when the muxer has drained one of the supplied inputs * @event FileMuxer#drain * @param {ReadableStream} input - The drained input stream */ inherits(FileMuxer, stream.Readable); /** * Checks the options supplied to the constructor * @private */ FileMuxer.prototype._checkOptions = function(options) { var shards = options.shards; var length = options.length; assert(typeof shards === 'number', 'You must supply a shards parameter'); assert(shards &gt; 0, 'Cannot multiplex a 0 shard stream'); assert(typeof length === 'number', 'You must supply a length parameter'); assert(length &gt; 0, 'Cannot multiplex a 0 length stream'); }; /** * Implements the underlying read method * @private */ FileMuxer.prototype._read = function() { var self = this; function _waitForSourceAvailable() { self.once('sourceAdded', self._read.bind(self)); self._sourceDrainTimeout = setTimeout(function() { self.removeAllListeners('sourceAdded'); self.emit('error', new Error('Unexpected end of source stream')); }, self._options.sourceDrainWait); } function _mux(bytes) { self._bytesRead += bytes.length; if (self._length &lt; self._bytesRead) { return self.emit('error', new Error('Input exceeds expected length')); } self.push(bytes); } function _readFromSource() { var bytes = self._inputs[0] ? self._inputs[0].read() : null; if (bytes !== null) { return _mux(bytes); } setTimeout(_readFromSource, self._options.sourceIdleWait); } if (this._sourceDrainTimeout) { clearTimeout(this._sourceDrainTimeout); } if (this._bytesRead === this._length) { return this.push(null); } if (!this._inputs[0]) { return _waitForSourceAvailable(); } _readFromSource(); }; /** * Adds an additional input stream to the multiplexer * @param {ReadableStream} readable - Readable input stream from file shard */ FileMuxer.prototype.addInputSource = function(readable) { assert(typeof readable.pipe === 'function', 'Invalid input stream supplied'); assert(this._added &lt; this._shards, 'Inputs exceed defined number of shards'); var self = this; var input = readable.pipe(stream.PassThrough()).pause(); input.on('end', function() { self._inputs.splice(self._inputs.indexOf(input), 1); self.emit('drain', input); }); this._added++; this._inputs.push(input); this.emit('sourceAdded'); return this; }; module.exports = FileMuxer; Ã— Search results Close "},"lib_crypto-tools_keypair.js.html":{"id":"lib_crypto-tools_keypair.js.html","title":"Source: lib/crypto-tools/keypair.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/crypto-tools/keypair.js 'use strict'; var bitcore = require('bitcore-lib'); var crypto = require('crypto'); var merge = require('merge'); var Message = require('bitcore-message'); var curve = bitcore.deps.elliptic.curves.secp256k1; var ecdsa = new bitcore.deps.elliptic.ec(curve); /** * Represents a ECDSA key pair * @constructor * @license LGPL-3.0 * @param {String|Buffer|undefined} privateKey - WIF encoded ECDSA private key */ function KeyPair(privkey) { if (!(this instanceof KeyPair)) { return new KeyPair(privkey); } if (privkey) { this._privkey = bitcore.PrivateKey.fromString(privkey); } else { this._privkey = bitcore.PrivateKey.fromRandom(); } this._pubkey = this._privkey.toPublicKey(); } /** * Returns the private key * @returns {String} key */ KeyPair.prototype.getPrivateKey = function() { return this._privkey.toString(); }; /** * Returns the public key * @returns {String} key */ KeyPair.prototype.getPublicKey = function() { return this._pubkey.toString(); }; /** * Returns the NodeID derived from the public key * @returns {String} nodeID - RIPEMD160 hash of public key */ KeyPair.prototype.getNodeID = function() { return bitcore.crypto.Hash.sha256ripemd160( this._pubkey.toBuffer() ).toString('hex'); }; /** * Returns the bitcoin address version of the nodeID * @returns {String} address - Base58 encoded address */ KeyPair.prototype.getAddress = function() { return bitcore.Address.fromPublicKeyHash( new Buffer(this.getNodeID(), 'hex') ).toString(); }; /** * Signs the supplied message with the private key * @param {String|Buffer} message - The message to sign * @param {Object} options * @param {Boolean} [options.compact=true] - Compact signature format * @returns {String} signature */ KeyPair.prototype.sign = function(message, options) { var sign = null; var opts = merge({ compact: true }, options); if (opts.compact) { sign = Message(message).sign(this._privkey); } else { if (!Buffer.isBuffer(message)) { message = new Buffer(message, 'utf8'); } sign = ecdsa.sign( crypto.createHash('sha256').update(message).digest('hex'), this.getPrivateKey() ).toDER('hex'); } return sign; }; module.exports = KeyPair; Ã— Search results Close "},"lib_crypto-tools_keyring.js.html":{"id":"lib_crypto-tools_keyring.js.html","title":"Source: lib/crypto-tools/keyring.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/crypto-tools/keyring.js 'use strict'; var assert = require('assert'); var fs = require('fs'); var DataCipherKeyIv = require('../crypto-tools/cipher-key-iv'); var crypto = require('crypto'); var path = require('path'); var targz = require('node-tar.gz'); var os = require('os'); var utils = require('../utils'); var constants = require('../constants'); /** * A {@link DataCipherKeyIv} factory with file system persistence * @constructor * @license LGPL-3.0 * @param {String} keyRingDir - Path to store keyring directory * @param {String} [passPhrase=''] - Passphrase to encrypt/decrypt keyring */ function KeyRing(filePath, passPhrase) { if (!(this instanceof KeyRing)) { return new KeyRing(filePath, passPhrase); } assert(typeof filePath === 'string', 'Invalid path supplied to keyring'); this._keyFolder = path.join(filePath, 'key.ring'); this._pass = passPhrase || ''; if (!utils.existsSync(this._keyFolder)) { fs.mkdirSync(this._keyFolder); } this._verify(); this._migrateOld(path.join(filePath, 'keyring')); } KeyRing.DEFAULTS = { algorithm: constants.CIPHER_ALG }; /** * Verify the password supplied is correct for the previously created keys. * @private */ KeyRing.prototype._verify = function() { if (!utils.existsSync(path.join(this._keyFolder, '.verify'))) { this.generate('.verify'); } try { this.get('.verify'); } catch (err) { throw new Error('Invalid passphrase was supplied to KeyRing'); } }; /** * Migrate the old keyring to new key.ring folder * @private * @param {String} oldPath - path to the old keyring */ KeyRing.prototype._migrateOld = function(oldPath) { if (utils.existsSync(oldPath)) { var oldKeyRing; try { oldKeyRing = JSON.parse( this._decrypt(fs.readFileSync(oldPath).toString()) ); } catch (err) { return fs.unlinkSync(oldPath); } for (var key in oldKeyRing) { var file = path.join(this._keyFolder, key); if (!utils.existsSync(file)) { fs.writeFileSync( file, this._encrypt(JSON.stringify(oldKeyRing[key])) ); } } fs.unlinkSync(oldPath); } }; /** * Export Keyring to compressed tarball * @param {String} outPath - Path to keyring to be compressed * @param {Function} callback - Called when tarball has been written */ KeyRing.prototype.export = function(tar, callback) { var read = targz().createReadStream(this._keyFolder); var write = fs.createWriteStream(tar); read.pipe(write).on('finish', callback).on('error', callback); }; /** * Import to Keyring from compressed tarball * @param {String} inPath - Path to tarball to be imported * @param {String} passPhrase - Passphrase used to decrypt the imported tar * @param {Boolean} [overwriteConflictingIds=false] - Overwrite conflicting key * @param {Function} callback - Called on import finish */ KeyRing.prototype.import = function(tar, passphrase, writeflag, callback) { var self = this; var read = fs.createReadStream(tar); var parse = targz().createParseStream(); if (typeof writeflag === 'function') { callback = writeflag; writeflag = false; } function worker(entry, done) { var key = path.basename(entry.path); var keyPath = path.join(self._keyFolder, key); if (!utils.existsSync(keyPath) || writeflag === true) { var buf = ''; entry.on('data', function(data) { buf += data; }); entry.resume(); entry.on('end', function() { var decrypted; if (key === 'key.ring' || key === '.DS_Store') { return entry.abort(); } try { decrypted = self._encrypt( KeyRing.prototype._decrypt.call({ _pass: passphrase }, buf) ); } catch (err) { parse.removeAllListeners('end'); return callback(new Error('Failed to decrypt keyring')); } fs.writeFileSync(keyPath, decrypted, done); }); } } parse.on('entry', worker).on('end', callback); read.pipe(parse); }; /** * Returns the stored {@link KeyPair} for the given id * @param {String} keyId - Arbitrary key ID to load * @returns {DataCipherKeyIv|null} */ KeyRing.prototype.get = function(id) { var file = path.join(this._keyFolder, id); if (!utils.existsSync(file)) { return null; } return DataCipherKeyIv.fromObject( JSON.parse(this._decrypt(fs.readFileSync(file).toString())) ); }; /** * Returns the stored {@link KeyPair} for the given id * @param {String} keyId - Generate a key for use with the given ID * @returns {KeyPair} */ KeyRing.prototype.generate = function(id) { return this.set(id, DataCipherKeyIv()); }; /** * Returns the stored {@link KeyPair} for the given id * @param {String} keyId - Arbitrary key ID to load * @param {DataCipherKeyIv} dataCipherKey - Cipher key object to set */ KeyRing.prototype.set = function(id, cipherKeyIv) { this._saveKeyToDisk(id, cipherKeyIv.toObject()); return cipherKeyIv; }; /** * Saves the keyring file to disk * @private */ KeyRing.prototype._saveKeyToDisk = function(id, cipherKeyIv) { return fs.writeFileSync( path.join(this._keyFolder, id), this._encrypt(JSON.stringify(cipherKeyIv)) ); }; /** * Delete the keyring file from disk * @param {String} keyId - Arbitrary key ID to delete */ KeyRing.prototype.del = function(id) { var key = path.join(this._keyFolder, id); if (utils.existsSync(key)) { return fs.unlinkSync(key); } }; /** * Resets the keyring password * @param {String} passPhrase - New passphrase for keyring * @param {Function} callback - Called on keyring password reset */ KeyRing.prototype.reset = function(newpass, callback) { var self = this; var tmp = os.tmpdir(); var tarball = path.join(tmp, 'keyring.bak.' + Date.now() + '.tgz'); var oldpass = this._pass; if (!newpass || !newpass.length) { return callback(new Error('Your Password cannot be blank!')); } this.export(tarball, function(err) { if (err) { return callback(err); } self._pass = newpass; self.del('.verify'); self.import(tarball, oldpass, true, function(err) { callback(err); fs.unlinkSync(tarball); }); }); }; /** * Encrypts the data with the passphrase * @private * @param {String} data - Data to encrypt */ KeyRing.prototype._encrypt = function(data) { var cipher = crypto.createCipher(KeyRing.DEFAULTS.algorithm, this._pass); var enc = cipher.update(data, 'utf8', 'hex'); enc += cipher.final('hex'); return enc; }; /** * Decrypts the data with the passphrase * @private * @param {String|Buffer} data - Data to encrypt */ KeyRing.prototype._decrypt = function(data) { var decipher = crypto.createDecipher(KeyRing.DEFAULTS.algorithm, this._pass); var dec = decipher.update(data, 'hex', 'utf8'); dec += decipher.final('utf8'); return JSON.parse(dec) &amp;&amp; dec; }; module.exports = KeyRing; Ã— Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: index.js /** * @module storj * @license (AGPL-3.0 AND LGPL-3.0) */ 'use strict'; require('./lib/patches')(); // NB: Apply any monkey patches /** {@link Network} */ exports.Network = require('./lib/network'); /** {@link Monitor} */ exports.Monitor = require('./lib/network/monitor'); /** {@link Transport} */ exports.Transport = require('./lib/network/transport'); /** {@link Contact} */ exports.Contact = require('./lib/network/contact'); /** {@link ContactChecker} */ exports.ContactChecker = require('./lib/network/contact-checker'); /** {@link RateLimiter} */ exports.RateLimiter = require('./lib/network/rate-limiter'); /** {@link DataChannelClient} */ exports.DataChannelClient = require('./lib/data-channels/client'); /** {@link DataChannelServer} */ exports.DataChannelServer = require('./lib/data-channels/server'); /** {@link DataChannelPointer} */ exports.DataChannelPointer = require('./lib/data-channels/pointer'); /** {@link module:storj/datachannel/errors} */ exports.DataChannelErrors = require('./lib/data-channels/error-codes'); /** {@link Protocol} */ exports.Protocol = require('./lib/network/protocol'); /** {@link TunnelServer} */ exports.TunnelServer = require('./lib/tunnel/server'); /** {@link TunnelMuxer} */ exports.TunnelMuxer = require('./lib/tunnel/multiplexer'); /** {@link TunnelDemuxer} */ exports.TunnelDemuxer = require('./lib/tunnel/demultiplexer'); /** {@link module:storj/tunnel/errors} */ exports.TunnelErrors = require('./lib/tunnel/error-codes'); /** {@link TunnelClient} */ exports.TunnelClient = require('./lib/tunnel/client'); /** {@link EncryptStream} */ exports.EncryptStream = require('./lib/crypto-tools/encrypt-stream'); /** {@link DecryptStream} */ exports.DecryptStream = require('./lib/crypto-tools/decrypt-stream'); /** {@link FileMuxer} */ exports.FileMuxer = require('./lib/file-handling/file-muxer'); /** {@link FileDemuxer} */ exports.FileDemuxer = require('./lib/file-handling/file-demuxer'); /** {@link Padder} */ exports.Padder = require('./lib/file-handling/padder'); /** {@link Unpadder} */ exports.Unpadder = require('./lib/file-handling/unpadder'); /** {@link Contract} */ exports.Contract = require('./lib/contract'); /** {@link AuditStream} */ exports.AuditStream = require('./lib/audit-tools/audit-stream'); /** {@link ProofStream} */ exports.ProofStream = require('./lib/audit-tools/proof-stream'); /** {@link Verification} */ exports.Verification = require('./lib/audit-tools/verification'); /** {@link StorageManager} */ exports.StorageManager = require('./lib/storage/manager'); /** {@link StorageAdapter} */ exports.StorageAdapter = require('./lib/storage/adapter'); /** {@link StorageMigration} */ exports.StorageMigration = require('./lib/storage/migration'); /** {@link EmbeddedStorageAdapter} */ exports.EmbeddedStorageAdapter = require('./lib/storage/adapters/embedded'); /** {@link RAMStorageAdapter} */ exports.RAMStorageAdapter = require('./lib/storage/adapters/ram'); /** {@link StorageItem} */ exports.StorageItem = require('./lib/storage/item'); /** {@link DataCipherKeyIv} */ exports.DataCipherKeyIv = require('./lib/crypto-tools/cipher-key-iv'); /** {@link KeyPair} */ exports.KeyPair = require('./lib/crypto-tools/keypair'); /** {@link KeyRing} */ exports.KeyRing = require('./lib/crypto-tools/keyring'); /** {@link RenterInterface} */ exports.RenterInterface = require('./lib/network/interfaces/renter'); /** {@link FarmerInterface} */ exports.FarmerInterface = require('./lib/network/interfaces/farmer'); /** {@link TunnelerInterface} */ exports.TunnelerInterface = require('./lib/network/interfaces/tunneler'); /** {@link BridgeClient} */ exports.BridgeClient = require('./lib/bridge-client'); /** {@link module:storj/version} */ exports.version = require('./lib/version'); /** {@link module:storj/constants} */ exports.constants = require('./lib/constants'); /** {@link module:storj/utils} */ exports.utils = require('./lib/utils'); /** {@link module:storj/deps} */ exports.deps = require('./lib/deps'); /** {@link module:storj/sips} */ exports.sips = require('./lib/sips'); Ã— Search results Close "},"lib_constants.js.html":{"id":"lib_constants.js.html","title":"Source: lib/constants.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/constants.js /** * @module storj/constants * @license LGPL-3.0 */ 'use strict'; module.exports = { /** @constant {String} CIPHER_ALG - Cipher/Decipher algorithm */ CIPHER_ALG: 'aes-256-ctr', /** @constant {Number} PREFIX - NodeID prefix (same as bitcoin) */ PREFIX: 0x00, /** @constant {Number} NONCE_EXPIRE - Time to honor a signed message */ NONCE_EXPIRE: 30000, /** @constant {Number} RPC_TIMEOUT - Max wait time for a RPC response */ RPC_TIMEOUT: 30000, /** @constant {Number} NET_REENTRY - Max wait time before re-entering net */ NET_REENTRY: 600000, /** @constant {Number} AUDIT_BYTES - Number of bytes for audit challenge */ AUDIT_BYTES: 32, /** @constant {Number} CLEAN_INTERVAL - Interval for reaping stale shards */ CLEAN_INTERVAL: 10800000, /** @constant {Number} CONSIGN_THRESHOLD - Threshold for consign time */ CONSIGN_THRESHOLD: 86400000, /** @constant {Number} TOKEN_EXPIRE - Reject datachannl token after time */ TOKEN_EXPIRE: 86400000, /** @constant {Number} TUNNEL_ANNOUNCE_INTERVAL - Announce tunnel state */ TUNNEL_ANNOUNCE_INTERVAL: 900000, /** @constant {Number} OFFER_TIMEOUT - Max wait time for storage offer */ OFFER_TIMEOUT: 15000, /** @constant {Number} ROUTER_CLEAN_INTERVAL - Drop bad contacts */ ROUTER_CLEAN_INTERVAL: 60000, /** @constant {Number} OPCODE_TUNRPC_PREFIX - Opcode for tunnel rpc message */ OPCODE_TUNRPC_PREFIX: 0x0c, /** @constant {Number} OPCODE_TUNDCX_PREFIX - Opcode for tunnel datachannel */ OPCODE_TUNDCX_PREFIX: 0x0d, /** @constant {Number} OPCODE_TUNNELER_PREFIX - Prefix opcode for tunneler */ OPCODE_TUNNELER_PREFIX: 0x0e, /** @constant {Number} OPCODE_CONTRACT_PREFIX - Prefix opcode for contracts */ OPCODE_CONTRACT_PREFIX: 0x0f, /** @constant {Number} OPCODE_DEG_NULL - Opcode for null criteria degree */ OPCODE_DEG_NULL: 0x00, /** @constant {Number} OPCODE_DEG_LOW - Opcode for low criteria degree */ OPCODE_DEG_LOW: 0x01, /** @constant {Number} OPCODE_DEG_MED - Opcode for medium criteria degree */ OPCODE_DEG_MED: 0x02, /** @constant {Number} OPCODE_DEG_HIGH - Opcode for medium criteria degree */ OPCODE_DEG_HIGH: 0x03, /** @constant {Number} MAX_CONCURRENT_OFFERS - Number of concurrent offers */ MAX_CONCURRENT_OFFERS: 3, /** @constant {Number} MAX_CONCURRENT_AUDITS - Number of concurrent audits */ MAX_CONCURRENT_AUDITS: 3, /** @constant MAX_FIND_TUNNEL_RELAYS - Max times to relay FIND_TUNNEL */ MAX_FIND_TUNNEL_RELAYS: 2 }; Ã— Search results Close "},"lib_data-channels_error-codes.js.html":{"id":"lib_data-channels_error-codes.js.html","title":"Source: lib/data-channels/error-codes.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/data-channels/error-codes.js /** * @module storj/datachannel/errors * @license AGPL-3.0 */ 'use strict'; /** @static {Number} UNEXPECTED */ module.exports.UNEXPECTED = 1011; /** @static {Number} INVALID_MESSAGE */ module.exports.INVALID_MESSAGE = 3100; /** @static {Number} UNAUTHORIZED_TOKEN */ module.exports.UNAUTHORIZED_TOKEN = 3101; /** @static {Number} FAILED_INTEGRITY */ module.exports.FAILED_INTEGRITY = 3102; /** @static {Number} INVALID_OPERATION */ module.exports.INVALID_OPERATION = 3103; Ã— Search results Close "},"lib_deps.js.html":{"id":"lib_deps.js.html","title":"Source: lib/deps.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/deps.js /** * @module storj/deps */ 'use strict'; /** * Kademlia inspired local file store based on LevelDB * @see http://bookch.in/kfs */ exports.kfs = require('kfs'); /** * Implementation of the Kademlia distributed hash table * @see http://kadtools.github.io/ */ exports.kad = require('kad'); exports.kad.Quasar = require('kad-quasar'); /** * A modular node for Bitcoin and blockchain-based apps * @see https://bitcore.io/ */ exports.bitcore = require('bitcore-lib'); exports.bitcore.ECIES = require('bitcore-ecies'); Ã— Search results Close "},"lib_patches.js.html":{"id":"lib_patches.js.html","title":"Source: lib/patches.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/patches.js /** * @module storj/patches * @license AGPL-3.0 */ 'use strict'; var kad = require('kad'); var constants = require('./constants'); module.exports = function() { // NB: Increase response timeout for RPC calls kad.constants.T_RESPONSETIMEOUT = constants.RPC_TIMEOUT; }; Ã— Search results Close "},"lib_sips_index.js.html":{"id":"lib_sips_index.js.html","title":"Source: lib/sips/index.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/sips/index.js /** * @module storj/sips * @license AGPL-3.0 */ 'use strict'; /** {@link module:storj/sips/0003} */ module.exports.SIP0003 = require('./0003'); Ã— Search results Close "},"lib_sips_0003_index.js.html":{"id":"lib_sips_0003_index.js.html","title":"Source: lib/sips/0003/index.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/sips/0003/index.js /** * @module storj/sips/0003 */ 'use strict'; /** {@link TriggerManager} */ exports.TriggerManager = require('./trigger-manager'); Ã— Search results Close "},"lib_tunnel_error-codes.js.html":{"id":"lib_tunnel_error-codes.js.html","title":"Source: lib/tunnel/error-codes.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/tunnel/error-codes.js /** * @module storj/tunnel/errors * @license AGPL-3.0 */ 'use strict'; /** @static {Number} UNEXPECTED */ module.exports.UNEXPECTED = 1011; /** @static {Number} GATEWAY_CLOSED */ module.exports.GATEWAY_CLOSED = 4100; /** @static {Number} INVALID_FRAME_TYPE */ module.exports.INVALID_FRAME_TYPE = 4101; Ã— Search results Close "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/utils.js /** * @module storj/utils * @license LGPL-3.0 */ 'use strict'; var constants = require('./constants'); var KeyPair = require('./crypto-tools/keypair'); var crypto = require('crypto'); var semver = require('semver'); var ip = require('ip'); var ntp = require('ntp-client'); var bitcore = require('bitcore-lib'); var ECIES = require('bitcore-ecies'); var through = require('through'); var fs = require('fs'); var base58 = bitcore.deps.bs58; var os = require('os'); /** * Returns the SHA-1 hash of the input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.sha1 = function(input, encoding) { return crypto.createHash('sha1').update(input, encoding).digest('hex'); }; /** * Returns the SHA-256 hash of the input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.sha256 = function(input, encoding) { return crypto.createHash('sha256').update(input, encoding).digest('hex'); }; /** * Returns the RIPEMD-160 hash of the input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.rmd160 = function(input, encoding) { return crypto.createHash('rmd160').update(input, encoding).digest('hex'); }; /** * Returns the WHIRLPOOL hash of the input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.whirlpool = function(input, encoding) { return crypto.createHash('whirlpool').update(input, encoding).digest('hex'); }; /** * Returns the RIPEMD-160 SHA-256 hash of this input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.rmd160sha256 = function(input, encoding) { return module.exports.rmd160( Buffer(module.exports.sha256(input, encoding), 'hex') ); }; /** * Returns the SHA-1 WHIRLPOOL hash of this input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.sha1whirlpool = function(input, encoding) { return module.exports.sha1( Buffer(module.exports.whirlpool(input, encoding), 'hex') ); }; /** * Returns the next power of two number * @param {Number} number * @returns {Number} */ module.exports.getNextPowerOfTwo = function(num) { return Math.pow(2, Math.ceil(Math.log(num) / Math.log(2))); }; /** * Generates a unique token * @returns {String} */ module.exports.generateToken = function() { return module.exports.rmd160sha256(crypto.randomBytes(512)); }; /** * Returns a stringified URL from the supplied contact object * @param {Object} contact * @param {String} contact.address * @param {Number} contact.port * @param {String} contact.nodeID * @returns {String} */ module.exports.getContactURL = function(contact) { return [ 'storj://', contact.address, ':', contact.port, '/', contact.nodeID ].join(''); }; /** * Returns whether or not the supplied semver tag is compatible * @param {String} version - The semver tag from the contact * @returns {Boolean} compatible */ module.exports.isCompatibleVersion = function(version) { var local = require('./version').protocol; var remote = version; var sameMajor = semver.major(local) === semver.major(remote); var sameMinor = semver.minor(local) === semver.minor(remote); var diffs = ['prerelease', 'prepatch', 'preminor', 'premajor']; if (diffs.indexOf(semver.diff(remote, local)) !== -1) { return false; } else if (semver.major(local) === 0 &amp;&amp; sameMajor) { return sameMinor; } else { return sameMajor; } }; /** * Determines if the supplied contact is valid * @param {Contact} contact - The contact information for a given peer * @param {Boolean} loopback - Allows contacts that are localhost * @returns {Boolean} */ module.exports.isValidContact = function(contact, loopback) { if (!contact) { return false; } var isValidAddr = ip.isV4Format(contact.address) || ip.isV6Format(contact.address) || ip.isPublic(contact.address); var isValidPort = contact.port &gt; 0; var isAllowedAddr = ip.isLoopback(contact.address) ? !!loopback : true; return isValidPort &amp;&amp; isValidAddr &amp;&amp; isAllowedAddr; }; /** * Creates an ECIES ciper object from a private and a public key * @param {String} privateKey - The private key of the sender * @param {String} publicKey - The public key of the recipient * @returns {Object} */ module.exports.createEciesCipher = function(privateKey, publicKey) { var cipher = ECIES(); cipher.privateKey(KeyPair(privateKey)._privkey); cipher.publicKey(bitcore.PublicKey.fromDER(Buffer(publicKey, 'hex'))); return cipher; }; /** * Validates the logger object supplied * @private */ module.exports.validateLogger = function(logger) { return logger &amp;&amp; logger.debug &amp;&amp; logger.warn &amp;&amp; logger.info &amp;&amp; logger.error; }; /** * Returns number of bytes from human readable size and unit strings * @param {String|Number} size - The size measurement * @param {String} unit - The unit of measure (MB|GB|TB) * @returns {Number} */ module.exports.toNumberBytes = function(size, unit) { switch (unit.toUpperCase()) { case 'MB': size = Number(size) * Math.pow(1024, 2); break; case 'GB': size = Number(size) * Math.pow(1024, 3); break; case 'TB': size = Number(size) * Math.pow(1024, 4); break; default: throw new Error('Unit must be one of TB, GB, or MB'); } return Number(size.toFixed()); }; /** * Encrypts the given data with the supplied password and base58 encodes it * @param {String} password - The passphrase to use for encryption * @param {String} data - The string to encrypt * @returns {String} */ module.exports.simpleEncrypt = function(password, str) { var aes256 = crypto.createCipher('aes-256-cbc', password); var a = aes256.update(str, 'utf8'); var b = aes256.final(); var buf = new Buffer(a.length + b.length); a.copy(buf, 0); b.copy(buf, a.length); return base58.encode(buf); }; /** * Decrypts the given data with the supplied password and base58 decodes it * @param {String} password - The passphrase to use for decryption * @param {String} data - The string to decrypt * @returns {String} */ module.exports.simpleDecrypt = function(password, str) { var aes256 = crypto.createDecipher('aes-256-cbc', password); var a = aes256.update(new Buffer(base58.decode(str))); var b = aes256.final(); var buf = new Buffer(a.length + b.length); a.copy(buf, 0); b.copy(buf, a.length); return buf.toString('utf8'); }; /** * Returns the delta between system time and NTP time * @param {Function} callback - Called with (err, delta) */ module.exports.getNtpTimeDelta = function(callback) { var timeBeforeRequest = new Date(); ntp.getNetworkTime( ntp.defaultNtpServer, ntp.defaultNtpPort, function(err, networkTime) { if (err) { return callback(err); } var timeAfterResponse = new Date(); var latency = timeAfterResponse - timeBeforeRequest; var systemTime = Date.now(); var delta = networkTime.getTime() - Math.abs(systemTime - latency); callback(null, delta); } ); }; /** * Determines if the system clock is syncronized with network * @param {Function} callback - Called with (err, delta) */ module.exports.ensureNtpClockIsSynchronized = function(callback) { module.exports.getNtpTimeDelta(function(err, delta) { if (err) { return callback(err); } if (delta &gt; constants.NONCE_EXPIRE) { return callback(new Error('System clock is not syncronized with NTP')); } callback(null, delta); }); }; /** * Returns a through stream that trims the output based on the given range * @param {Number} trimFront - Number of bytes to trim off front of stream * @param {Number} totalBytes - The total length of the stream in bytes */ module.exports.createStreamTrimmer = function(trimFront, totalBytes) { var bytesTrimmedFront = 0; var bytesRead = 0; return through(function(data) { if (trimFront - bytesTrimmedFront &gt; data.length) { bytesTrimmedFront += data.length; bytesRead += 0; this.queue(new Buffer([])); } else if (trimFront &gt; bytesTrimmedFront) { var frontTrimmedSlice = data.slice(trimFront - bytesTrimmedFront); bytesTrimmedFront += data.length; bytesRead += frontTrimmedSlice.length; this.queue(frontTrimmedSlice); } else if (bytesRead &lt; totalBytes) { var backTrimmedSlice = data.slice(0, totalBytes - bytesRead); bytesRead += backTrimmedSlice.length; this.queue(backTrimmedSlice); } else { this.queue(null); } }); }; /** * Check if file exists * @param {String} file - Path to file * @returns {Boolean} */ module.exports.existsSync = function(file) { try { fs.statSync(file); } catch(err) { return false; } return true; }; /** * Check if a path is a directory * @param {String} dirPath - Path to a directory * @returns {Boolean} */ module.exports.isDirectory = function(dirPath) { try { return fs.statSync(dirPath).isDirectory(); } catch (err) { return false; } }; /** * Check for env STORJ_TEMP todetermine temp directory */ module.exports.tmpdir = function() { var tmpdir = process.env.STORJ_TEMP; if (!tmpdir || (typeof tmpdir === 'undefined')) { tmpdir = os.tmpdir(); } return tmpdir; }; /** * Empty function stub * @private */ module.exports.noop = function() {}; Ã— Search results Close "},"lib_version.js.html":{"id":"lib_version.js.html","title":"Source: lib/version.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/version.js /** * @module storj/version */ 'use strict'; var semver = require('semver'); var assert = require('assert'); var postfix = process.env.STORJ_NETWORK ? '-' + process.env.STORJ_NETWORK : ''; module.exports = { /** @constant {String} protocol - The supported protocol version */ protocol: '0.8.1' + postfix, /** @constant {String} software - The current software version */ software: require('../package').version }; assert( semver.valid(module.exports.protocol), 'Invalid protocol version specified' ); Ã— Search results Close "},"lib_network_monitor.js.html":{"id":"lib_network_monitor.js.html","title":"Source: lib/network/monitor.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/monitor.js 'use strict'; var Network = require('./index'); var EventEmitter = require('events').EventEmitter; var inherits = require('util').inherits; var assert = require('assert'); var merge = require('merge'); var async = require('async'); var request = require('request'); /** * Wraps a {@link Network} instance and provides events for gathering * statistics about node operation * @constructor * @license AGPL-3.0 * @param {Network} network - The network interface to monitor * @param {Object} options */ function Monitor(network, options) { if (!(this instanceof Monitor)) { return new Monitor(network, options); } assert(network instanceof Network, 'Invalid network instance supplied'); this._source = network; this._options = merge(Object.create(Monitor.DEFAULTS), options); this._statistics = {}; this._collectors = { soft: [ Monitor.getConnectedPeers, Monitor.getDiskUtilization ], hard: [ Monitor.getPaymentAddressBalances ] }; EventEmitter.call(this); } inherits(Monitor, EventEmitter); /** * Triggered when a valid offer is received, but we are not waiting for one * @event Monitor#update * @param {Object} stats */ Monitor.DEFAULTS = { softInterval: 10000, // NB: Interval for simple jobs hardInterval: 3 * 60 * 1000 // NB: Interval for resource heavy jobs }; /** * Starts the network monitor * @returns {Monitor} */ Monitor.prototype.start = function() { if (this._softInterval &amp;&amp; this._hardInterval) { return false; } this._softInterval = setInterval( this._collectSoftStats.bind(this), this._options.softInterval ); this._hardInterval = setInterval( this._collectHardStats.bind(this), this._options.hardInterval ); return true; }; /** * Stops the network monitor * @returns {Monitor} */ Monitor.prototype.stop = function() { if (!this._softInterval &amp;&amp; !this._hardInterval) { return false; } clearInterval(this._softInterval); clearInterval(this._hardInterval); delete this._softInterval; delete this._hardInterval; return true; }; /** * Returns the current snapshot * @returns {Object} snapshot */ Monitor.prototype.getSnapshot = function() { return merge(Object.create(this._statistics), { timestamp: new Date() }); }; /** * Collects the soft stats * @private */ Monitor.prototype._collectStats = function(collectors) { var self = this; async.parallel(collectors.map(function(collector) { return collector.bind(null, self._source); }), function(err, results) { results.forEach(function(result) { self._statistics = merge(self._statistics, result); }); self.emit('update', self.getSnapshot()); }); }; /** * Collects the soft stats * @private */ Monitor.prototype._collectSoftStats = function() { this._collectStats(this._collectors.soft); }; /** * Collects the hard stats * @private */ Monitor.prototype._collectHardStats = function() { this._collectStats(this._collectors.hard); }; /** * Gets the list of currently known {@link Contact}s * @static * @param {Network} source - The network instance to use * @param {Function} callback */ Monitor.getConnectedPeers = function(source, callback) { var stats = { connected: 0 }; var buckets = source.router._buckets; for (var k in buckets) { stats.connected += buckets[k].getSize(); } callback(null, { peers: stats }); }; /** * Gets the amount of used space compared to amount shared * @static * @param {Network} source - The network instance to use * @param {Function} callback */ Monitor.getDiskUtilization = function(source, callback) { var stats = { free: source.manager._options.maxCapacity }; source.manager._storage.size(function(err, bytes) { if (err) { return callback(null, { disk: merge(stats, { used: 0, free: stats.free }) }); } callback(null, { disk: merge(stats, { used: bytes, free: stats.free - bytes }) }); }); }; /** * Gets the balance of SJCX/SJCT from a {@link FarmerInterface} * @static * @param {Network} source - The network instance to use * @param {Function} callback */ Monitor.getPaymentAddressBalances = function(source, callback) { var stats = { balances: { sjcx: 0, sjct: 0 } }; var address = source.keyPair.getAddress(); if (source._options.paymentAddress) { address = source._options.paymentAddress.trim(); } var url = 'https://counterpartychain.io/api/balances/' + address; request({ url: url, json: true }, function(err, res, body) { if (err || res.statusCode !== 200) { return callback(null, { payments: stats }); } if (body &amp;&amp; body.data) { for (var balance = 0; balance &lt; body.data.length; balance++) { stats.balances[body.data[balance].asset.toLowerCase()] = Number( body.data[balance].amount ); } } callback(null, { payments: stats }); }); }; /** * Gets the total contracts stored * @static * @param {Network} source - The network instance to use * @param {Function} callback */ Monitor.getContractsDetails = function(source, callback) { var stats = { total: 0 }; var stream = source.storageManager._storage.createReadStream(); stream.on('data', function(item) { stats.total += Object.keys(item.contracts).length; }); stream.on('end', function() { callback(null, { contracts: stats }); }); stream.on('error', function() { stream.removeAllListeners(); callback(null, { contracts: stats }); }); }; module.exports = Monitor; Ã— Search results Close "},"lib_file-handling_padder.js.html":{"id":"lib_file-handling_padder.js.html","title":"Source: lib/file-handling/padder.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/file-handling/padder.js 'use strict'; var stream = require('readable-stream'); var inherits = require('util').inherits; /** * Takes an input stream and pads the tail with zeroes to the next byte mulitple * @constructor * @license LGPL-3.0 */ function Padder() { if (!(this instanceof Padder)) { return new Padder(); } this._bytesRead = 0; stream.Transform.call(this); } inherits(Padder, stream.Transform); Padder.DEFAULTS = { multiple: 1024 * 1024 * 8 }; /** * Implements a simple passthrough while tracking number of bytes * @private */ Padder.prototype._transform = function(chunk, enc, callback) { this._bytesRead += chunk.length; this.push(chunk); callback(null); }; /** * Pads the tail of the stream with zeroes * @private */ Padder.prototype._flush = function(callback) { var remainder = this._bytesRead % Padder.DEFAULTS.multiple; if (this._bytesRead &lt; Padder.DEFAULTS.multiple) { this.push(Buffer(Padder.DEFAULTS.multiple - this._bytesRead).fill(0)); return callback(null); } if (remainder) { this.push(Buffer(Padder.DEFAULTS.multiple - remainder).fill(0)); return callback(null); } callback(null); }; module.exports = Padder; Ã— Search results Close "},"lib_audit-tools_proof-stream.js.html":{"id":"lib_audit-tools_proof-stream.js.html","title":"Source: lib/audit-tools/proof-stream.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/audit-tools/proof-stream.js 'use strict'; var assert = require('assert'); var MerkleTree = require('mtree'); var utils = require('../utils'); var inherits = require('util').inherits; var stream = require('readable-stream'); var crypto = require('crypto'); /** * Provides interface for proving possession of a file for an * {@link AuditStream} * @constructor * @license LGPL-3.0 * @param {Array} merkleLeaves - Bottom leaves of the audit merkle tree * @param {String} hexChallenge - The challenge data in hex to prepend to shard */ function ProofStream(leaves, challenge) { if (!(this instanceof ProofStream)) { return new ProofStream(leaves, challenge); } assert(Array.isArray(leaves), 'Merkle leaves must be an array'); assert.ok(challenge, 'Invalid challenge supplied'); this._tree = new MerkleTree(this._generateLeaves(leaves), utils.rmd160sha256); this._challenge = challenge; this._hasher = crypto.createHash('sha256').update(this._challenge); this._proof = null; stream.Transform.call(this, { objectMode: true }); } inherits(ProofStream, stream.Transform); /** * Returns the generated proof structure * @return {Array} */ ProofStream.prototype.getProofResult = function() { assert(Array.isArray(this._proof), 'Proof generation is not complete'); return this._proof; }; /** * Handles writing the shard data to the proof stream * @private */ ProofStream.prototype._transform = function(chunk, encoding, next) { this._hasher.update(chunk.toString('hex')); next(); }; /** * Generates the proof from the read data * @private */ ProofStream.prototype._flush = function(done) { try { this._generateProof(); } catch(err) { return done(err); } this.push(this.getProofResult()); done(); }; /** * Calculate audit response * @private * @param {String} challenge - Challenge string sent by auditor * @returns {Array} result - Challenge response */ ProofStream.prototype._generateProof = function() { var response = utils.rmd160(this._hasher.digest('hex')); var leaves = this._tree.level(this._tree.levels() - 1); var challengenum = leaves.indexOf(utils.rmd160sha256(response)); assert(challengenum !== -1, 'Failed to generate proof'); var branches = [response]; for (var i = (this._tree.levels() - 1); i &gt; 0; i--) { var level = this._tree.level(i); if (challengenum % 2 === 0) { branches = [branches, level[challengenum + 1]]; } else { branches = [level[challengenum - 1], branches]; } challengenum = Math.floor(challengenum / 2); } this._proof = branches; }; /** * Generates the bottom leaves of the tree to the next power of two * @private * @param {Array} leaves */ ProofStream.prototype._generateLeaves = function(leaves) { var numEmpty = utils.getNextPowerOfTwo(leaves.length) - leaves.length; var emptyLeaves = []; for (var i = 0; i &lt; numEmpty; i++) { emptyLeaves.push(utils.rmd160sha256('')); } return leaves.concat(emptyLeaves); }; module.exports = ProofStream; Ã— Search results Close "},"lib_network_protocol.js.html":{"id":"lib_network_protocol.js.html","title":"Source: lib/network/protocol.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/protocol.js 'use strict'; var assert = require('assert'); var utils = require('../utils'); var ProofStream = require('../audit-tools/proof-stream'); var Contract = require('../contract'); var StorageItem = require('../storage/item'); var stream = require('readable-stream'); var kad = require('kad'); var url = require('url'); var async = require('async'); var Contact = require('./contact'); var constants = require('../constants'); var DataChannelClient = require('../data-channels/client'); /** * Defines the Storj protocol methods and mounts on a {@link Network} instance * to handle Storj protocol messages * @constructor * @license AGPL-3.0 * @param {Object} options * @param {Network} options.network - Network instance to bind to */ function Protocol(opts) { if (!(this instanceof Protocol)) { return new Protocol(opts); } assert(typeof opts === 'object' , 'Invalid options supplied'); this._network = opts.network; this._logger = this._network._logger; } /** * Handles OFFER messages * @param {Object} params - RPC message parameters * @param {Function} callback - Completion callback */ Protocol.prototype.handleOffer = function(params, callback) { var self = this; var contract; this._logger.info( 'handling storage contract offer from %s', params.contact.nodeID ); try { contract = Contract.fromObject(params.contract); } catch (err) { return callback(new Error('Invalid contract format')); } // TODO: Ultimately we will need to create a robust decision engine that will // TODO: allow us to better determine if the received offer is in our best // TODO: interest. For now, we just make sure that we have the data_shard // TODO: from the OFFER and we wish to CONSIGN it. // For now, we just accept any storage offer we get that matches our own... var key = contract.get('data_hash'); this._verifyContract(contract, params.contact, function(err) { if (err) { return callback(err); } var doConsign = self._network._pendingContracts[key].bind( self._network, null, Contact(params.contact), contract ); delete self._network._pendingContracts[key]; var item = new StorageItem({ hash: key }); item.contracts[params.contact.nodeID] = contract; self._network.storageManager.save(item, function(err) { if (err) { return callback(err); } self._logger.info( 'accepting storage contract offer from %s', params.contact.nodeID ); callback(null, { contract: contract.toObject() }); doConsign(); }); }); }; /** * Verifies that the contract is valid * @private */ Protocol.prototype._verifyContract = function(contract, contact, callback) { if (!contract.verify('farmer', contact.nodeID)) { return callback(new Error('Invalid signature from farmer')); } contract.sign('renter', this._network.keypair.getPrivateKey()); if (!contract.isComplete()) { return callback(new Error('Contract is not complete')); } if (!this._network._pendingContracts[contract.get('data_hash')]) { this._network.emit('unhandledOffer', contract, contact); return callback(new Error('Contract no longer open to offers')); } var blacklist = this._network._pendingContracts[ contract.get('data_hash') ].blacklist; if (blacklist.indexOf(contact.nodeID) !== -1) { return callback(new Error('Contract no longer open to offers')); } callback(null); }; /** * Handles AUDIT messages * @param {Object} params - RPC message parameters * @param {Function} callback - Completion callback */ Protocol.prototype.handleAudit = function(params, callback) { var self = this; var limit = constants.MAX_CONCURRENT_AUDITS; if (!Array.isArray(params.audits)) { return callback(new Error('Invalid audit list supplied')); } this._logger.info( 'handling storage audit from %s', params.contact.nodeID ); async.mapLimit(params.audits, limit, function(audit, done) { self._proveShardExistence( audit.data_hash, audit.challenge, params.contact.nodeID, done ); }, function onComplete(err, proofs) { if (err) { return callback(err); } callback(null, { proofs: proofs }); }); }; /** * Performs a single audit proof generation * @private * @param {String} hash - The hash of the shard to prove * @param {String} challenge - The challenge input for proof generation * @param {String} nodeID - The nodeID of the auditor * @param {Function} callback - Called on completion of the proof generation */ Protocol.prototype._proveShardExistence = function(hash, chall, nid, cb) { if (!hash || !chall) { return cb(new Error('Invalid data hash or challenge provided')); } this._network.storageManager.load(hash, function(err, item) { if (err) { return cb(err); } if (item.shard instanceof stream.Writable) { return cb(new Error('Shard not found')); } var proof = new ProofStream(item.trees[nid], chall); proof.on('error', function(err) { proof.removeAllListeners('finish'); cb(err); }); proof.on('finish', function() { proof.removeAllListeners('error'); cb(null, proof.getProofResult()); }); item.shard.pipe(proof); }); }; /** * Handles CONSIGN messages * @param {Object} params - RPC message parameters * @param {Function} callback - Completion callback */ Protocol.prototype.handleConsign = function(params, callback) { var self = this; var token = utils.generateToken(); this._logger.info( 'handling storage consignment request from %s', params.contact.nodeID ); self._network.storageManager.load(params.data_hash, function(err, item) { if (err) { return callback(err); } var contract = item.contracts[params.contact.nodeID]; var t = Date.now(); if (!contract) { return callback(new Error('Consignment is not authorized')); } item.trees[contract.get('renter_id')] = params.audit_tree; try { assert( t &lt; contract.get('store_end') &amp;&amp; t + constants.CONSIGN_THRESHOLD &gt; contract.get('store_begin'), 'Consignment violates contract store time' ); } catch (err) { return callback(err); } self._network.storageManager.save(item, function(err) { if (err) { return callback(err); } self._logger.info( 'authorizing data channel for %s', params.contact.nodeID ); self._network.dataChannelServer.accept(token, params.data_hash); callback(null, { token: token }); }); }); }; /** * Handles MIRROR messages * @param {Object} params - RPC message parameters * @param {Function} callback - Completion callback */ Protocol.prototype.handleMirror = function(params, callback) { var self = this; var hash = params.data_hash; var token = params.token; self._network.storageManager.load(hash, function(err, item) { if (err) { return callback(err); } // NB: Don't mirror data we are not contracted for if (!item.contracts[params.contact.nodeID]) { return callback(new Error('No contract found for shard')); } // NB: Don't mirror if we already have the shard if (typeof item.shard.write !== 'function') { return callback(null, {}); } self._logger.info( 'opening datachannel with %j to mirror %s', params.farmer, hash ); var dcx = new DataChannelClient(params.farmer); function _onChannelError(err) { dcx.removeAllListeners(); self._logger.error( 'failed to open datachannel for mirroring, reason: %s', err.message ); callback(err); } function _onChannelOpen() { var rs = dcx.createReadStream(token, hash); self._logger.info('datachannel successfully established for mirror'); dcx.removeListener('error', _onChannelError); rs.on('error', function _onStreamError(err) { self._logger.error('failed to read from mirror node: %s', err.message); rs.unpipe(item.shard); item.shard.destroy(); }).pipe(item.shard); callback(null, {}); } dcx.on('error', _onChannelError).on('open', _onChannelOpen); }); }; /** * Handles RETRIEVE messages * @param {Object} params - RPC message parameters * @param {Function} callback - Completion callback */ Protocol.prototype.handleRetrieve = function(params, callback) { var self = this; var hash = params.data_hash; var token = utils.generateToken(); if (!kad.utils.isValidKey(hash)) { return callback(new Error('Invalid data hash provided: ' + hash)); } self._network.storageManager.load(hash, function(err, item) { if (err) { return callback(err); } // TODO: We will need to increment the download count to track payments, as // TODO: well as make sure that the requester is allowed to fetch the shard // TODO: as part of the contract. self._logger.info( 'authorizing data channel for %s', params.contact.nodeID ); self._network.dataChannelServer.accept(token, item.hash); callback(null, { token: token }); }); }; /** * Handles PROBE messages * @param {Object} params - RPC message parameters * @param {Function} callback - Completion callback */ Protocol.prototype.handleProbe = function(params, callback) { var message = new kad.Message({ method: 'PING', params: { contact: this._network.contact } }); this._logger.info('performing probe for %s', params.contact.nodeID); this._network.transport.send(params.contact, message, function(err) { if (err) { return callback(new Error('Probe failed, you are not addressable')); } callback(null, {}); }); }; /** * Handles FIND_TUNNEL messages * @param {Object} params - RPC message parameters * @param {Function} callback - Completion callback */ Protocol.prototype.handleFindTunnel = function(params, callback) { var available = this._network.transport.tunnelServer.hasTunnelAvailable(); var knownTunnelers = this._network._tunnelers.getContactList(); var tunnels = available ? [this._network.contact].concat(knownTunnelers) : knownTunnelers; this._logger.info('finding tunnels for %s', params.contact.nodeID); if (tunnels.length) { this._logger.info( 'sending %s tunnels to %s', tunnels.length, params.contact.nodeID ); return callback(null, { tunnels: tunnels }); } if (params.relayers.length &lt; constants.MAX_FIND_TUNNEL_RELAYS) { return this._askNeighborsForTunnels(params.relayers, callback); } callback(null, { tunnels: tunnels }); }; /** * Sends a FIND_TUNNEL to our seed on behalf of requester * @private */ Protocol.prototype._askNeighborsForTunnels = function(relayers, callback) { var self = this; var nearestNeighbors = this._network.router.getNearestContacts( this._network.contact.nodeID, 3, this._network.contact.nodeID ).filter(function(contact) { return relayers.indexOf(contact.nodeID) === -1; }); this._logger.info('asking nearest neighbors for known tunnels'); function askNeighbor(neighbor, done) { self._network.transport.send(neighbor, kad.Message({ method: 'FIND_TUNNEL', params: { contact: self._network.contact, relayers: [self._network.contact].concat(relayers) } }), function(err, response) { if (err || !Array.isArray(response.result.tunnels)) { return done(false); } if (response.result.tunnels &amp;&amp; response.result.tunnels.length) { response.result.tunnels.forEach(function(tun) { if (self._network._tunnelers.getSize() &lt; kad.constants.K) { self._network._tunnelers.addContact( self._network.transport._createContact(tun) ); } }); return done(true); } done(false); }); } async.detectSeries(nearestNeighbors, askNeighbor, function() { callback(null, { tunnels: self._network._tunnelers.getContactList() }); }); }; /** * Handles OPEN_TUNNEL messages * @param {Object} params - RPC message parameters * @param {Function} callback - Completion callback */ Protocol.prototype.handleOpenTunnel = function(params, callback) { var self = this; this._logger.info('opening gateway for %s', params.contact.nodeID); this._network.transport.tunnelServer.createGateway(function(err, gateway) { if (err) { return callback(err); } var tunnel = url.format({ protocol: 'ws', slashes: true, hostname: self._network.contact.address, port: self._network.transport.tunnelServer.getListeningPort(), pathname: 'tun', query: { token: gateway.getEntranceToken() } }); var alias = { address: self._network.contact.address, port: gateway.getEntranceAddress().port }; self._logger.info( 'gateway opened for %s at %j', params.contact.nodeID, alias ); if (!self._network.transport._requiresTraversal) { return callback(null, { tunnel: tunnel, alias: alias }); } self._network.transport.createPortMapping( gateway.getEntranceAddress().port, function(err) { if (err) { return callback(err); } callback(null, { tunnel: tunnel, alias: alias }); } ); }); }; /** * Handles TRIGGER messages * @param {Object} params - RPC message parameters * @param {Function} callback - Completion callback */ Protocol.prototype.handleTrigger = function(params, callback) { this._network.triggers.process(params, callback); }; /** * Returns bound references to the protocol handlers * @returns {Object} handlers */ Protocol.prototype.getRouteMap = function() { return { OFFER: this.handleOffer.bind(this), AUDIT: this.handleAudit.bind(this), CONSIGN: this.handleConsign.bind(this), MIRROR: this.handleMirror.bind(this), RETRIEVE: this.handleRetrieve.bind(this), PROBE: this.handleProbe.bind(this), FIND_TUNNEL: this.handleFindTunnel.bind(this), OPEN_TUNNEL: this.handleOpenTunnel.bind(this), TRIGGER: this.handleTrigger.bind(this) }; }; module.exports = Protocol; Ã— Search results Close "},"lib_storage_adapters_ram.js.html":{"id":"lib_storage_adapters_ram.js.html","title":"Source: lib/storage/adapters/ram.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/adapters/ram.js 'use strict'; var inherits = require('util').inherits; var stream = require('readable-stream'); var StorageAdapter = require('../adapter'); var StorageItem = require('../item'); /** * Implements an in-memory storage adapter * @extends {StorageAdapter} * @constructor * @license AGPL-3.0 */ function RAMStorageAdapter() { if (!(this instanceof RAMStorageAdapter)) { return new RAMStorageAdapter(); } this._items = {}; this._shards = {}; } inherits(RAMStorageAdapter, StorageAdapter); /** * Implements the abstract {@link StorageAdapter#_get} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._get = function(key, callback) { var self = this; var result = this._items[key]; if (!result) { return callback(new Error('Shard data not found')); } if (this._shards[key]) { result.shard = this._decorateStreamWithDestroy(key, new stream.Readable({ read: function() { if (this._finished) { this.push(null); } else { this.push(self._shards[key]); this._finished = true; } } })); } else { result.shard = this._decorateStreamWithDestroy(key, new stream.Writable({ write: function(data, encoding, next) { self._shards[key] = data; next(); } })); } callback(null, new StorageItem(result)); }; /** * Implements the abstract {@link StorageAdapter#_peek} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._peek = function(key, callback) { if (!this._items[key]) { return callback(new Error('Shard data not found')); } callback(null, new StorageItem(this._items[key])); }; /** * Implements the abstract {@link StorageAdapter#_put} * @private * @param {String} key * @param {StorageItem} item * @param {Function} callback */ RAMStorageAdapter.prototype._put = function(key, item, callback) { this._items[key] = item; callback(); }; /** * Implements the abstract {@link StorageAdapter#_del} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._del = function(key, callback) { delete this._shards[key]; callback(); }; /** * Implements the abstract {@link StorageAdapter#_size} * @private * @param {Function} callback */ RAMStorageAdapter.prototype._size = function(callback) { var shardBytes = 0; for (var _key in this._shards) { shardBytes += this._shards[_key].length; } callback( null, Buffer(JSON.stringify(this._items)).length + shardBytes ); }; /** * Implements the abstract {@link StorageAdapter#_keys} * @private * @param {Function} callback */ RAMStorageAdapter.prototype._keys = function(callback) { callback(null, Object.keys(this._items)); }; /** * Decorates a stream with a destroy method to remove any data written * @private * @param {String} key * @param {Stream} stream */ RAMStorageAdapter.prototype._decorateStreamWithDestroy = function(key, stream) { var self = this; stream.destroy = function() { delete self._shards[key]; }; return stream; }; module.exports = RAMStorageAdapter; Ã— Search results Close "},"lib_network_rate-limiter.js.html":{"id":"lib_network_rate-limiter.js.html","title":"Source: lib/network/rate-limiter.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/rate-limiter.js 'use strict'; var merge = require('merge'); var ms = require('ms'); /** * Tracks the number of messages received from a given nodeID and prevents * handling of message received during the limited timespan * @constructor * @license AGPL-3.0 * @param {Object} options * @param {Number} options.rate - The number of milliseconds before resetting * @param {Number} options.limit - The number of messages allowed per rate */ function RateLimiter(options) { if (!(this instanceof RateLimiter)) { return new RateLimiter(options); } options = merge(Object.create(RateLimiter.DEFAULTS), options); this.rate = options.rate; this.limit = options.limit; this.started = Date.now(); this.resetCounter(); setInterval(this.resetCounter.bind(this), this.rate); } RateLimiter.DEFAULTS = { rate: ms('1m'), limit: 120 }; /** * Increment the counter for the given nodeID * @param {String} nodeID - The nodeID of the contact to track */ RateLimiter.prototype.updateCounter = function(nodeID) { this._counter[nodeID] = (this._counter[nodeID] || 0) + 1; }; /** * Checks if the given nodeID is currently rate limited * @param {String} nodeID - The nodeID for the contact to check * @returns {Boolean} */ RateLimiter.prototype.isLimited = function(nodeID) { return this._counter[nodeID] ? this._counter[nodeID] &gt; this.limit : false; }; /** * Resets the rate limit count */ RateLimiter.prototype.resetCounter = function() { this._counter = {}; }; /** * Returns the time left before counter reset * @returns {Number} */ RateLimiter.prototype.getResetTime = function() { return this.rate - ((Date.now() - this.started) % this.rate); }; module.exports = RateLimiter; Ã— Search results Close "},"lib_data-channels_readable-stream.js.html":{"id":"lib_data-channels_readable-stream.js.html","title":"Source: lib/data-channels/readable-stream.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/data-channels/readable-stream.js 'use strict'; var inherits = require('util').inherits; var ReadableStream = require('readable-stream'); /** * A readable stream for transferring data via {@link DataChannelClient} * @constructor * @param {DataChannelClient} channel - The data channel client to use * @param {String} token - The authorization token for transfer * @param {String} hash - The hash of the data to transfer */ function ReadableDataChannelStream(channel, token, hash) { if (!(this instanceof ReadableDataChannelStream)) { return new ReadableDataChannelStream(channel, token, hash); } var self = this; this._channel = channel; this._token = token; this._hash = hash; this._isDestroyed = false; this.isAuthenticated = false; this._channel._client.on('message', this._push.bind(this)); this._channel._client.on('close', function(code, message) { if (code !== 1000) { self.emit('error', new Error(message)); } self.push(null); }); ReadableStream.call(this); } ReadableDataChannelStream.MAX_TTFB = 5000; // NB: Time To First Byte /** * Triggered when a error occurs * @event ReadableDataChannelStream#error * @param {Error} error - The error object */ /** * Triggered when a chunk of data has been received from the remote host * @event ReadableDataChannelStream#data */ /** * Triggered when all data has been received from the remote host * @event ReadableDataChannelStream#end */ inherits(ReadableDataChannelStream, ReadableStream); /** * Implements the underlying writer * @private */ ReadableDataChannelStream.prototype._read = function() { var self = this; if (!self.isAuthenticated) { return self._channel._client.send(JSON.stringify({ token: self._token, hash: self._hash, operation: 'PULL' }), function() { self.isAuthenticated = true; self._createTTFBTimeout(); }); } }; /** * Proxies the underlying push method to clear TTFB timer * @private */ ReadableDataChannelStream.prototype._push = function(bytes) { this._clearTTFBTimeout(); this.push(bytes); }; /** * Creates a timeout for receiving the first bytes * @private */ ReadableDataChannelStream.prototype._createTTFBTimeout = function() { var self = this; this._ttfbTimeout = setTimeout(function() { self.emit( 'error', new Error('Did not receive data within max Time-To-First-Byte') ); self.destroy(); }, ReadableDataChannelStream.MAX_TTFB); }; /** * Destroys the timeout for receiving first bytes * @private */ ReadableDataChannelStream.prototype._clearTTFBTimeout = function() { clearTimeout(this._ttfbTimeout); }; /** * Closes the underlying connection * @returns {Boolean} didDestroy - Indicates if the stream was destroyed */ ReadableDataChannelStream.prototype.destroy = function() { this._clearTTFBTimeout(); if (this._isDestroyed) { return false; } this._channel._client.terminate(); this._isDestroyed = true; return true; }; module.exports = ReadableDataChannelStream; Ã— Search results Close "},"lib_network_interfaces_renter.js.html":{"id":"lib_network_interfaces_renter.js.html","title":"Source: lib/network/interfaces/renter.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/interfaces/renter.js 'use strict'; var assert = require('assert'); var Contract = require('../../contract'); var Contact = require('../contact'); var constants = require('../../constants'); var AuditStream = require('../../audit-tools/audit-stream'); var kad = require('kad'); var Network = require('..'); var inherits = require('util').inherits; var StorageItem = require('../../storage/item'); var async = require('async'); var DataChannelPointer = require('../../data-channels/pointer'); /** * Creates and a new farmer interface * @constructor * @license AGPL-3.0 * @extends {Network} * @param {Object} options * @param {KeyPair} options.keyPair - Node's cryptographic identity * @param {StorageManager} options.storageManager - Storage manager backend * @param {String} options.bridgeUri - URL for bridge server seed lookup * @param {Object} options.logger - Logger instance * @param {Array} options.seedList - List of seed URIs to join * @param {String} options.rpcAddress - Public node IP or hostname * @param {Number} options.rpcPort - Listening port for RPC * @param {Boolean} options.doNotTraverseNat - Skip NAT traversal strategies * @param {Number} options.maxTunnels - Max number of tunnels to provide * @param {Number} options.tunnelServerPort - Port for tunnel server to use * @param {Object} options.tunnelGatewayRange * @param {Number} options.tunnelGatewayRange.min - Min port for gateway bind * @param {Number} options.tunnelGatewayRange.max - Max port for gateway bind * @param {Object} options.rateLimiterOpts - Options for {@link RateLimiter} * @emits Network#ready * @property {KeyPair} keyPair * @property {StorageManager} storageManager * @property {kad.Node} node - The underlying DHT node * @property {TriggerManager} triggerManager * @property {BridgeClient} bridgeClient * @property {Contact} contact * @property {Transport} transportAdapter * @property {kad.Router} router - The underlying DHT router * @property {DataChannelServer} dataChannelServer */ function RenterInterface(options) { if (!(this instanceof RenterInterface)) { return new RenterInterface(options); } Network.call(this, options); } inherits(RenterInterface, Network); /** * Publishes a storage {@link Contract} for solicitation of offers based on the * supplied shard metadata. * @param {Contract} contract - Proposed storage contract to solicit for offers * @param {Array} [blacklist] - Optional farmer blacklist for offers * @param {RenterInterface~getStorageOfferCallback} callback - Offer handler */ RenterInterface.prototype.getStorageOffer = function(contract, bl, callback) { var self = this; if (typeof bl === 'function') { callback = bl; bl = []; } assert(contract instanceof Contract, 'Invalid contract supplied'); assert(typeof callback === 'function', 'Invalid offer handler supplied'); var hash = contract.get('data_hash'); this._pendingContracts[hash] = callback; this._pendingContracts[hash].blacklist = bl; function _handleTimeout() { if (!self._pendingContracts[hash]) { return; } self._pendingContracts[hash](new Error('No storage offers were received')); delete self._pendingContracts[hash]; } this.publish(contract.getTopicString(), contract.toObject(), { key: hash }); setTimeout(_handleTimeout, constants.OFFER_TIMEOUT); }; /** * This callback is called upon receipt of an offer from * {@link RenterInterface#getStorageOffer} * @callback RenterInterface~getStorageOfferCallback * @param {Error|null} err - An error if one is encountered * @param {Contact} farmer - The farmer who offered to fulfill the contract * @param {Contract} contract - The {@link Contact} offered by the farmer */ /** * Issues an audit request to the given farmer for the data and returns the * {@link ProofStream#getProofResult} structure for verification. * @param {Contact} farmer - Farmer contact from which proof is needed * @param {StorageItem} item - The storage item on which to perform the audit * @param {RenterInterface~getStorageProofCallback} callback - Proof handler */ RenterInterface.prototype.getStorageProof = function(farmer, item, callback) { assert(farmer instanceof Contact, 'Invalid contact supplied'); assert(item instanceof StorageItem, 'Invalid storage item supplied'); if (!item.challenges[farmer.nodeID]) { return callback(new Error('Item has no contracts with supplied farmer')); } if (!item.challenges[farmer.nodeID].challenges.length) { return callback(new Error('There are no remaining challenges to send')); } var message = new kad.Message({ method: 'AUDIT', params: { audits: [ { data_hash: item.hash, challenge: item.challenges[farmer.nodeID].challenges.shift() } ], contact: this.contact } }); this.transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } if (!Array.isArray(response.result.proofs)) { return callback(new Error('Invalid proof returned')); } callback(null, response.result.proofs[0]); }); }; /** * This callback is called upon receipt of an audit proof from * {@link RenterInterface#getStorageProof} * @callback RenterInterface~getStorageProofCallback * @param {Error|null} err - If requesting the proof failed, an error object * @param {Array} proof - Result from {@link ProofStream#getProofResult} */ /** * Requests a consignment pointer from the given farmer for opening a * {@link DataChannelClient} for transferring the the data shard to the farmer * @param {Contact} farmer - The farmer contact object for requesting token * @param {Contract} contract - The storage contract for this consignment * @param {AuditStream} audit - The audit object for merkle leaves * @param {RenterInterface~getConsignmentPointerCallback} callback */ RenterInterface.prototype.getConsignmentPointer = function(f, c, a, callback) { var farmer = f; var contract = c; var audit = a; assert(farmer instanceof Contact, 'Invalid farmer contact supplied'); assert(contract instanceof Contract, 'Invalid contract supplied'); assert(audit instanceof AuditStream, 'Invalid audit object supplied'); var message = new kad.Message({ method: 'CONSIGN', params: { data_hash: contract.get('data_hash'), audit_tree: audit.getPublicRecord(), contact: this.contact } }); this.transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } callback(null, DataChannelPointer( f, contract.get('data_hash'), response.result.token, 'PUSH' )); }); }; /** * This callback is called upon receipt of a consignment token from * {@link RenterInterface#getConsignmentPointer} * @callback RenterInterface~getConsignmentPointerCallback * @param {Error|null} err - If requesting the token failed, an error object * @param {DataChannelPointer} pointer - Pointer for a {@link DataChannelClient} */ /** * Requests a consignment token from the given farmer for opening a * {@link DataChannelClient} for transferring the the data shard to the farmer * @deprecated since version 1.4.0 * @param {Contact} farmer - The farmer contact object for requesting token * @param {Contract} contract - The storage contract for this consignment * @param {AuditStream} audit - The audit object for merkle leaves * @param {RenterInterface~getConsignTokenCallback} callback */ RenterInterface.prototype.getConsignToken = function(f, c, a, callback) { this.getConsignmentPointer(f, c, a, function(err, pointer) { if (err) { return callback(err); } callback(null, pointer.token); }); }; /** * This callback is called upon receipt of a consignment token from * {@link RenterInterface#getConsignToken} * @callback RenterInterface~getConsignTokenCallback * @param {Error|null} err - If requesting the token failed, an error object * @param {String} token - Consignment token for a {@link DataChannelClient} */ /** * Requests a retrieval token from the given farmer for opening a * {@link DataChannelClient} for transferring the data shard from the farmer * @param {Contact} farmer - The farmer contact object for requesting token * @param {Contract} contract - The storage contract for this consignment * @param {RenterInterface~getRetrievalPointerCallback} callback - Token handler */ RenterInterface.prototype.getRetrievalPointer = function(f, c, callback) { var farmer = f; var contract = c; assert(farmer instanceof Contact, 'Invalid farmer contact supplied'); assert(contract instanceof Contract, 'Invalid contract supplied'); var message = new kad.Message({ method: 'RETRIEVE', params: { data_hash: contract.get('data_hash'), contact: this.contact } }); this.transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } callback(null, DataChannelPointer( f, contract.get('data_hash'), response.result.token, 'PULL' )); }); }; /** * This callback is called upon receipt of a retrieval token from * {@link RenterInterface#getRetrieveToken} * @callback RenterInterface~getRetrievalPointerCallback * @param {Error|null} err - If requesting the token failed, an error object * @param {DataChannelPointer} pointer - Pointer for a {@link DataChannelClient} */ /** * Requests a retrieval token from the given farmer for opening a * {@link DataChannelClient} for transferring the the data shard from the farmer * @deprecated since version 1.4.0 * @param {Contact} farmer - The farmer contact object for requesting token * @param {Contract} contract - The storage contract for this retrieval * @param {RenterInterface~getConsignTokenCallback} callback */ RenterInterface.prototype.getRetrieveToken = function(f, c, callback) { this.getRetrievalPointer(f, c, function(err, pointer) { if (err) { return callback(err); } callback(null, pointer.token); }); }; /** * This callback is called upon receipt of a consignment token from * {@link RenterInterface#getConsignToken} * @callback RenterInterface~getConsignTokenCallback * @param {Error|null} err - If requesting the token failed, an error object * @param {String} token - Consignment token for a {@link DataChannelClient} */ /** * Requests that the given destination farmers mirror the data from the source * {@link DataChannelPointer}. * @param {Array.&lt;DataChannelPointer&gt;} sources - Pointers for each destination * @param {Array.&lt;Contact&gt;} destinations - The farmers to replicate to * @param {RenterInterface~getMirrorNodesCallback} callback - Results handler */ RenterInterface.prototype.getMirrorNodes = function(sources, dests, callback) { var self = this; assert(Array.isArray(sources), 'Invalid sources list supplied'); assert(Array.isArray(dests), 'Invalid destination list supplied'); assert( sources.length === dests.length, 'Sources and destinations must have equal length' ); sources.forEach(function(src) { assert(src instanceof DataChannelPointer, 'Invalid pointer supplied'); }); dests.forEach(function(dest) { assert(dest instanceof Contact, 'Invalid destination supplied'); }); function _sendMirrorRequest(destination, next) { var source = sources.shift(); var message = new kad.Message({ method: 'MIRROR', params: { data_hash: source.hash, token: source.token, farmer: source.farmer, contact: self.contact } }); self.transport.send(destination, message, function(err, response) { if (err || response.error) { return next(false); } next(true); }); } function _onMirrorRequestsComplete(results) { if (results.length === 0) { return callback(new Error('All mirror requests failed')); } callback(null, results); } async.filter(dests, _sendMirrorRequest, _onMirrorRequestsComplete); }; /** * This callback is called upon acknowledgement of a mirror request * @callback RenterInterface~getMirrorNodesCallback * @param {Error|null} err - If requesting all mirrors failed, an error object * @param {Array.&lt;Contact&gt;} results - The farmers who successfully mirrored */ module.exports = RenterInterface; Ã— Search results Close "},"lib_storage_item.js.html":{"id":"lib_storage_item.js.html","title":"Source: lib/storage/item.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/item.js 'use strict'; var assert = require('assert'); var Contract = require('../contract'); var merge = require('merge'); /** * Represents a storage item, including contracts, challenges, the shard itself * along with metadata describing download count, payments, etc * @constructor * @license AGPL-3.0 * @param {Object} data * @param {String|null} data.hash - Shard hash to use as storage key * @param {Stream|null} data.shard - Raw binary blob of shard * @param {Object} data.contracts - Dictionary of nodeID:{@link Contract} * @param {Object} data.trees - Dictionary of nodeID:merkleLeaves * @param {Object} data.challenges - Dictionary of nodeID:privateAuditData * @param {Object} data.meta - Dictionary of arbitrary nodeID:metadata */ function StorageItem(data) { if (!(this instanceof StorageItem)) { return new StorageItem(data); } data = merge({}, data); this.hash = null; this.shard = null; this.contracts = {}; this.trees = data.trees || {}; this.challenges = data.challenges || {}; this.meta = data.meta || {}; this.modified = data.modified || Date.now(); this._init(data); } /** * Adds the trees and challenges to the item keyed by nodeID * @param {Contact} contact - The contact associated with the trees * @param {Audit|AuditStream} audit - The audit or challenge generator */ StorageItem.prototype.addAuditRecords = function(contact, audit) { this.trees[contact.nodeID] = audit.getPublicRecord(); this.challenges[contact.nodeID] = audit.getPrivateRecord(); }; /** * Adds the contract data keyed by nodeID * @param {Contact} contact - The contact associated with the trees * @param {Contract} contract - The storage contract instance */ StorageItem.prototype.addContract = function(contact, contract) { this.contracts[contact.nodeID] = contract; }; /** * Adds the meta data keyed by nodeID * @param {Contact} contact - The contact associated with the trees * @param {Object} meta - Arbitrary metadata about the shard */ StorageItem.prototype.addMetaData = function(contact, meta) { this.meta[contact.nodeID] = meta; }; /** * Updates the timestamp for the item */ StorageItem.prototype.updateTimestamp = function() { this.modified = Date.now(); }; /** * Initializes the item values with the given data * @private * @param {Object} data * @returns {StorageItem} */ StorageItem.prototype._init = function(data) { assert(typeof data === 'object', 'Invalid item data supplied'); this.shard = data.shard || null; this.hash = data.hash || null; for (var nodeID in data.contracts) { this.contracts[nodeID] = new Contract(data.contracts[nodeID]); } return this; }; module.exports = StorageItem; Ã— Search results Close "},"lib_storage_manager.js.html":{"id":"lib_storage_manager.js.html","title":"Source: lib/storage/manager.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/manager.js 'use strict'; var constants = require('../constants'); var assert = require('assert'); var StorageAdapter = require('./adapter'); var StorageItem = require('./item'); var merge = require('merge'); var EventEmitter = require('events').EventEmitter; var inherits = require('util').inherits; /** * Interface for managing contracts, shards, and audits * @constructor * @license AGPL-3.0 * @extends {EventEmitter} * @param {StorageAdapter} storage - Storage adapter to use * @param {Object} options * @param {Boolean} options.disableReaper - Don't perform periodic reaping of * stale contracts * @param {Number} options.maxCapacity - Max number of bytes to allow in storage */ function StorageManager(storage, options) { if (!(this instanceof StorageManager)) { return new StorageManager(storage, options); } assert(storage instanceof StorageAdapter, 'Invalid storage adapter'); this._options = merge(Object.create(StorageManager.DEFAULTS), options); this._storage = storage; this._capacityReached = false; this._initShardReaper(); } inherits(StorageManager, EventEmitter); /** * Triggered when the underlying storage adapter reaches capacity * @event StorageManager#locked */ /** * Triggered when the underlying storage adapter has newly freed space * @event StorageManager#unlocked */ StorageManager.DEFAULTS = { disableReaper: false, maxCapacity: Infinity }; /** * Loads the storage {@link Item} at the given key * @param {String} hash - Shard hash to load data for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageManager.prototype.load = function(hash, callback) { assert(typeof hash === 'string', 'Invalid key supplied'); assert(hash.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); this._storage.get(hash, function(err, item) { if (err) { return callback(err); } if (!(item instanceof StorageItem)) { return callback(new Error('Storage adapter provided invalid result')); } callback(null, item); }); }; /** * Saves the storage {@link StorageItem} at the given key * @param {StorageItem} item - The {@link StorageItem} to store * @param {Function} callback - Called on complete */ StorageManager.prototype.save = function(item, callback) { var self = this; assert(item instanceof StorageItem, 'Invalid storage item supplied'); assert(typeof callback === 'function', 'Callback function must be supplied'); if (this._capacityReached) { return callback(new Error('Storage capacity reached')); } this._storage.put(item, function(err) { if (err) { return callback(err); } self._checkCapacity(); callback(null); }); }; /** * Opens the underlying storage adapter * @param {Function} callback - Called on complete */ StorageManager.prototype.open = function(callback) { this._storage._open(callback); }; /** * Closes the underlying storage adapter * @param {Function} callback - Called on complete */ StorageManager.prototype.close = function(callback) { this._storage._close(callback); }; /** * Enumerates all storage contracts and reaps stale data * @param {Function} callback - Called on complete */ StorageManager.prototype.clean = function(callback) { var self = this; var rstream = this._storage.createReadStream(); rstream.on('data', function(item) { rstream.pause(); var total = Object.keys(item.contracts).length; var endedOrIncomplete = 0; for (var nodeID in item.contracts) { var ended = item.contracts[nodeID].get('store_end') &lt; Date.now(); var incomplete = !item.contracts[nodeID].isComplete(); if (ended || incomplete) { endedOrIncomplete++; } } if (total === endedOrIncomplete) { self._storage.del(item.hash, function(/* err */) { rstream.resume(); }); } else { rstream.resume(); } }); rstream.on('end', function() { self._checkCapacity(); callback(); }); }; /** * Checks the underlying storage adapter's size and determines if our defined * capacity has been reached * @private */ StorageManager.prototype._checkCapacity = function() { var self = this; this._storage.size(function(err, bytes) { if (err) { return self.emit('error', err); } var capacityReached = bytes &gt;= self._options.maxCapacity; if (capacityReached !== self._capacityReached) { self.emit(capacityReached ? 'locked' : 'unlocked'); } self._capacityReached = capacityReached; }); }; /** * Initialize the shard reaper to check for stale contracts and reap shards * @private */ StorageManager.prototype._initShardReaper = function() { var self = this; if (!this._options.disableReaper) { setTimeout(self._initShardReaper.bind(self), constants.CLEAN_INTERVAL); } }; module.exports = StorageManager; Ã— Search results Close "},"lib_storage_migration.js.html":{"id":"lib_storage_migration.js.html","title":"Source: lib/storage/migration.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/migration.js 'use strict'; var assert = require('assert'); var StorageAdapter = require('./adapter'); var inherits = require('util').inherits; var EventEmitter = require('events').EventEmitter; var StorageItem = require('./item'); var WritableStream = require('readable-stream').Writable; /** * Migrates data stored with one {@link StorageAdapter} to another * @constructor * @license AGPL-3.0 * @param {StorageAdapter} source - The source adapter * @param {StorageAdapter} target - The migration destination */ function StorageMigration(source, target) { if (!(this instanceof StorageMigration)) { return new StorageMigration(source, target); } assert(source instanceof StorageAdapter, 'Invalid storage adapter supplied'); assert(target instanceof StorageAdapter, 'Invalid storage adapter supplied'); this.source = source; this.target = target; this.readyState = StorageMigration.STOPPED; this._isReady = false; EventEmitter.call(this); } inherits(StorageMigration, EventEmitter); StorageMigration.STOPPED = 0; StorageMigration.STARTED = 1; /** * Starts the migration process */ StorageMigration.prototype.start = function() { var self = this; assert( this.readyState === StorageMigration.STOPPED, 'Migration has already started' ); self.readyState = StorageMigration.STARTED; self._sourceStream = self.source.createReadStream(); self._targetStream = new WritableStream({ write: self._handleSourceObject.bind(self), objectMode: true }); self._targetStream.on('finish', self._handleSourceFinished.bind(self)); self._sourceStream.on('error', self._handleSourceError.bind(self)); self._targetStream.on('error', self._handleSourceError.bind(self)); return self._sourceStream.pipe(self._targetStream); }; /** * Stops the migration process */ StorageMigration.prototype.stop = function() { assert( this.readyState === StorageMigration.STARTED, 'Migration has already stopped' ); this._sourceStream.removeAllListeners(); this.readyState = StorageMigration.STOPPED; this._sourceStream = null; }; /** * Handles a data event from the source read stream and inserts it into the * the target adapter * @private * @param {StorageItem} sourceItem - Storage item from the source read stream */ StorageMigration.prototype._handleSourceObject = function(sourceItem, enc, cb) { var self = this; self.target.put(StorageItem(sourceItem), function(err) { if (err) { return cb(err); } self.target.get(sourceItem.hash, function(err, targetItem) { if (err) { return cb(err); } self.source.get(sourceItem.hash, function(err, fullSourceItem) { if (err) { return cb(err); } if (typeof fullSourceItem.shard.read === 'function') { return fullSourceItem.shard.pipe(targetItem.shard) .on('error', cb) .on('finish', cb); } cb(); }); }); }); }; /** * Handles the completion of the source stream read * @private */ StorageMigration.prototype._handleSourceFinished = function() { this.readyState = StorageMigration.STOPPED; this._sourceStream = null; this.emit('finish'); }; /** * Handles errors received from the underyling source stream * @private * @param {Error} error */ StorageMigration.prototype._handleSourceError = function(err) { this.readyState = StorageMigration.STOPPED; this._sourceStream = null; this.emit('error', err); }; module.exports = StorageMigration; Ã— Search results Close "},"lib_network_transport.js.html":{"id":"lib_network_transport.js.html","title":"Source: lib/network/transport.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/transport.js 'use strict'; var inherits = require('util').inherits; var kad = require('kad'); var portfinder = require('portfinder'); var natupnp = require('nat-upnp'); var ip = require('ip'); var TunnelServer = require('../tunnel/server'); var merge = require('merge'); var utils = require('../utils'); var ContactChecker = require('./contact-checker'); /** * Custom HTTP transport adapter * @constructor * @license AGPL-3.0 * @param {kad.Contact} contact - Contact object to binding to port * @param {Object} options * @param {Logger} options.logger - Logger for diagnositcs * @param {Boolean} options.cors - Enable cross origin resource sharing * @param {Number} options.maxTunnels - Number of tunnels to provide to network * @param {Boolean} options.doNotTraverseNat - Do not try to punch out of NAT * @param {Number} options.tunnelServerPort - Port for tunnel server to bind * @param {Object} options.tunnelGatewayRange * @param {Number} options.tunnelGatewayRange.min - Min port for gateway bind * @param {Number} options.tunnelGatewayRange.max - Max port for gateway bind */ function Transport(contact, options) { if (!(this instanceof Transport)) { return new Transport(contact, options); } options = merge(Object.create(Transport.DEFAULTS), options); this._maxTunnels = options.maxTunnels; this._tunnelServerPort = options.tunnelServerPort || 0; this._doNotTraverseNat = options.doNotTraverseNat; this._tunnelGatewayRange = options.tunnelGatewayRange; kad.transports.HTTP.call(this, contact, options); this._bindTunnelServer(); } Transport.DEFAULTS = { maxTunnels: 3, tunnelServerPort: 0, doNotTraverseNat: false, tunnelGatewayRange: { min: 0, max: 0 } }; inherits(Transport, kad.transports.HTTP); /** * Opens the transport, trying UPnP to become publicly addressable and falling * back to using a Tunnel * @private * @param {Function} callback */ Transport.prototype._open = function(callback) { var self = this; if (self._doNotTraverseNat) { self._isPublic = true; /* istanbul ignore next */ self._log.warn( 'your address is %s and traversal strategies are disabled', ip.isPublic(self._contact.address) ? 'public' : 'private' ); return kad.transports.HTTP.prototype._open.call(self, callback); } self._requiresTraversal = true; function _traverseNat() { self._log.warn( 'you are not publicly reachable, trying traversal strategies...' ); self._forwardPort(function(err, wanip, port) { self._isPublic = !err; if (self._isPublic) { self._contact.port = port || self._contact.port; self._log.info('node bound and port mapped: %s', self._contact.port); } kad.transports.HTTP.prototype._open.call(self, callback); self._contact.address = wanip || self._contact.address; }); } kad.transports.HTTP.prototype._open.call(self, function() { self._checkIfReachable(function(isReachable) { if (isReachable) { return callback(null); } kad.transports.HTTP.prototype._close.call(self); _traverseNat(); }); }); }; /** * Checks if we are publicly reachable * @private * @param {Function} */ Transport.prototype._checkIfReachable = function(callback) { if (ip.isPrivate(this._contact.address)) { return callback(false); } var checker = new ContactChecker(); checker.check(this._contact, function(err) { if (err) { return callback(false); } callback(true); }); }; /** * Closes the underyling transport and tunnel server * @private * @param {Function} callback */ Transport.prototype._close = function(callback) { this.tunnelServer.close(); kad.transports.HTTP.prototype._close.call(this, callback); }; /** * Creates a port mapping with UPnP * @param {Number} port - The port to forward * @param {Function} callback - Callback function */ Transport.prototype.createPortMapping = function(port, callback) { var self = this; var natupnpClient = natupnp.createClient(); natupnpClient.portMapping({ public: port, private: port, ttl: 0 }, function(err) { if (err) { self._log.warn('could not connect to NAT device via UPnP: %s', port); return callback(err); } natupnpClient.externalIp(function(err, wanip) { if (err) { self._log.warn('could not obtain public IP address'); return callback(err); } if (ip.isPrivate(wanip)) { self._log.warn('UPnP device has no public IP address: %s', wanip); return callback(new Error('UPnP device has no public IP address')); } self._log.info('successfully traversed NAT via UPnP: %s:%s', wanip, port); callback(null, String(wanip), port); }); }); }; /** * Resolve random port to use for opening a gateway * @private * @param {Number} port * @param {Function} callback */ Transport.prototype._getPort = function(callback) { var self = this; if (self._contact.port) { return callback(null, self._contact.port); } portfinder.basePort = Math.floor(Math.random() * (65535 - 1024) + 1024); portfinder.getPort(callback); }; /** * Forwards a port and resolves the public IP * @private * @param {Function} callback */ Transport.prototype._forwardPort = function(callback) { var self = this; self._getPort(function(err, port) { if (err) { self._log.warn('could not obtain port'); return callback(err); } self.createPortMapping(port, callback); }); }; /** * Set up a local tunnel server * @private */ Transport.prototype._bindTunnelServer = function() { var self = this; this._log.info( 'you are configured to tunnel up to %s connections', this._maxTunnels ); this.tunnelServer = new TunnelServer({ maxTunnels: this._maxTunnels, serverPort: this._tunnelServerPort, gatewayPortRange: this._tunnelGatewayRange, logger: self._log }); this.tunnelServer.on('ready', function() { if (self._isPublic) { return; } self.createPortMapping(this.getListeningPort(), function(err, ip, port) { if (err) { self._log.warn('failed to map port for tunserver: %s', err.message); } else { self._log.info('tunnel server bound and port mapped: %s', port); } }); }); }; /** * Sends the RPC message to the given contact * @param {Contact} contact * @param {kad.Message} message * @param {Function} callback */ Transport.prototype.send = function(contact, message, callback) { if (kad.Message.isResponse(message)) { return kad.transports.HTTP.prototype.send.apply(this, arguments); } if (!utils.isValidContact(contact, !!process.env.STORJ_ALLOW_LOOPBACK)) { return callback(new Error('Invalid or forbidden contact address')); } kad.transports.HTTP.prototype.send.apply(this, arguments); }; module.exports = Transport; Ã— Search results Close "},"lib_sips_0003_trigger-manager.js.html":{"id":"lib_sips_0003_trigger-manager.js.html","title":"Source: lib/sips/0003/trigger-manager.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/sips/0003/trigger-manager.js 'use strict'; var assert = require('assert'); /** * Implements behavior triggers as described in SIP-0003 * @constructor * @license AGPL-3.0 * @see https://github.com/storj/sips/blob/master/sip-0003.md */ function TriggerManager(options) { if (!(this instanceof TriggerManager)) { return new TriggerManager(options); } this._options = options; this._authorized = {}; this._behaviors = {}; } /** * Adds a trigger handler for the given nodeID and behavior * @param {String|Array} nodeID - The nodeID(s) to authorize for the trigger * (supports `*` wildcard) * @param {Object} behaviors - Behavior name to {TriggerManager~triggerHandler}s */ TriggerManager.prototype.add = function(nodeID, behaviors) { var self = this; if (Array.isArray(nodeID)) { return nodeID.forEach(function(nodeID) { self.add(nodeID, behaviors); }); } for (var behavior in behaviors) { assert( typeof behaviors[behavior] === 'function', 'Trigger handler must be a function' ); if (!this._authorized[behavior]) { this._authorized[behavior] = []; } if (this._authorized[behavior].indexOf(nodeID) === -1) { this._authorized[behavior].push(nodeID); } this._behaviors[nodeID + ':' + behavior] = behaviors[behavior]; } }; /** * Removes a trigger handler for the given nodeID and behavior * @param {String|Array} nodeID - The nodeID(s) to deauthorize for the trigger * @param {String|Array} behaviors - Behavior name to unregister */ TriggerManager.prototype.remove = function(nodeID, behavior) { var self = this; if (Array.isArray(nodeID)) { return nodeID.forEach(function(nodeID) { if (Array.isArray(behavior)) { return behavior.forEach(function(behavior) { self.remove(nodeID, behavior); }); } self.remove(nodeID, behavior); }); } if (this._authorized[behavior]) { var index = this._authorized[behavior].indexOf(nodeID); if (index !== -1) { this._authorized[behavior].splice(index, 1); } } delete this._behaviors[nodeID + ':' + behavior]; }; /** * Process a received trigger message * @param {Object} messageParams - The received message params * @param {TriggerManager~processCallback} callback - Result of trigger process */ TriggerManager.prototype.process = function(messageParams, callback) { var authorized = this._authorized[messageParams.behavior]; var allowAnySource = authorized ? authorized.indexOf('*') !== -1 : false; var sourceNodeId = allowAnySource || messageParams.contact.nodeID; if (!authorized) { return callback(new Error('No trigger handler defined for behavior')); } if (!allowAnySource &amp;&amp; authorized.indexOf(sourceNodeId) === -1) { return callback(new Error('Not authorized to process trigger')); } this._behaviors[sourceNodeId + ':' + messageParams.behavior]( messageParams, callback, this.remove.bind(this, sourceNodeId, messageParams.behavior) ); }; /** * Called when a trigger is received from authorized source * @callback TriggerManager~triggerHandler * @param {Object} messageParams - The RPC message parameters * @param {TriggerManager~replyToSender} replyToSender - Respond to the trigger * @param {TriggerManager~destroyTrigger} destroyTrigger - Unregisters trigger */ /** * Passed to the trigger handler for replying to the message * @callback TriggerManager~replyToSender * @param {Error|null} err - Optional error to respond with * @param {Object} params - Response parameters to return */ /** * Optionally called from trigger handler to unregister the trigger handler * @callback TriggerManager~destroyTrigger */ /** * Called upon the processing of a trigger message * @callback TriggerManager~processCallback * @param {Error|null} err - Optional error resulting from processing * @param {Object} params - Response parameters to send back */ module.exports = TriggerManager; Ã— Search results Close "},"lib_tunnel_client.js.html":{"id":"lib_tunnel_client.js.html","title":"Source: lib/tunnel/client.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/tunnel/client.js 'use strict'; var kad = require('kad'); var assert = require('assert'); var WebSocketClient = require('ws'); var TunnelMuxer = require('./multiplexer'); var TunnelDemuxer = require('./demultiplexer'); var events = require('events'); var inherits = require('util').inherits; var request = require('request'); var url = require('url'); var merge = require('merge'); /** * Creates a tunnel connection to a {@link TunnelServer} * @constructor * @license AGPL-3.0 * @param {String} tunnelServerUri - URI for remote tunnel server * @param {String} targetServerUri - Destination for forwarding messages * @param {Object} [options] * @param {Object} [options.logger] - A logger object to use */ function TunnelClient(tunnel, target, options) { if (!(this instanceof TunnelClient)) { return new TunnelClient(tunnel, target, options); } assert(typeof tunnel === 'string', 'Invalid tunnel address supplied'); assert(typeof target === 'string', 'Invalid target address supplied'); this._options = merge(Object.create(TunnelClient.DEFAULTS), options); this._logger = this._options.logger; this._tunuri = tunnel; this._target = target; this._tunnel = null; this._muxer = null; this._demuxer = null; this._channels = {}; this.readyState = TunnelClient.CLOSED; events.EventEmitter.call(this); } TunnelClient.DEFAULTS = { logger: kad.Logger(0) }; TunnelClient.OPEN = 1; TunnelClient.CLOSED = 0; /** * Triggered when the tunnel is opened * @event TunnelClient#open */ /** * Triggered when the tunnel is closed * @event TunnelClient#close */ inherits(TunnelClient, events.EventEmitter); /** * Opens the tunnel connection */ TunnelClient.prototype.open = function() { var self = this; this._logger.info('opening tunnel client to %s', this._tunuri); this._demuxer = new TunnelDemuxer(); this._muxer = new TunnelMuxer(); this._tunnel = new WebSocketClient(this._tunuri); this._demuxer.on('error', function(err) { self.emit('error', err); }); this._demuxer.on('data', function(object) { switch (object.type) { case 'rpc': self._handleRPC(object); break; case 'datachannel': self._handleDataChannel(object); break; default: self.emit('error', new Error('Cannot handle tunnel frame type')); } }); this._muxer.on('error', function(err) { self.emit('error', err); }); this._muxer.on('data', function(buffer) { self._tunnel.send(buffer, { binary: true }); }); this._tunnel.on('error', function(err) { self.close(); self.emit('error', err); }); this._tunnel.on('close', function() { self.close(); }); this._tunnel.on('open', function() { this.readyState = TunnelClient.OPEN; self.emit('open'); }); this._tunnel.on('message', function(data) { self._demuxer.write(data); }); }; /** * Closes the tunnel connection * @returns {Boolean} tunnelDidClose */ TunnelClient.prototype.close = function() { if (!this._tunnel) { return false; } this._logger.info('closing tunnel client to %s', this._tunuri); var states = [WebSocketClient.CONNECTING, WebSocketClient.OPEN]; this._muxer.removeAllListeners(); this._demuxer.removeAllListeners(); if (states.indexOf(this._tunnel.readyState) !== -1) { this._tunnel.close(); } this._tunnel = null; this.readyState = TunnelClient.CLOSED; this.emit('close'); return true; }; /** * Handles incoming RPC messages and forwards them to the target, proxying the * response back through to the tunnel server * @private * @param {Object} object - The demuxed message object */ TunnelClient.prototype._handleRPC = function(object) { var options = { url: this._target, method: 'POST', body: object.data.serialize() }; this._logger.debug('handling tunneled rpc incoming message: %j', object); request(options, this._forwardResponse.bind(this)); }; /** * Buffers the supplied response stream and sends it through the multiplexer * and back to the tunnel server * @private * @param {http.ServerResponse} res */ TunnelClient.prototype._forwardResponse = function(err, res, body) { if (err) { return this.emit('error', err); } this._logger.debug('forwarding tunneled rpc response: %j', body); this._muxer.write({ type: 'rpc', data: kad.Message.fromBuffer(Buffer(body)), flags: {} }); }; /** * Handles incoming datachannel messages and forwards them to the target, * proxying the response back through to the tunnel server * @private * @param {Object} object - The demuxed message object */ TunnelClient.prototype._handleDataChannel = function(object) { var self = this; var urlobj = url.parse(this._target); var destination = 'ws://' + urlobj.hostname + ':' + urlobj.port; var quid = object.flags.quid; this._logger.debug('handling incoming tunneled datachannel'); if (this._channels[object.flags.quid]) { this._logger.debug( 'sending datachannel content to existing session (%s)', object.flags.quid ); return this._sendToExistingSocket(object); } this._logger.debug( 'establishing loopback datachannel from tunnel client (%s)', object.flags.quid ); var socket = this._channels[quid] = new WebSocketClient(destination); socket.on('open', function() { socket.send(object.data, { binary: object.flags.binary }); }); socket.on('error', function(err) { self.emit('error', err); }); socket.on('message', function(data, flags) { self._muxer.write({ type: 'datachannel', data: data, flags: { binary: flags.binary, quid: quid } }); }); socket.on('close', function(code, message) { delete self._channels[quid]; self._logger.debug( 'sending datachannel termination signal via tunnel client (%s)', object.flags.quid ); self._muxer.write({ type: 'datachannel', data: JSON.stringify({ code: code, message: message }), flags: { binary: false, quid: quid } }); }); }; /** * Sends the object to an already open socket * @private */ TunnelClient.prototype._sendToExistingSocket = function(object) { var sock = this._channels[object.flags.quid]; if (sock.readyState !== WebSocketClient.OPEN) { return sock.once('open', function() { sock.send(object.data, { binary: object.flags.binary }); }); } return sock.send(object.data, { binary: object.flags.binary }); }; module.exports = TunnelClient; Ã— Search results Close "},"lib_tunnel_demultiplexer.js.html":{"id":"lib_tunnel_demultiplexer.js.html","title":"Source: lib/tunnel/demultiplexer.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/tunnel/demultiplexer.js 'use strict'; var stream = require('readable-stream'); var kad = require('kad'); var inherits = require('util').inherits; var constants = require('../constants'); /** * Demultiplexes a multiplexed tunnel stream * @constructor * @fires TunnelDemuxer#data * @license AGPL-3.0 */ function TunnelDemuxer() { if (!(this instanceof TunnelDemuxer)) { return new TunnelDemuxer(); } stream.Transform.call(this, { objectMode: true }); } /** * @event TunnelDemuxer#data * @param {Object} demuxedMessage * @param {String} demuxedMessage.type - The message type (rpc, datachannel) * @param {Buffer|String} demuxedMessage.data - The message payload * @param {Object} demuxedMessage.flags * @param {Boolean} demuxedMessage.flags.binary - WebSocket opcode binary flag * @param {String} demuxedMessage.flags.quid - Quasi-unique associatation ID */ inherits(TunnelDemuxer, stream.Transform); /** * Parses and demultiplexes RPC messages * @private * @param {Buffer} buffer - The RPC data to demux * @param {Function} callback */ TunnelDemuxer.prototype._demuxRPC = function(buffer, callback) { callback(null, { type: 'rpc', data: kad.Message.fromBuffer(buffer.slice(1)), flags: {} }); }; /** * Parses and demultiplexes datachannel messages * @private * @param {Buffer} buffer - The datachannel data to demux * @param {Function} callback */ TunnelDemuxer.prototype._demuxDataChannel = function(buffer, callback) { if ([0x01, 0x02].indexOf(buffer[1]) === -1) { return callback(new Error('Invalid frame type opcode supplied')); } var binary = buffer[1] === 0x02; // NB: WebSocket opcode for frame type var data = buffer.slice(8); callback(null, { type: 'datachannel', data: binary ? data : data.toString(), flags: { binary: binary, quid: buffer.slice(2, 8).toString('hex') } }); }; /** * Input transformer * @private */ TunnelDemuxer.prototype._transform = function(buffer, encoding, callback) { switch (buffer[0]) { case constants.OPCODE_TUNRPC_PREFIX: return this._demuxRPC(buffer, callback); case constants.OPCODE_TUNDCX_PREFIX: return this._demuxDataChannel(buffer, callback); default: return callback(new Error('Invalid input for tunnel demuxing')); } }; module.exports = TunnelDemuxer; Ã— Search results Close "},"lib_network_interfaces_tunneler.js.html":{"id":"lib_network_interfaces_tunneler.js.html","title":"Source: lib/network/interfaces/tunneler.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/interfaces/tunneler.js 'use strict'; var Network = require('..'); var inherits = require('util').inherits; var merge = require('merge'); var StorageManager = require('../../storage/manager'); var RAMStorageAdapter = require('../../storage/adapters/ram'); /** * Creates a new tunneler interface (a passive non-renter/non-farmer node) and * is just a {@link Network} instance, with more appropriate default options * including an in-memory storage adapter. * @constructor * @license AGPL-3.0 * @extends {Network} * @param {Object} options * @param {KeyPair} options.keyPair - Node's cryptographic identity * @param {String} options.bridgeUri - URL for bridge server seed lookup * @param {Object} options.logger - Logger instance * @param {Array} options.seedList - List of seed URIs to join * @param {String} options.rpcAddress - Public node IP or hostname * @param {Number} [options.rpcPort=8080] - Listening port for RPC * @param {Boolean} [options.doNotTraverseNat=true] - Skip NAT traversal * @param {Number} [options.maxTunnels] - Max number of tunnels to provide * @param {Number} [options.tunnelServerPort=8081] - Port for tunnel server * @param {Object} options.tunnelGatewayRange * @param {Number} [options.tunnelGatewayRange.min=8082] - Min port for bind * @param {Number} [options.tunnelGatewayRange.max=9005] - Max port for bind * @param {Object} options.rateLimiterOpts - Options for {@link RateLimiter} */ function TunnelerInterface(options) { if (!(this instanceof TunnelerInterface)) { return new TunnelerInterface(options); } options = merge(Object.create(TunnelerInterface.DEFAULTS), options); Network.call(this, merge(options, { storageManager: new StorageManager(new RAMStorageAdapter()) })); } inherits(TunnelerInterface, Network); TunnelerInterface.DEFAULTS = merge(Object.create(Network.DEFAULTS), { maxTunnels: 24, rpcPort: 8080, tunnelServerPort: 8081, tunnelGatewayRange: { min: 8082, max: 9005 }, doNotTraverseNat: true // NB: Tunnelers generally should be public already }); module.exports = TunnelerInterface; Ã— Search results Close "},"lib_tunnel_gateway.js.html":{"id":"lib_tunnel_gateway.js.html","title":"Source: lib/tunnel/gateway.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/tunnel/gateway.js 'use strict'; var kad = require('kad'); var http = require('http'); var https = require('https'); var ws = require('ws'); var events = require('events'); var inherits = require('util').inherits; var crypto = require('crypto'); var merge = require('merge'); /** * Creates a tunnel gateway and emits manages entry and exit messages * @constructor * @license AGPL-3.0 * @param {Object} options - Options to pass to http.Server/https.Server * @param {Object} [options.logger] - A logger to use * @param {Number} port - Port to bind gateway entrance * @fires TunnelGateway#message/rpc * @fires TunnelGateway#message/datachannel */ function TunnelGateway(options, port) { if (!(this instanceof TunnelGateway)) { return new TunnelGateway(options, port); } this._port = port || 0; this._options = merge(Object.create(TunnelGateway.DEFAULTS), options); this._server = this._options.cert &amp;&amp; this._options.key ? https.createServer(this._options, this._handleRPC.bind(this)) : http.createServer(this._handleRPC.bind(this)); this._websock = new ws.Server({ server: this._server }); this._logger = this._options.logger; // Manages pending RPC responses this._responses = {}; // Manages open data channel sockets this._channels = {}; this.token = crypto.randomBytes(32).toString('hex'); } TunnelGateway.DEFAULTS = { logger: kad.Logger(0) }; /** * Triggered when a message is received over RPC * @event TunnelGateway#message/rpc * @param {Object} message - The parsed RPC message received */ /** * Triggered when the gateway is opened * @event TunnelGateway#open */ /** * Triggered when the gateway is closed * @event TunnelGateway#close */ /** * Triggered when a message is received over a datachannel * @event TunnelGateway#message/datachannel * @param {Buffer|String} data - The data frame received * @param {Object} flags - WebSocket flags included * @param {Boolean} flags.binary - Frame was sent with 0x02 opcode * @param {String} flags.quid - Quasi-unique ID assigned to this socket */ inherits(TunnelGateway, events.EventEmitter); /** * Returns the alias data for the gateway * @returns {Object|null} alias */ TunnelGateway.prototype.getEntranceAddress = function() { var addr = this._server.address(); if (addr === null) { return addr; } return { address: addr.address, port: addr.port }; }; /** * Returns the authorization token for this gateway * @returns {Object} alias */ TunnelGateway.prototype.getEntranceToken = function() { return this.token; }; /** * Dispatches the supplied response the the given pending RPC by ID * @param {Object} message - The JSON-RPC message response * @returns {Boolean} sent - Whether or not the message was sent */ TunnelGateway.prototype.respond = function(message) { var response = kad.Message(message); if (!this._responses[message.id]) { return false; } try { this._logger.debug('responding for tunneled client for %s', message.id); this._responses[message.id].end(response.serialize()); delete this._responses[message.id]; } catch (err) { return false; } return true; }; /** * Writes the supplied data to the socket at the given quid * @param {String} quid - The quasi-unique socket identifier * @param {String|Buffer} - The data to be transferred * @returns {Boolean} sent - Whether or not the data was transferred */ TunnelGateway.prototype.transfer = function(quid, data) { var flags = { binary: Buffer.isBuffer(data) }; if (!this._channels[quid]) { return false; } if (!flags.binary) { var terminationInfo = this._checkForTerminationSignal(data); if (terminationInfo.isTerminationSignal) { this._logger.debug( 'sending tunneled datachannel termination signal (%s)', quid ); return this.terminate( quid, terminationInfo.parsedSignal.code, terminationInfo.parsedSignal.message ); } } try { this._logger.debug('sending tunneled datachannel content (%s)', quid); this._channels[quid].send(data, flags); } catch (err) { return false; } return true; }; /** * Checks if a datachannel message is a termination signal * @private */ TunnelGateway.prototype._checkForTerminationSignal = function(data) { var result = { isTerminationSignal: false, parsedSignal: null }; try { result.parsedSignal = JSON.parse(data); } catch (err) { return result; } result.isTerminationSignal = !!(result.parsedSignal.code &amp;&amp; result.parsedSignal.message); return result; }; /** * Terminates the specified channel * @param {String} quid - The quasi-unique socket identifier * @param {Number} code - The status code * @param {String} [message] - Status message * @returns {Boolean} terminated - Whether or not the channel was terminated */ TunnelGateway.prototype.terminate = function(quid, code, message) { if (!this._channels[quid]) { return false; } try { this._channels[quid].close(code, message); } catch (err) { return false; } this._logger.debug('tunneled datachannel terminated (%s)', quid); return true; }; /** * Opens the gateway * @param {Function} callback - Optional completion callback */ TunnelGateway.prototype.open = function(callback) { var self = this; if (callback) { this.once('open', callback); this.once('error', callback); } this._websock.on('error', this._handleError.bind(this)); this._server.on('listening', function() { self._logger.info('tunnel gateway opened on port %s', self._port); self._websock.on('connection', self._handleDataChannel.bind(self)); self._onGatewayOpen(); }); this._server.listen(this._port); }; /** * Closes the gateway * @param {Function} callback - Optional completion callback */ TunnelGateway.prototype.close = function(callback) { var self = this; if (callback) { this.once('close', callback); } try { this._shutdown(); } catch (err) { // noop } this._responses = {}; this._channels = {}; setImmediate(function() { self._logger.info('tunnel gateway on port %s closed', self._port); self.emit('close'); }); }; /** * Forces a gateway shutdown * @private */ TunnelGateway.prototype._shutdown = function() { this._websock.close(); this._server.close(); for (var id in this._responses) { this._responses[id].end(); } for (var quid in this._channels) { this._channels[quid].close(); } }; /** * Handles incoming RPC messages * @private */ TunnelGateway.prototype._handleRPC = function(req, res) { var self = this; var message = new Buffer([]); req.on('data', function(chunk) { message = Buffer.concat([message, chunk]); }); req.on('end', function() { try { message = kad.Message.fromBuffer(message); } catch (err) { res.writeHead(400); return res.end(); } self._responses[message.id] = res; // Keep track of this response self.emit('message/rpc', message); }); req.on('error', function(err) { self._logger.error( 'problem receiving rpc message on tunnel gateway: %s', err.message ); }); }; /** * Handles incoming data channel connections * @private */ TunnelGateway.prototype._handleDataChannel = function(socket) { var self = this; var quid = crypto.randomBytes(6).toString('hex'); this._channels[quid] = socket; socket.on('message', function(data, flags) { flags.quid = quid; self.emit('message/datachannel', data, flags); }); socket.on('close', function() { delete self._channels[quid]; }); socket.on('error', function(err) { self._logger.error( 'problem receiving datachannel on tunnel gateway: %s', err.message ); }); }; /** * Bubbles error events * @private */ TunnelGateway.prototype._handleError = function() { this.emit('error', new Error('Failed to open tunnel gateway')); }; /** * Fired when server begins listening * @private */ TunnelGateway.prototype._onGatewayOpen = function() { var self = this; setImmediate(function() { self.emit('open', self.getEntranceToken(), self.getEntranceAddress()); }); }; module.exports = TunnelGateway; Ã— Search results Close "},"lib_tunnel_multiplexer.js.html":{"id":"lib_tunnel_multiplexer.js.html","title":"Source: lib/tunnel/multiplexer.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/tunnel/multiplexer.js 'use strict'; var stream = require('readable-stream'); var inherits = require('util').inherits; var constants = require('../constants'); /** * Multiplexes events from a {@link TunnelGateway} and exposes a readable * stream to piped down to a {@link TunnelClient} (and vice-versa). * @constructor * @license AGPL-3.0 */ function TunnelMuxer() { if (!(this instanceof TunnelMuxer)) { return new TunnelMuxer(); } stream.Transform.call(this, { objectMode: true }); } inherits(TunnelMuxer, stream.Transform); /** * Set up event listeners for a {@link TunnelGateway} or {@link TunnelClient} * @param {TunnelGateway|TunnelClient} source - Input source to add * @returns {TunnelGateway|TunnelClient} source */ TunnelMuxer.prototype.source = function(source) { var self = this; source.on('message/rpc', function(message) { self.write({ type: 'rpc', data: message, flags: {} }); }); source.on('message/datachannel', function(data, flags) { self.write({ type: 'datachannel', data: data, flags: flags }); }); return (this._source = source); }; /** * Parses and multiplexes RPC messages * @private * @param {kad.Message} message - The RPC message to mux * @param {Function} callback */ TunnelMuxer.prototype._muxRPC = function(message, callback) { callback(null, Buffer.concat([ Buffer([constants.OPCODE_TUNRPC_PREFIX]), message.serialize() ])); }; /** * Parses and multiplexes datachannel messages * @private * @param {Buffer|String} data - The included data in the datachannel message * @param {Object} flags - Metadata about the message * @param {Function} callback */ TunnelMuxer.prototype._muxDataChannel = function(data, flags, callback) { callback(null, Buffer.concat([ Buffer([constants.OPCODE_TUNDCX_PREFIX]), Buffer([flags.binary ? 0x02 : 0x01]), // NB: WebSocket opcode for frame type Buffer(flags.quid, 'hex'), Buffer(data) ])); }; /** * Input transformer * @private */ TunnelMuxer.prototype._transform = function(object, encoding, callback) { switch (object.type) { case 'rpc': return this._muxRPC(object.data, callback); case 'datachannel': return this._muxDataChannel(object.data, object.flags, callback); default: return callback(new Error('Invalid input for tunnel muxing')); } }; module.exports = TunnelMuxer; Ã— Search results Close "},"lib_tunnel_server.js.html":{"id":"lib_tunnel_server.js.html","title":"Source: lib/tunnel/server.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/tunnel/server.js 'use strict'; var TunnelGateway = require('./gateway'); var TunnelMuxer = require('./multiplexer'); var TunnelDemuxer = require('./demultiplexer'); var ws = require('ws'); var merge = require('merge'); var url = require('url'); var qs = require('querystring'); var events = require('events'); var inherits = require('util').inherits; var async = require('async'); var TunnelErrors = require('./error-codes'); var kad = require('kad'); /** * Creates a Tunnel server for NATed or firewalled clients to use to join the * overlay network. * @constructor * @license AGPL-3.0 * @param {Object} options * @param {http.Server} [options.server] - Transport adapter to bind to * @param {Number} [options.serverPort=4001] - Port to bind if no server given * @param {Number} [options.maxTunnels=3] - Maximum number of gateways to open * @param {Object} [options.gatewayPortRange] * @param {Number} [options.gatewayPortRange.min=4002] - Min gateway port bind * @param {Number} [options.gatewayPortRange.max=4003] - Min gateway port bind * @param {Object} [options.logger] - A Logger object to use */ function TunnelServer(options) { if (!(this instanceof TunnelServer)) { return new TunnelServer(options); } this._options = merge(Object.create(TunnelServer.DEFAULTS), options); this._logger = this._options.logger; this._serveropts = { path: '/tun', verifyClient: this._verifyClient.bind(this) }; this._server = new ws.Server( this._options.server ? merge(this._serveropts, { server: this._options.server }) : merge(this._serveropts, { port: this._options.serverPort }) ); this._gateways = {}; // NB: {@link TunnelGateway}s keyed by their token this._authorized = []; // NB: List of authorized tokens this._usedPorts = []; this._server.on('connection', this._handleClient.bind(this)); this._server._server.on('listening', this._emitReady.bind(this)); events.EventEmitter.call(this); } /** * Triggered when the server is listening * @event TunnelServer#ready */ /** * Triggered when the server has no more available tunnels * @event TunnelServer#locked */ /** * Triggered when the server has an available tunnel * @event TunnelServer#unlocked */ inherits(TunnelServer, events.EventEmitter); TunnelServer.DEFAULTS = { serverPort: 4001, server: null, maxTunnels: 3, gatewayPortRange: { min: 4002, max: 4004 }, logger: kad.Logger(0) }; /** * Closes the tunnel server * @param {Function} callback */ TunnelServer.prototype.close = function(callback) { var self = this; this._logger.info('shutting down tunnel server'); this._server.close(function(err) { if (err) { return callback(err); } self._shutdownGateways(callback); }); }; /** * Shuts all the gateways down * @private * @param {Function} callback */ TunnelServer.prototype._shutdownGateways = function(callback) { var self = this; async.forEachOf(this._gateways, function(gateway, id, done) { self._logger.info('shutting down gateway %s', id); gateway.close(done); }, callback); }; /** * Creates a new {@link TunnelGateway} and prepares it for use * @param {Function} callback - Called on {@link TunnelGateway#event:open} */ TunnelServer.prototype.createGateway = function(callback) { if (Object.keys(this._gateways).length &gt;= this._options.maxTunnels) { return callback(new Error('Maximum number of tunnels open')); } var self = this; var gateway = new TunnelGateway( { logger: self._logger }, this._getAvailablePort() ); var authID = gateway.getEntranceToken(); var usedPort = null; gateway.on('close', function() { delete self._gateways[authID]; self._usedPorts.splice(self._usedPorts.indexOf(usedPort), 1); self.emit('unlocked'); }); gateway.on('open', function(token) { authID = token; self._gateways[authID] = gateway; usedPort = gateway.getEntranceAddress().port; self._usedPorts.push(usedPort); if (Object.keys(self._gateways).length &gt;= self._options.maxTunnels) { self.emit('locked'); } self._authorized.push(authID); callback(null, gateway); }); gateway.on('error', callback); self._logger.info('opening new gateway for tunneled client: %s', authID); gateway.open(); }; /** * Returns whether or not this tunnel server has any available tunnels * @returns {Boolean} */ TunnelServer.prototype.hasTunnelAvailable = function() { return Object.keys(this._gateways).length &lt; this._options.maxTunnels; }; /** * Returns the port the tunnel server is listening on * @returns {Number} port */ TunnelServer.prototype.getListeningPort = function() { return this._server._server.address().port; }; /** * Handles the verfication of a connecting client by the supplied token * @private * @param {Object} info * @param {Function} callback * @see https://github.com/websockets/ws/blob/master/doc/ws.md */ TunnelServer.prototype._verifyClient = function(info, callback) { var token = this._extractTokenFromRequest(info.req); if (this._authorized.indexOf(token) === -1) { this._logger.warn('rejecting unauthorized connection to tunnel gateway'); return callback(false, 401); } this._authorized.splice(this._authorized.indexOf(token), 1); this._logger.info('authorized client connection to tunnel gateway'); callback(true); }; /** * Returns an available port, suitable for opening a gateway * @private */ TunnelServer.prototype._getAvailablePort = function() { if (!this._options.gatewayPortRange.min) { return 0; } var start = this._options.gatewayPortRange.min; var end = this._options.gatewayPortRange.max; var available = []; while (start &lt;= end) { available.push(start++); } for (var i = 0; i &lt; this._usedPorts.length; i++) { if (available.indexOf(this._usedPorts[i]) !== -1) { available.splice(available.indexOf(this._usedPorts[i]), 1); } } return available[Math.floor(Math.random() * available.length)]; }; /** * Extracts the token from the request url * @private * @param {http.IncomingMessage} req */ TunnelServer.prototype._extractTokenFromRequest = function(req) { var uriobj = url.parse(req.url); var query = qs.parse(uriobj.query); return query.token; }; /** * Emits the ready event * @private */ TunnelServer.prototype._emitReady = function() { this.emit('ready'); }; /** * Handles an authorized client connection and connects it the the appropriate * {@link TunnelGateway} and associated {@link TunnelDemuxer} * @private * @param {WebSocket} client */ TunnelServer.prototype._handleClient = function(client) { var token = this._extractTokenFromRequest(client.upgradeReq); if (!this._gateways[token]) { return client.close( TunnelErrors.GATEWAY_CLOSED, 'Gateway no longer open' ); } var gateway = this._gateways[token]; var muxer = new TunnelMuxer(); var demuxer = new TunnelDemuxer(); function cleanup() { gateway.close(); demuxer.removeAllListeners(); muxer.removeAllListeners(); } demuxer .on('error', function(err) { client.close(TunnelErrors.UNEXPECTED, err.message); }) .on('data', function(object) { switch (object.type) { case 'rpc': return gateway.respond(object.data); case 'datachannel': return gateway.transfer(object.flags.quid, object.data); default: client.close( TunnelErrors.INVALID_FRAME_TYPE, 'Cannot handle tunnel frame type' ); } }); muxer .on('error', function(err) { client.close(TunnelErrors.UNEXPECTED, err.message); }) .on('data', function(data) { if (ws.OPEN !== client.readyState) { return cleanup(); } client.send(data, { binary: true }); }) .source(gateway); client .on('message', function(data) { demuxer.write(data); }) .on('close', cleanup) .on('error', cleanup); }; module.exports = TunnelServer; Ã— Search results Close "},"lib_file-handling_unpadder.js.html":{"id":"lib_file-handling_unpadder.js.html","title":"Source: lib/file-handling/unpadder.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/file-handling/unpadder.js 'use strict'; var stream = require('readable-stream'); var inherits = require('util').inherits; /** * Takes an input stream and removes padded zeroes from the tail * @constructor * @license LGPL-3.0 */ function Unpadder() { if (!(this instanceof Unpadder)) { return new Unpadder(); } stream.Transform.call(this); } inherits(Unpadder, stream.Transform); /** * Implements the transformer * @private */ Unpadder.prototype._transform = function(chunk, enc, callback) { var firstNullByte = chunk.indexOf(0); var lastNullByte = chunk.lastIndexOf(0); var lastByteIsNull = lastNullByte === chunk.length - 1; var expectedPadding = Buffer(lastNullByte - firstNullByte).fill(0); var possiblePadding = chunk.slice(firstNullByte, lastNullByte); var sectionIsNull = Buffer.compare(expectedPadding, possiblePadding) === 0; var isPadding = sectionIsNull &amp;&amp; lastByteIsNull; if (isPadding) { callback(null, chunk.slice(0, firstNullByte)); } else { callback(null, chunk); } }; module.exports = Unpadder; Ã— Search results Close "},"lib_bridge-client_upload-state.js.html":{"id":"lib_bridge-client_upload-state.js.html","title":"Source: lib/bridge-client/upload-state.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/bridge-client/upload-state.js 'use strict'; var async = require('async'); var utils = require('../utils'); var merge = require('merge'); var inherits = require('util').inherits; var EventEmitter = require('events').EventEmitter; var rimraf = require('rimraf'); /** * Internal state machine used by {@link BridgeClient} * @constructor * @license LGPL-3.0 * @param {Object} options * @param {String} options.id - Bucket ID for the upload state * @param {String} options.file - Path to the file to track * @param {Number} options.numShards - The number of shards to transfer * @param {Number} options.concurrency - The number shards to transfer at once * @param {Function} options.worker - The queue task processor function * @param {Function} options.onComplete - Reference to callback after complete */ function UploadState(options) { /* jshint maxstatements: 16 */ if (!(this instanceof UploadState)) { return new UploadState(options); } options = merge(Object.create(UploadState.DEFAULTS), options); this.bucketId = options.id; this.file = options.file; this.cleanQueue = []; this.numShards = options.numShards; this.completed = 0; this.callback = options.onComplete; this.concurrency = options.concurrency; this.queue = async.queue(options.worker, this.concurrency); this.killed = false; this.dataChannels = []; EventEmitter.call(this); this.setMaxListeners(0); } inherits(UploadState, EventEmitter); /** * Triggered when the upload queue has been killed * @event UploadState#killed */ UploadState.DEFAULTS = { concurrency: 6 }; /** * Unlinks the referenced tmp files */ UploadState.prototype.cleanup = function() { this.killed = true; this.cleanQueue.forEach(function(tmpFilePath) { if (utils.existsSync(tmpFilePath)) { rimraf.sync(tmpFilePath); } }); this.dataChannels.forEach(function(channel) { channel.destroy(); }); this.queue.kill(); this.emit('killed'); this.removeAllListeners(); }; module.exports = UploadState; Ã— Search results Close "},"lib_audit-tools_verification.js.html":{"id":"lib_audit-tools_verification.js.html","title":"Source: lib/audit-tools/verification.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/audit-tools/verification.js 'use strict'; var assert = require('assert'); var utils = require('../utils'); /** * Interface for verifying the result of an audit proof * @constructor * @license LGPL-3.0 * @param {Array} proof - The result of {@link ProofStream#getProofResult} */ function Verification(proof) { if (!(this instanceof Verification)) { return new Verification(proof); } assert(Array.isArray(proof), 'Proof must be an array'); this._proof = proof; } /** * Extracts the challenge response from the proof * @private * @param {Array} response - Challenge response received from farmer * @returns {String} leaf */ Verification.prototype._getChallengeResponse = function(tuple) { var data = tuple || this._proof; if (data.length === 1) { return utils.rmd160sha256(data[0]); } if (Array.isArray(data[0])) { return this._getChallengeResponse(data[0]); } else { return this._getChallengeResponse(data[1]); } }; /** * Verifies the proof given the merkle root and tree depth * @param {String} merkleRoot - Merkle root * @param {Number} totalDepth - Depth of merkle tree * @returns {Array} result - Array with expected result and verified result */ Verification.prototype.verify = function(root, totaldepth) { function _collapse(proof, leaf, depth) { if (depth === 0) { assert(proof.length === 1, 'Invalid proof structure'); assert(utils.rmd160sha256(proof[0]) === leaf, 'Invalid proof value'); return leaf; } var hashL, hashR; if (Array.isArray(proof[0])) { hashL = _collapse(proof[0], leaf, depth - 1); } else { hashL = proof[0]; } if (Array.isArray(proof[1])) { hashR = _collapse(proof[1], leaf, depth - 1); } else { hashR = proof[1]; } return utils.rmd160sha256(hashL + hashR); } return [ _collapse(this._proof, this._getChallengeResponse(), totaldepth - 1), root ]; }; module.exports = Verification; Ã— Search results Close "},"lib_data-channels_writable-stream.js.html":{"id":"lib_data-channels_writable-stream.js.html","title":"Source: lib/data-channels/writable-stream.js","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/data-channels/writable-stream.js 'use strict'; var WebSocketClient = require('ws'); var FlushWritable = require('flushwritable'); var inherits = require('util').inherits; /** * A writable stream for transferring data via {@link DataChannelClient} * @constructor * @param {DataChannelClient} channel - The data channel client to use * @param {String} token - The authorization token for transfer * @param {String} hash - The hash of the data to transfer */ function WritableDataChannelStream(channel, token, hash) { if (!(this instanceof WritableDataChannelStream)) { return new WritableDataChannelStream(channel, token, hash); } var self = this; this._channel = channel; this._token = token; this._hash = hash; this._isDestroyed = false; this.isAuthenticated = false; this._channel._client.on('close', function(code, message) { self._clearTTWATimeout(); self._handleClosed(function(err) { if (err) { return self.emit('error', err); } self.emit('finish'); }, code, message); }); FlushWritable.call(this); } WritableDataChannelStream.MAX_TTWA = 5000; // NB: Time To Write Acknowledgement /** * Triggered when a error occurs * @event WritableDataChannelStream#error * @param {Error} error - The error object */ /** * Triggered when all data has been flushed and remote host receives it * @event WritableDataChannelStream#finish */ inherits(WritableDataChannelStream, FlushWritable); /** * Implements the underlying writer * @private */ WritableDataChannelStream.prototype._write = function(chunk, enc, callback) { var self = this; if (!this.isAuthenticated) { return self._channel._client.send(JSON.stringify({ token: self._token, hash: self._hash, operation: 'PUSH' }), function() { self.isAuthenticated = true; self._sendData(chunk, callback); }); } self._sendData(chunk, callback); }; /** * Implements the underyling flusher (only emit finish after data is received) * @private */ WritableDataChannelStream.prototype._flush = function(callback) { var self = this; function _flush(code, message) { self._clearTTWATimeout(); self._handleClosed.call( self._channel._client, callback, code, message ); } if (self._channel._client.readyState !== WebSocketClient.CLOSED) { self._channel._client.removeAllListeners('close'); self._channel._client.on('close', _flush); self._createTTWATimeout(); } else { callback(null); } }; /** * Create a timeout for the remote host to acknowledge data was written * @private */ WritableDataChannelStream.prototype._createTTWATimeout = function() { var self = this; this._ttwaTimeout = setTimeout(function() { self.removeAllListeners('close'); self.destroy(); self.emit( 'error', new Error('Did not close channel by max Time-To-Write-Acknowledgement') ); }, WritableDataChannelStream.MAX_TTWA); }; /** * Clears the timeout for TTWA * @private */ WritableDataChannelStream.prototype._clearTTWATimeout = function() { clearTimeout(this._ttwaTimeout); }; /** * Send the data to the remote host * @private */ WritableDataChannelStream.prototype._sendData = function(chunk, next) { var self = this; if (WebSocketClient.OPEN !== self._channel._client.readyState) { return self.emit('error', new Error('Remote host terminated early')); } self._channel._client.send(chunk, { binary: true }, next); }; /** * If the remote host terminates before we call _flush, handle it * @private */ WritableDataChannelStream.prototype._handleClosed = function(flush, code, msg) { if (code !== 1000) { var err = new Error(msg || 'Unspecified error occurred'); err.code = code; return flush(err); } flush(null); }; /** * Closes the underlying connection * @returns {Boolean} didDestroy - Indicates if the stream was destroyed */ WritableDataChannelStream.prototype.destroy = function() { if (this._isDestroyed) { return false; } this._channel._client.terminate(); this._isDestroyed = true; return true; }; module.exports = WritableDataChannelStream; Ã— Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Modules Classes AuditStream Blacklist BridgeClient Contact ContactChecker Contract DataChannelClient DataChannelPointer DataChannelServer DataCipherKeyIv DecryptStream EmbeddedStorageAdapter EncryptStream FarmerInterface FileDemuxer FileMuxer KeyPair KeyRing Monitor Network Padder ProofStream Protocol RAMStorageAdapter RateLimiter ReadableDataChannelStream RenterInterface StorageAdapter StorageItem StorageManager StorageMigration Transport TriggerManager TunnelClient TunnelDemuxer TunnelerInterface TunnelGateway TunnelMuxer TunnelServer Unpadder UploadState Verification WritableDataChannelStream Events finish Triggered when the stream has ended Source: lib/audit-tools/audit-stream.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/client.js open Triggered when the connection is opened Source: lib/data-channels/client.js connection Triggered when a connection is opened Parameters: Name Type Description socket WebSocket The socket connection opened Source: lib/data-channels/server.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description item StorageItem The item associated with the download Source: lib/data-channels/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description item StorageItem The item associated with the upload Source: lib/data-channels/server.js data Triggered when some input bytes have become decrypted output bytes Type: Buffer Source: lib/crypto-tools/decrypt-stream.js end Triggered when the stream has ended Source: lib/crypto-tools/decrypt-stream.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js data Triggered when some input bytes have become encrypted output bytes Type: Buffer Source: lib/crypto-tools/encrypt-stream.js end Triggered when the stream has ended Source: lib/crypto-tools/encrypt-stream.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js finish Triggered when the demuxer has finished writing to all shards Source: lib/file-handling/file-demuxer.js shard Triggered when the demuxer has a shard ready to stream Parameters: Name Type Description shard ReadableStream The file shard as a readable stream Source: lib/file-handling/file-demuxer.js drain Triggered when the muxer has drained one of the supplied inputs Parameters: Name Type Description input ReadableStream The drained input stream Source: lib/file-handling/file-muxer.js update Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description stats Object Source: lib/network/monitor.js connected Triggered when the node has entered the overlay network Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Source: lib/network/index.js error Triggered when an error occurs Source: lib/network/index.js ready Triggered when the transport's network interface is ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Source: lib/network/index.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js data Triggered when a chunk of data has been received from the remote host Source: lib/data-channels/readable-stream.js end Triggered when all data has been received from the remote host Source: lib/data-channels/readable-stream.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/readable-stream.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js ready Triggered when the adapter is ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Source: lib/storage/adapter.js locked Triggered when the underlying storage adapter reaches capacity Source: lib/storage/manager.js unlocked Triggered when the underlying storage adapter has newly freed space Source: lib/storage/manager.js close Triggered when the tunnel is closed Source: lib/tunnel/client.js open Triggered when the tunnel is opened Source: lib/tunnel/client.js data Parameters: Name Type Description demuxedMessage Object Properties Name Type Description type String The message type (rpc, datachannel) data Buffer | String The message payload flags Object Properties Name Type Description binary Boolean WebSocket opcode binary flag quid String Quasi-unique associatation ID Source: lib/tunnel/demultiplexer.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js close Triggered when the gateway is closed Source: lib/tunnel/gateway.js message/datachannel Triggered when a message is received over a datachannel Parameters: Name Type Description data Buffer | String The data frame received flags Object WebSocket flags included Properties Name Type Description binary Boolean Frame was sent with 0x02 opcode quid String Quasi-unique ID assigned to this socket Source: lib/tunnel/gateway.js message/rpc Triggered when a message is received over RPC Parameters: Name Type Description message Object The parsed RPC message received Source: lib/tunnel/gateway.js open Triggered when the gateway is opened Source: lib/tunnel/gateway.js locked Triggered when the server has no more available tunnels Source: lib/tunnel/server.js ready Triggered when the server is listening Source: lib/tunnel/server.js unlocked Triggered when the server has an available tunnel Source: lib/tunnel/server.js killed Triggered when the upload queue has been killed Source: lib/bridge-client/upload-state.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/writable-stream.js finish Triggered when all data has been flushed and remote host receives it Source: lib/data-channels/writable-stream.js Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Classes Classes AuditStream Blacklist BridgeClient Contact ContactChecker Contract DataChannelClient DataChannelPointer DataChannelServer DataCipherKeyIv DecryptStream EmbeddedStorageAdapter EncryptStream FarmerInterface FileDemuxer FileMuxer KeyPair KeyRing Monitor Network Padder ProofStream Protocol RAMStorageAdapter RateLimiter ReadableDataChannelStream RenterInterface StorageAdapter StorageItem StorageManager StorageMigration Transport TriggerManager TunnelClient TunnelDemuxer TunnelerInterface TunnelGateway TunnelMuxer TunnelServer Unpadder UploadState Verification WritableDataChannelStream Events finish Triggered when the stream has ended Source: lib/audit-tools/audit-stream.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/client.js open Triggered when the connection is opened Source: lib/data-channels/client.js connection Triggered when a connection is opened Parameters: Name Type Description socket WebSocket The socket connection opened Source: lib/data-channels/server.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description item StorageItem The item associated with the download Source: lib/data-channels/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description item StorageItem The item associated with the upload Source: lib/data-channels/server.js data Triggered when some input bytes have become decrypted output bytes Type: Buffer Source: lib/crypto-tools/decrypt-stream.js end Triggered when the stream has ended Source: lib/crypto-tools/decrypt-stream.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js data Triggered when some input bytes have become encrypted output bytes Type: Buffer Source: lib/crypto-tools/encrypt-stream.js end Triggered when the stream has ended Source: lib/crypto-tools/encrypt-stream.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js finish Triggered when the demuxer has finished writing to all shards Source: lib/file-handling/file-demuxer.js shard Triggered when the demuxer has a shard ready to stream Parameters: Name Type Description shard ReadableStream The file shard as a readable stream Source: lib/file-handling/file-demuxer.js drain Triggered when the muxer has drained one of the supplied inputs Parameters: Name Type Description input ReadableStream The drained input stream Source: lib/file-handling/file-muxer.js update Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description stats Object Source: lib/network/monitor.js connected Triggered when the node has entered the overlay network Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Source: lib/network/index.js error Triggered when an error occurs Source: lib/network/index.js ready Triggered when the transport's network interface is ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Source: lib/network/index.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js data Triggered when a chunk of data has been received from the remote host Source: lib/data-channels/readable-stream.js end Triggered when all data has been received from the remote host Source: lib/data-channels/readable-stream.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/readable-stream.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js ready Triggered when the adapter is ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Source: lib/storage/adapter.js locked Triggered when the underlying storage adapter reaches capacity Source: lib/storage/manager.js unlocked Triggered when the underlying storage adapter has newly freed space Source: lib/storage/manager.js close Triggered when the tunnel is closed Source: lib/tunnel/client.js open Triggered when the tunnel is opened Source: lib/tunnel/client.js data Parameters: Name Type Description demuxedMessage Object Properties Name Type Description type String The message type (rpc, datachannel) data Buffer | String The message payload flags Object Properties Name Type Description binary Boolean WebSocket opcode binary flag quid String Quasi-unique associatation ID Source: lib/tunnel/demultiplexer.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js close Triggered when the gateway is closed Source: lib/tunnel/gateway.js message/datachannel Triggered when a message is received over a datachannel Parameters: Name Type Description data Buffer | String The data frame received flags Object WebSocket flags included Properties Name Type Description binary Boolean Frame was sent with 0x02 opcode quid String Quasi-unique ID assigned to this socket Source: lib/tunnel/gateway.js message/rpc Triggered when a message is received over RPC Parameters: Name Type Description message Object The parsed RPC message received Source: lib/tunnel/gateway.js open Triggered when the gateway is opened Source: lib/tunnel/gateway.js locked Triggered when the server has no more available tunnels Source: lib/tunnel/server.js ready Triggered when the server is listening Source: lib/tunnel/server.js unlocked Triggered when the server has an available tunnel Source: lib/tunnel/server.js killed Triggered when the upload queue has been killed Source: lib/bridge-client/upload-state.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/writable-stream.js finish Triggered when all data has been flushed and remote host receives it Source: lib/data-channels/writable-stream.js Ã— Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Tutorials Classes AuditStream Blacklist BridgeClient Contact ContactChecker Contract DataChannelClient DataChannelPointer DataChannelServer DataCipherKeyIv DecryptStream EmbeddedStorageAdapter EncryptStream FarmerInterface FileDemuxer FileMuxer KeyPair KeyRing Monitor Network Padder ProofStream Protocol RAMStorageAdapter RateLimiter ReadableDataChannelStream RenterInterface StorageAdapter StorageItem StorageManager StorageMigration Transport TriggerManager TunnelClient TunnelDemuxer TunnelerInterface TunnelGateway TunnelMuxer TunnelServer Unpadder UploadState Verification WritableDataChannelStream Events finish Triggered when the stream has ended Source: lib/audit-tools/audit-stream.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/client.js open Triggered when the connection is opened Source: lib/data-channels/client.js connection Triggered when a connection is opened Parameters: Name Type Description socket WebSocket The socket connection opened Source: lib/data-channels/server.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description item StorageItem The item associated with the download Source: lib/data-channels/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description item StorageItem The item associated with the upload Source: lib/data-channels/server.js data Triggered when some input bytes have become decrypted output bytes Type: Buffer Source: lib/crypto-tools/decrypt-stream.js end Triggered when the stream has ended Source: lib/crypto-tools/decrypt-stream.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js data Triggered when some input bytes have become encrypted output bytes Type: Buffer Source: lib/crypto-tools/encrypt-stream.js end Triggered when the stream has ended Source: lib/crypto-tools/encrypt-stream.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js finish Triggered when the demuxer has finished writing to all shards Source: lib/file-handling/file-demuxer.js shard Triggered when the demuxer has a shard ready to stream Parameters: Name Type Description shard ReadableStream The file shard as a readable stream Source: lib/file-handling/file-demuxer.js drain Triggered when the muxer has drained one of the supplied inputs Parameters: Name Type Description input ReadableStream The drained input stream Source: lib/file-handling/file-muxer.js update Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description stats Object Source: lib/network/monitor.js connected Triggered when the node has entered the overlay network Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Source: lib/network/index.js error Triggered when an error occurs Source: lib/network/index.js ready Triggered when the transport's network interface is ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Source: lib/network/index.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js data Triggered when a chunk of data has been received from the remote host Source: lib/data-channels/readable-stream.js end Triggered when all data has been received from the remote host Source: lib/data-channels/readable-stream.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/readable-stream.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js ready Triggered when the adapter is ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Source: lib/storage/adapter.js locked Triggered when the underlying storage adapter reaches capacity Source: lib/storage/manager.js unlocked Triggered when the underlying storage adapter has newly freed space Source: lib/storage/manager.js close Triggered when the tunnel is closed Source: lib/tunnel/client.js open Triggered when the tunnel is opened Source: lib/tunnel/client.js data Parameters: Name Type Description demuxedMessage Object Properties Name Type Description type String The message type (rpc, datachannel) data Buffer | String The message payload flags Object Properties Name Type Description binary Boolean WebSocket opcode binary flag quid String Quasi-unique associatation ID Source: lib/tunnel/demultiplexer.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js close Triggered when the gateway is closed Source: lib/tunnel/gateway.js message/datachannel Triggered when a message is received over a datachannel Parameters: Name Type Description data Buffer | String The data frame received flags Object WebSocket flags included Properties Name Type Description binary Boolean Frame was sent with 0x02 opcode quid String Quasi-unique ID assigned to this socket Source: lib/tunnel/gateway.js message/rpc Triggered when a message is received over RPC Parameters: Name Type Description message Object The parsed RPC message received Source: lib/tunnel/gateway.js open Triggered when the gateway is opened Source: lib/tunnel/gateway.js locked Triggered when the server has no more available tunnels Source: lib/tunnel/server.js ready Triggered when the server is listening Source: lib/tunnel/server.js unlocked Triggered when the server has an available tunnel Source: lib/tunnel/server.js killed Triggered when the upload queue has been killed Source: lib/bridge-client/upload-state.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/writable-stream.js finish Triggered when all data has been flushed and remote host receives it Source: lib/data-channels/writable-stream.js Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections This package exposes a module that provides all of the tools needed to integrate with the Storj network. You must have Node.js v4.x.x, Python v2.x.x, and Git installed. Complete documentation can be found here. npm install storj-lib --save If you want access to the Storj CLI, you must install it separately or use the storj metapackage to install both the core library and command line interface. Usage Examples Example 1 - Creating a User Example 2 - Generating a KeyPair Example 3 - Authenticating with a KeyPair Example 4 - Listing Keys Example 4b - Add/Remove Keys Example 5a - List Buckets Example 5b - Add/Remove Bucket Example 6a - Upload File Example 6b - Download File Example 6c - List Bucket Files Example 6d - Delete File from Bucket LicenseStorj Core - Implementation of the Storj protocol for Node.js Copyright (C) 2016 Storj Labs, Inc This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Certain parts of this program are licensed under the GNU Lesser General Public License as published by the Free Software Foundation. You can redistribute it and/or modify it under the terms either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program. If not, see http://www.gnu.org/licenses/. Ã— Search results Close "},"AuditStream.html":{"id":"AuditStream.html","title":"Class: AuditStream","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: AuditStream AuditStream new AuditStream(audits) Represents a streaming audit challenge generator Parameters: Name Type Description audits Number Total number of challenges to generate License: LGPL-3.0 Source: lib/audit-tools/audit-stream.js Fires: AuditStream#event:finish Methods &lt;static&gt; fromRecords(challenges, tree) Returns a new instance from the predefined challenges and tree Parameters: Name Type Description challenges Array The precomputed challenges tree Array The bottom leaves of the existing merkle tree Source: lib/audit-tools/audit-stream.js Returns: Type AuditStream getPrivateRecord() Returns the challenges, the tree depth, and merkle root Source: lib/audit-tools/audit-stream.js Returns: challenge - Private audit record with challenges Type Object getPublicRecord() Returns the bottom leaves of the merkle tree for sending to farmer Source: lib/audit-tools/audit-stream.js Returns: leaves - Bottom merkle leaves of audit tree Type Array Events finish Triggered when the stream has ended Source: lib/audit-tools/audit-stream.js Ã— Search results Close "},"Blacklist.html":{"id":"Blacklist.html","title":"Class: Blacklist","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Blacklist Blacklist new Blacklist(path) Manage a blacklist file containing an object with key value pairs of nodeids: timestamp Parameters: Name Type Description path String blacklist folder location License: LGPL-3.0 Source: lib/bridge-client/blacklist.js See: https://github.com/storj/bridge Methods push(nodeid) Push node to blacklist Parameters: Name Type Description nodeid String Node id to be added to blacklist Source: lib/bridge-client/blacklist.js toObject() Return list of blacklisted nodeids Source: lib/bridge-client/blacklist.js Ã— Search results Close "},"BridgeClient.html":{"id":"BridgeClient.html","title":"Class: BridgeClient","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: BridgeClient BridgeClient new BridgeClient( [uri], options) Represents a client interface to a given bridge server Parameters: Name Type Argument Default Description uri String &lt;optional&gt; https://api.storj.io API base URI options Object Properties Name Type Description keyPair KeyPair KeyPair instance for request signing logger Object Logger instance transferConcurrency Number Upload concurrency limit transferRetries Number Limit number of shard transfer retries before getting a new contract basicAuth Object Properties Name Type Description email String Email address for HTTP basic auth password String Password for HTTP basic auth License: LGPL-3.0 Source: lib/bridge-client/index.js See: https://github.com/storj/bridge https://storj.io/api.html Methods addPublicKey(pubkey, callback) Registers a public key for the caller Parameters: Name Type Description pubkey String Hex encoded ECDSA (secp256k1) public key callback function Source: lib/bridge-client/index.js addShardToFileStagingFrame(id, shard, options, callback) Adds the given shard metadata to the file staging frame Parameters: Name Type Description id String Unique frame ID shard Object The shard metadata options Object Properties Name Type Description retry Number Retry the request this many times if failed callback function Source: lib/bridge-client/index.js createBucket(data, callback) Creates a new file bucket Parameters: Name Type Description data Object Bucket parameters for creation callback function Source: lib/bridge-client/index.js createFileSliceStream(options) Create a stream for a given slice of a file Parameters: Name Type Description options Object Properties Name Type Description bucket String The bucket ID file String The file ID start Number The byte position to start slice end Number The byte position to end slice Source: lib/bridge-client/index.js createFileStagingFrame(callback) Creates a file staging frame Parameters: Name Type Description callback function Source: lib/bridge-client/index.js createFileStream(bucket, file [, options], callback) Create a readable stream from the given bucket and file id Parameters: Name Type Argument Description bucket String The unique bucket ID file String The unique file ID options Object &lt;optional&gt; Properties Name Type Argument Description exlude Array &lt;optional&gt; Exclude these nodeID's from pointers callback function Receives (err, stream) Source: lib/bridge-client/index.js createToken(id, operation, callback) Create bucket token Parameters: Name Type Description id String Unique bucket ID operation String PUSH or PULL (file operation) callback function Source: lib/bridge-client/index.js createUser(options, callback) Registers a user account Parameters: Name Type Description options Object Properties Name Type Description email String Email address for verification email password String Password to register (auto hashed) redirect String URL to redirect to after verification pubkey String Optional ECDSA public key to register callback function Source: lib/bridge-client/index.js destroyBucketById(id, callback) Removes the bucket Parameters: Name Type Description id String Unique bucket ID callback function Source: lib/bridge-client/index.js destroyFileStagingFrameById(id, callback) Destroy an existing file staging frame Parameters: Name Type Description id String Unique frame ID callback function Source: lib/bridge-client/index.js destroyPublicKey(pubkey, callback) Disassociates the public key from the caller Parameters: Name Type Description pubkey String Hex encoded ECDSA (secp256k1) public key callback function Source: lib/bridge-client/index.js destroyUser(options, callback) Deactivates a user account Parameters: Name Type Description options Object Properties Name Type Description email String Email address of user to deactivate redirect String URL to redirect after verification callback function Source: lib/bridge-client/index.js getBucketById(id, callback) Returns the bucket information by ID Parameters: Name Type Description id String Unique bucket ID callback function Source: lib/bridge-client/index.js getBuckets(callback) Lists the caller's file buckets Parameters: Name Type Description callback function Source: lib/bridge-client/index.js getContactByNodeId(nodeId, callback) Get the contact information for the given nodeID Parameters: Name Type Description nodeId String The nodeID of the contact callback function Source: lib/bridge-client/index.js getContactList(options, callback) Fetches the list of known contacts filtered according to the options Parameters: Name Type Description options Object Properties Name Type Description page Number The page number of the contact list to fetch connected Boolean Filter results by connection status callback function Source: lib/bridge-client/index.js getFilePointers(options, callback) Retrieves a series of file pointers from the bucket Parameters: Name Type Description options Object Properties Name Type Description bucket String Unique bucket ID token String Token from BridgeClient#createToken file String The unique file pointer ID skip Number The starting index of pointers to resolve limit Number The number of pointers to resolve callback function Source: lib/bridge-client/index.js getFileStagingFrameById(id, callback) Fetch an existing file staging frame by it's ID Parameters: Name Type Description id String Unique frame ID callback function Source: lib/bridge-client/index.js getFileStagingFrames(callback) List all of the file staging frames Parameters: Name Type Description callback function Source: lib/bridge-client/index.js getFrameFromFile(id, callback) Gets the frame by it's ID Parameters: Name Type Description id String Unique file ID callback function Source: lib/bridge-client/index.js getInfo(callback) Get the remote Storj Bridge API documentation and version as JSON Parameters: Name Type Description callback function Source: lib/bridge-client/index.js getPublicKeys(callback) Returns list of associated public keys Parameters: Name Type Description callback function Source: lib/bridge-client/index.js listFilesInBucket(id, callback) Lists the files stored in a bucket Parameters: Name Type Description id String Unique bucket ID callback function Source: lib/bridge-client/index.js removeFileFromBucket(id, file, callback) Removes a file from a bucket Parameters: Name Type Description id String Unique bucket ID file String ID of the file to remove from bucket callback function Source: lib/bridge-client/index.js replicateFileFromBucket(id, token, file, concurrency, callback) Instructs the bridge to find N mirroring farmers for redundancy Parameters: Name Type Description id String Unique bucket ID token String Token from BridgeClient#createToken file String Path to file to store concurrency Number Upload concurrency callback function Source: lib/bridge-client/index.js resetPassword(options, callback) Requests a password reset Parameters: Name Type Description options Object Properties Name Type Description email String Email address of user to reset password password String The cleartext password to reset to redirect String URL to redirect adter confirmation callback function Source: lib/bridge-client/index.js resolveFileFromPointers(pointers, callback) Open a series of data channels based on the returned value of BridgeClient#getFilePointers to resolve all the shards and reassemble them together as a binary stream Parameters: Name Type Description pointers Array Result of BridgeClient#getFilePointers callback function Source: lib/bridge-client/index.js storeFileInBucket(id, token, file, callback) Stores a file in the bucket Parameters: Name Type Description id String Unique bucket ID token String Token from BridgeClient#createToken file String Path to file to store callback function Source: lib/bridge-client/index.js updateBucketById(id, updates, callback) Updates the bucket Parameters: Name Type Description id String Unique bucket ID updates Object Bucket update parameters callback function Source: lib/bridge-client/index.js Ã— Search results Close "},"Contact.html":{"id":"Contact.html","title":"Class: Contact","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Contact Contact new Contact(contact) Represents a Storj contact (or peer) Parameters: Name Type Description contact Object Properties Name Type Argument Description address String Hostname of IP address port Number RPC port number nodeID String 160 bit node ID (hex) userAgent String &lt;optional&gt; User agent identifier protocol String Semver tag for compatibility License: LGPL-3.0 Source: lib/network/contact.js Ã— Search results Close "},"ContactChecker.html":{"id":"ContactChecker.html","title":"Class: ContactChecker","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: ContactChecker ContactChecker new ContactChecker(options) Handles checking if a contact is reachable Parameters: Name Type Description options Object Properties Name Type Argument Default Description timeout Number &lt;optional&gt; 2000 Milliseconds to wait for timeout License: AGPL-3.0 Source: lib/network/contact-checker.js Extends EventEmitter Methods check(contact, callback) Opens a connection to the contact to ensure it's reachable Parameters: Name Type Description contact Contact The contact to check callback ContactChecker~checkCallback Source: lib/network/contact-checker.js Type Definitions checkCallback( [error]) Parameters: Name Type Argument Description error Error &lt;optional&gt; Source: lib/network/contact-checker.js Ã— Search results Close "},"Contract.html":{"id":"Contract.html","title":"Class: Contract","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Contract Contract new Contract(contract, criteria) Represents a storage contract between a renter and a farmer Parameters: Name Type Description contract Object Properties Name Type Description type String Unique identifier for the contract renter_id String Node ID of the renter renter_signature String Renter's cryptographic signature farmer_id String Node ID of the farmer farmer_signature String Farmer's cryptographic signature data_size Number Number of bytes to store data_hash String RIPEMD-160 SHA-256 hash of the data store_begin Number UNIX timestamp to start contract store_end Number UNIX timestamp to end the contract audit_count Number Number of audits renter will perform payment_storage_price Number Total price for storage payment_download_price Number Price per download payment_destination String Bitcoin address to send funds criteria Object Properties Name Type Description size Number Criteria degree OPCODE duration Number Criteria degree OPCODE availability Number Criteria degree OPCODE speed Number Criteria degree OPCODE Version: 0 License: AGPL-3.0 Source: lib/contract/index.js Members &lt;static&gt; CRITERIA Defines some default criteria of a Contract Source: lib/contract/index.js &lt;static&gt; DEFAULTS Defines some default properties of a Contract Source: lib/contract/index.js &lt;static&gt; MATRIX Defines the criteria matrix for a Contract Source: lib/contract/index.js &lt;static&gt; Schema Defines the JSON Schema of a Contract Source: lib/contract/index.js Methods &lt;static&gt; compare(c1, c2) Compares two contracts against each other Parameters: Name Type Description c1 Contract Contract to compare c2 Contract Contract to compare Source: lib/contract/index.js Returns: Type Boolean &lt;static&gt; createTopic(criteria) Create a topical OPCODE byte sequence from the provided criteria Parameters: Name Type Description criteria Object Properties Name Type Description size Number Criteria degree OPCODE duration Number Criteria degree OPCODE availability Number Criteria degree OPCODE speed Number Criteria degree OPCODE Source: lib/contract/index.js Returns: Type Buffer &lt;static&gt; createValidator() Creates a validator function for data against the schema Source: lib/contract/index.js Returns: validator Type function &lt;static&gt; fromBuffer(buffer) Creates a contract from a Buffer Parameters: Name Type Description buffer Buffer Raw binary blob of contract data Source: lib/contract/index.js Returns: Type Contract &lt;static&gt; fromJSON(json) Creates a contract from a JSON string Parameters: Name Type Description json String JSON encoded contract Source: lib/contract/index.js Returns: Type Contract &lt;static&gt; fromObject(object) Creates a contract from a plain object Parameters: Name Type Description object Object Dictionary of contract data Source: lib/contract/index.js Returns: Type Contract get(field_name) Returns the value for the given contract property Parameters: Name Type Description field_name String Contract property to get Source: lib/contract/index.js Returns: value Type String | Number | null getHash() Calculates the SHA-256 hash of the serialized contract Source: lib/contract/index.js Returns: Type Buffer getTopicBuffer() Return OPCODE byte sequence for contract publication topic Source: lib/contract/index.js Returns: Type Buffer getTopicString() Return OPCODE byte sequence for contract publication topic as hex string Source: lib/contract/index.js Returns: Type String isComplete() Checks if the contract is complete Source: lib/contract/index.js Returns: completed Type Boolean set(field_name) Sets the contract property to the given value Parameters: Name Type Description field_name String Contract property to get Source: lib/contract/index.js Returns: value Type String | Number | null sign(actor, secret) Signs the contract as the given actor Parameters: Name Type Description actor String One of 'farmer' or 'renter' secret Buffer ECDSA private key Source: lib/contract/index.js Returns: signature Type String toBuffer() Converts the contract to Buffer Source: lib/contract/index.js Returns: Type Buffer toJSON() Converts the contract to JSON string Source: lib/contract/index.js Returns: Type String toObject() Converts the contract to a plain object Source: lib/contract/index.js Returns: Type Object update(fields) Applies the provided fields to the contract and validates it Parameters: Name Type Description fields Object Contract properties to update Source: lib/contract/index.js Returns: self Type Contract verify(actor, pubkeyhash) Verify the contract signature for the given actor Parameters: Name Type Description actor String One of 'farmer' or 'renter' pubkeyhash Buffer ECDSA nodeID Source: lib/contract/index.js Returns: validity Type Boolean Ã— Search results Close "},"DataChannelClient.html":{"id":"DataChannelClient.html","title":"Class: DataChannelClient","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: DataChannelClient DataChannelClient new DataChannelClient(contact) Creates a data channel client for sending and receiving consigned file shards Parameters: Name Type Description contact Object Properties Name Type Description address String The address of the target farmer port Number The port of the target farmer License: LGPL-3.0 Source: lib/data-channels/client.js Methods &lt;static&gt; getChannelURL(contact) Returns the URI of the contact's data channel Parameters: Name Type Description contact Object Source: lib/data-channels/client.js &lt;static&gt; getStreamFromPointer(pointer, callback) Creates a Readable or Writable stream from a DataChannelPointer Parameters: Name Type Description pointer DataChannelPointer The pointer to create stream callback DataChannelClient~getStreamFromPointerCallback Source: lib/data-channels/client.js createReadStream(token, hash) Creates a readable stream from the remote farmer for retrieval of a shard Parameters: Name Type Description token String The RETRIEVE token supplied by the farmer hash String The hash of the data to retrieve Source: lib/data-channels/client.js Returns: Type stream.Readable createWriteStream(token, hash) Creates a writable stream from the remote farmer for consignment of a shard Parameters: Name Type Description token String The CONSIGN token supplied by the farmer hash String The hash of the data to consign Source: lib/data-channels/client.js Returns: Type WritableDataChannelStream Type Definitions getStreamFromPointerCallback(err, stream) This callback is called when the client is open and stream is created Parameters: Name Type Description err Error | null If opening client failed, an error object stream stream.Writable | stream.Readable The data channel stream Source: lib/data-channels/client.js Events error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/client.js open Triggered when the connection is opened Source: lib/data-channels/client.js Ã— Search results Close "},"DataChannelPointer.html":{"id":"DataChannelPointer.html","title":"Class: DataChannelPointer","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: DataChannelPointer DataChannelPointer new DataChannelPointer(contact, hash, token [, operation]) Represents a pointer for opening a DataChannelClient stream Parameters: Name Type Argument Default Description contact Contact The farmer the pointer is for hash String The hash of the data to consign or retrieve token String The authorization token fot the operation operation String &lt;optional&gt; PULL The type of operation (PUSH or PULL) License: LGPL-3.0 Source: lib/data-channels/pointer.js Ã— Search results Close "},"DataChannelServer.html":{"id":"DataChannelServer.html","title":"Class: DataChannelServer","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: DataChannelServer DataChannelServer new DataChannelServer(options) Creates a data channel server for sending and receiving consigned file shards Parameters: Name Type Description options Object Properties Name Type Argument Default Description server http.Server A http(s).Server instance storageManager StorageManager Storage manager backend logger kad.Logger Logger to use from Network tokenTtl Number &lt;optional&gt; 86400000 Close after idle License: AGPL-3.0 Source: lib/data-channels/server.js Methods accept(token, filehash) Begin accepting data for the given file hash and token Parameters: Name Type Description token String The authorization token created for transfer filehash String The shard hash to allow for the token Source: lib/data-channels/server.js close() Closes the data channel and disconnects all clients Source: lib/data-channels/server.js reject(token) Stop accepting data for the given token Parameters: Name Type Description token String The authorization token created for transfer Source: lib/data-channels/server.js Events connection Triggered when a connection is opened Parameters: Name Type Description socket WebSocket The socket connection opened Source: lib/data-channels/server.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description item StorageItem The item associated with the download Source: lib/data-channels/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description item StorageItem The item associated with the upload Source: lib/data-channels/server.js Ã— Search results Close "},"DataCipherKeyIv.html":{"id":"DataCipherKeyIv.html","title":"Class: DataCipherKeyIv","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: DataCipherKeyIv DataCipherKeyIv new DataCipherKeyIv( [password] [, salt]) Create a new random cipher key and initialization vector Parameters: Name Type Argument Description password String | Buffer &lt;optional&gt; The unique cipher password salt String | Buffer &lt;optional&gt; The unique salt License: LGPL-3.0 Source: lib/crypto-tools/cipher-key-iv.js Methods &lt;static&gt; fromObject(object) Returns the a DataCipherKeyIv from an object Parameters: Name Type Description object Object Properties Name Type Description pass Buffer | String The unique password salt Buffer | String The unique salt Source: lib/crypto-tools/cipher-key-iv.js Returns: Type DataCipherKeyIv getCipherKeyIv() Returns the cipher key and iv in an array Source: lib/crypto-tools/cipher-key-iv.js Returns: Type Array toObject() Returns the key and iv as an array Source: lib/crypto-tools/cipher-key-iv.js Returns: Type Array Ã— Search results Close "},"DecryptStream.html":{"id":"DecryptStream.html","title":"Class: DecryptStream","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: DecryptStream DecryptStream new DecryptStream(keyiv) Represents a duplex stream capable of taking encrypted data as input and producing output decrypted by a DataCipherKeyIv Parameters: Name Type Description keyiv DataCipherKeyIv Object to use for derivation function License: LGPL-3.0 Source: lib/crypto-tools/decrypt-stream.js Fires: DecryptStream#event:data DecryptStream#event:end Events data Triggered when some input bytes have become decrypted output bytes Type: Buffer Source: lib/crypto-tools/decrypt-stream.js end Triggered when the stream has ended Source: lib/crypto-tools/decrypt-stream.js Ã— Search results Close "},"EmbeddedStorageAdapter.html":{"id":"EmbeddedStorageAdapter.html","title":"Class: EmbeddedStorageAdapter","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: EmbeddedStorageAdapter EmbeddedStorageAdapter new EmbeddedStorageAdapter(storageDirPath) Implements an LevelDB/KFS storage adapter interface Parameters: Name Type Description storageDirPath String Path to store the level db License: AGPL-3.0 Source: lib/storage/adapters/embedded.js Extends StorageAdapter Methods createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Inherited From: StorageAdapter#createReadStream Source: lib/storage/adapter.js Returns: Type ReadableStream del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Inherited From: StorageAdapter#del Source: lib/storage/adapter.js get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#get Source: lib/storage/adapter.js peek(key, callback) Calls the implemented StorageAdapter#_peek and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#peek Source: lib/storage/adapter.js put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Inherited From: StorageAdapter#put Source: lib/storage/adapter.js size(callback) Calls the implemented StorageAdapter#_size Parameters: Name Type Description callback function Called with error or number of bytes stored Inherited From: StorageAdapter#size Source: lib/storage/adapter.js Events add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js Ã— Search results Close "},"EncryptStream.html":{"id":"EncryptStream.html","title":"Class: EncryptStream","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: EncryptStream EncryptStream new EncryptStream(keyiv) Represents a duplex stream capable of taking cleartext data as input and producing output encrypted with DataCipherKeyIv Parameters: Name Type Description keyiv DataCipherKeyIv Object to use for derivation function License: LGPL-3.0 Source: lib/crypto-tools/encrypt-stream.js Fires: EncryptStream#event:data EncryptStream#event:end Events data Triggered when some input bytes have become encrypted output bytes Type: Buffer Source: lib/crypto-tools/encrypt-stream.js end Triggered when the stream has ended Source: lib/crypto-tools/encrypt-stream.js Ã— Search results Close "},"FarmerInterface.html":{"id":"FarmerInterface.html","title":"Class: FarmerInterface","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: FarmerInterface FarmerInterface new FarmerInterface(options) Creates and a new farmer interface Parameters: Name Type Description options Object Properties Name Type Argument Description paymentAddress String Optional payment address opcodeSubscriptions Array Contract opcodes to farm maxOfferConcurrency Number Max offers to have pending contractNegotiator FarmerInterface~negotiator keyPair KeyPair Node's cryptographic identity storageManager StorageManager Storage manager backend bridgeUri String URL for bridge server seed lookup logger Object Logger instance seedList Array List of seed URIs to join rpcAddress String Public node IP or hostname rpcPort Number Listening port for RPC doNotTraverseNat Boolean Skip NAT traversal strategies maxTunnels Number Max number of tunnels to provide tunnelServerPort Number Port for tunnel server to use tunnelGatewayRange Object Properties Name Type Description min Number Min port for gateway binding max Number Max port for gateway binding rateLimiterOpts Object &lt;optional&gt; Options for RateLimiter renterWhitelist Array.&lt;String&gt; &lt;optional&gt; Node IDs to offer storage to Properties: Name Type Description keyPair KeyPair storageManager StorageManager node kad.Node The underlying DHT node triggerManager TriggerManager bridgeClient BridgeClient contact Contact transportAdapter Transport router kad.Router The underlying DHT router dataChannelServer DataChannelServer License: AGPL-3.0 Source: lib/network/interfaces/farmer.js Fires: Network#event:ready Extends Network Methods connect(uri, callback) Connects to the node at the given URI Parameters: Name Type Description uri String The storj protocol URI to connect callback function Called on connection or error Inherited From: Network#connect Source: lib/network/index.js getPaymentAddress() Returns the payment address supplied or the derived one from keypair Source: lib/network/interfaces/farmer.js Returns: Type String join(callback) Wraps the super call to Network#join to listen for contract after successfully establishing a connection to the network Parameters: Name Type Description callback function Called on successful join Overrides: Network#join Source: lib/network/interfaces/farmer.js leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Inherited From: Network#leave Source: lib/network/index.js publish(topic, contents, options) Publishes a topic with content to the network Parameters: Name Type Description topic String The serialized opcode topic contents Object Arbitrary publication contents options Object Options to pass to kad-quasar Inherited From: Network#publish Source: lib/network/index.js subscribe(topic, handler) Subscribes to a topic on the network Parameters: Name Type Description topic String The serialized opcode topic handler Object Function to handle received publications Inherited From: Network#subscribe Source: lib/network/index.js Type Definitions negotiator(contract) Called when a contract is found that meets subscription criteria and allows us to modify the contract terms if we desire and then uses the return value to determine if we should send the renter an offer Parameters: Name Type Description contract Contract The contract object to negotiate Source: lib/network/interfaces/farmer.js Returns: Type Boolean Events connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js Ã— Search results Close "},"FileDemuxer.html":{"id":"FileDemuxer.html","title":"Class: FileDemuxer","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: FileDemuxer FileDemuxer new FileDemuxer(filePath, options) Takes a single file read stream and outputs several output streams, used for &quot;shredding&quot; a file and creating muliple out destination interfaces Parameters: Name Type Description filePath String Path the file to demultiplex options Object Properties Name Type Description shardSize Number Size of each shard License: LGPL-3.0 Source: lib/file-handling/file-demuxer.js Fires: FileDemuxer#event:shard Methods &lt;static&gt; getOptimalShardSize(fileInfo [, acc]) Determine the optimal shard size given an arbitrary file size in bytes Parameters: Name Type Argument Default Description fileInfo Object Properties Name Type Description fileSize Number The number of bytes in the given file shardConcurrency Number Num of shards uploaded at once acc Number &lt;optional&gt; 1 Accumulator (number of recursions) Source: lib/file-handling/file-demuxer.js Returns: shardSize Type Number Events finish Triggered when the demuxer has finished writing to all shards Source: lib/file-handling/file-demuxer.js shard Triggered when the demuxer has a shard ready to stream Parameters: Name Type Description shard ReadableStream The file shard as a readable stream Source: lib/file-handling/file-demuxer.js Ã— Search results Close "},"FileMuxer.html":{"id":"FileMuxer.html","title":"Class: FileMuxer","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: FileMuxer FileMuxer new FileMuxer(options) Accepts multiple ordered input sources and exposes them as a single contiguous readable stream. Used for re-assembly of shards. Parameters: Name Type Description options Object Properties Name Type Description shards Number Number of total shards to be multiplexed length Number Number of total bytes of input sourceDrainWait Number Time to wait for a new input after all inputs are drained before entire stream is consumed sourceIdleWait Number Time to wait for source to make more data available between next read License: LGPL-3.0 Source: lib/file-handling/file-muxer.js Fires: FileMuxer#event:drain Methods addInputSource(readable) Adds an additional input stream to the multiplexer Parameters: Name Type Description readable ReadableStream Readable input stream from file shard Source: lib/file-handling/file-muxer.js Events drain Triggered when the muxer has drained one of the supplied inputs Parameters: Name Type Description input ReadableStream The drained input stream Source: lib/file-handling/file-muxer.js Ã— Search results Close "},"KeyPair.html":{"id":"KeyPair.html","title":"Class: KeyPair","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: KeyPair KeyPair new KeyPair(privateKey) Represents a ECDSA key pair Parameters: Name Type Description privateKey String | Buffer | undefined WIF encoded ECDSA private key License: LGPL-3.0 Source: lib/crypto-tools/keypair.js Methods getAddress() Returns the bitcoin address version of the nodeID Source: lib/crypto-tools/keypair.js Returns: address - Base58 encoded address Type String getNodeID() Returns the NodeID derived from the public key Source: lib/crypto-tools/keypair.js Returns: nodeID - RIPEMD160 hash of public key Type String getPrivateKey() Returns the private key Source: lib/crypto-tools/keypair.js Returns: key Type String getPublicKey() Returns the public key Source: lib/crypto-tools/keypair.js Returns: key Type String sign(message, options) Signs the supplied message with the private key Parameters: Name Type Description message String | Buffer The message to sign options Object Properties Name Type Argument Default Description compact Boolean &lt;optional&gt; true Compact signature format Source: lib/crypto-tools/keypair.js Returns: signature Type String Ã— Search results Close "},"KeyRing.html":{"id":"KeyRing.html","title":"Class: KeyRing","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: KeyRing KeyRing new KeyRing(keyRingDir [, passPhrase]) A DataCipherKeyIv factory with file system persistence Parameters: Name Type Argument Default Description keyRingDir String Path to store keyring directory passPhrase String &lt;optional&gt; '' Passphrase to encrypt/decrypt keyring License: LGPL-3.0 Source: lib/crypto-tools/keyring.js Methods del(keyId) Delete the keyring file from disk Parameters: Name Type Description keyId String Arbitrary key ID to delete Source: lib/crypto-tools/keyring.js export(outPath, callback) Export Keyring to compressed tarball Parameters: Name Type Description outPath String Path to keyring to be compressed callback function Called when tarball has been written Source: lib/crypto-tools/keyring.js generate(keyId) Returns the stored KeyPair for the given id Parameters: Name Type Description keyId String Generate a key for use with the given ID Source: lib/crypto-tools/keyring.js Returns: Type KeyPair get(keyId) Returns the stored KeyPair for the given id Parameters: Name Type Description keyId String Arbitrary key ID to load Source: lib/crypto-tools/keyring.js Returns: Type DataCipherKeyIv | null import(inPath, passPhrase [, overwriteConflictingIds], callback) Import to Keyring from compressed tarball Parameters: Name Type Argument Default Description inPath String Path to tarball to be imported passPhrase String Passphrase used to decrypt the imported tar overwriteConflictingIds Boolean &lt;optional&gt; false Overwrite conflicting key callback function Called on import finish Source: lib/crypto-tools/keyring.js reset(passPhrase, callback) Resets the keyring password Parameters: Name Type Description passPhrase String New passphrase for keyring callback function Called on keyring password reset Source: lib/crypto-tools/keyring.js set(keyId, dataCipherKey) Returns the stored KeyPair for the given id Parameters: Name Type Description keyId String Arbitrary key ID to load dataCipherKey DataCipherKeyIv Cipher key object to set Source: lib/crypto-tools/keyring.js Ã— Search results Close "},"module-storj.html":{"id":"module-storj.html","title":"Module: storj","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj License: (AGPL-3.0 AND LGPL-3.0) Source: index.js Members &lt;static&gt; AuditStream AuditStream Source: index.js &lt;static&gt; BridgeClient BridgeClient Source: index.js &lt;static&gt; constants module:storj/constants Source: index.js &lt;static&gt; Contact Contact Source: index.js &lt;static&gt; ContactChecker ContactChecker Source: index.js &lt;static&gt; Contract Contract Source: index.js &lt;static&gt; DataChannelClient DataChannelClient Source: index.js &lt;static&gt; DataChannelErrors module:storj/datachannel/errors Source: index.js &lt;static&gt; DataChannelPointer DataChannelPointer Source: index.js &lt;static&gt; DataChannelServer DataChannelServer Source: index.js &lt;static&gt; DataCipherKeyIv DataCipherKeyIv Source: index.js &lt;static&gt; DecryptStream DecryptStream Source: index.js &lt;static&gt; deps module:storj/deps Source: index.js &lt;static&gt; EmbeddedStorageAdapter EmbeddedStorageAdapter Source: index.js &lt;static&gt; EncryptStream EncryptStream Source: index.js &lt;static&gt; FarmerInterface FarmerInterface Source: index.js &lt;static&gt; FileDemuxer FileDemuxer Source: index.js &lt;static&gt; FileMuxer FileMuxer Source: index.js &lt;static&gt; KeyPair KeyPair Source: index.js &lt;static&gt; KeyRing KeyRing Source: index.js &lt;static&gt; Monitor Monitor Source: index.js &lt;static&gt; Network Network Source: index.js &lt;static&gt; Padder Padder Source: index.js &lt;static&gt; ProofStream ProofStream Source: index.js &lt;static&gt; Protocol Protocol Source: index.js &lt;static&gt; RAMStorageAdapter RAMStorageAdapter Source: index.js &lt;static&gt; RateLimiter RateLimiter Source: index.js &lt;static&gt; RenterInterface RenterInterface Source: index.js &lt;static&gt; sips module:storj/sips Source: index.js &lt;static&gt; StorageAdapter StorageAdapter Source: index.js &lt;static&gt; StorageItem StorageItem Source: index.js &lt;static&gt; StorageManager StorageManager Source: index.js &lt;static&gt; StorageMigration StorageMigration Source: index.js &lt;static&gt; Transport Transport Source: index.js &lt;static&gt; TunnelClient TunnelClient Source: index.js &lt;static&gt; TunnelDemuxer TunnelDemuxer Source: index.js &lt;static&gt; TunnelerInterface TunnelerInterface Source: index.js &lt;static&gt; TunnelErrors module:storj/tunnel/errors Source: index.js &lt;static&gt; TunnelMuxer TunnelMuxer Source: index.js &lt;static&gt; TunnelServer TunnelServer Source: index.js &lt;static&gt; Unpadder Unpadder Source: index.js &lt;static&gt; utils module:storj/utils Source: index.js &lt;static&gt; Verification Verification Source: index.js &lt;static&gt; version module:storj/version Source: index.js Ã— Search results Close "},"module-storj_constants.html":{"id":"module-storj_constants.html","title":"Module: storj/constants","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/constants License: LGPL-3.0 Source: lib/constants.js Members &lt;inner, constant&gt; AUDIT_BYTES :Number Number of bytes for audit challenge Type: Number Source: lib/constants.js &lt;inner, constant&gt; CIPHER_ALG :String Cipher/Decipher algorithm Type: String Source: lib/constants.js &lt;inner, constant&gt; CLEAN_INTERVAL :Number Interval for reaping stale shards Type: Number Source: lib/constants.js &lt;inner, constant&gt; CONSIGN_THRESHOLD :Number Threshold for consign time Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_CONCURRENT_AUDITS :Number Number of concurrent audits Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_CONCURRENT_OFFERS :Number Number of concurrent offers Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_FIND_TUNNEL_RELAYS Source: lib/constants.js &lt;inner, constant&gt; NET_REENTRY :Number Max wait time before re-entering net Type: Number Source: lib/constants.js &lt;inner, constant&gt; NONCE_EXPIRE :Number Time to honor a signed message Type: Number Source: lib/constants.js &lt;inner, constant&gt; OFFER_TIMEOUT :Number Max wait time for storage offer Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_CONTRACT_PREFIX :Number Prefix opcode for contracts Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_HIGH :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_LOW :Number Opcode for low criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_MED :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_NULL :Number Opcode for null criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_TUNDCX_PREFIX :Number Opcode for tunnel datachannel Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_TUNNELER_PREFIX :Number Prefix opcode for tunneler Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_TUNRPC_PREFIX :Number Opcode for tunnel rpc message Type: Number Source: lib/constants.js &lt;inner, constant&gt; PREFIX :Number NodeID prefix (same as bitcoin) Type: Number Source: lib/constants.js &lt;inner, constant&gt; ROUTER_CLEAN_INTERVAL :Number Drop bad contacts Type: Number Source: lib/constants.js &lt;inner, constant&gt; RPC_TIMEOUT :Number Max wait time for a RPC response Type: Number Source: lib/constants.js &lt;inner, constant&gt; TOKEN_EXPIRE :Number Reject datachannl token after time Type: Number Source: lib/constants.js &lt;inner, constant&gt; TUNNEL_ANNOUNCE_INTERVAL :Number Announce tunnel state Type: Number Source: lib/constants.js Ã— Search results Close "},"module-storj_datachannel_errors.html":{"id":"module-storj_datachannel_errors.html","title":"Module: storj/datachannel/errors","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/datachannel/errors License: AGPL-3.0 Source: lib/data-channels/error-codes.js Members &lt;static&gt; FAILED_INTEGRITY Source: lib/data-channels/error-codes.js &lt;static&gt; INVALID_MESSAGE Source: lib/data-channels/error-codes.js &lt;static&gt; INVALID_OPERATION Source: lib/data-channels/error-codes.js &lt;static&gt; UNAUTHORIZED_TOKEN Source: lib/data-channels/error-codes.js &lt;static&gt; UNEXPECTED Source: lib/data-channels/error-codes.js Ã— Search results Close "},"module-storj_deps.html":{"id":"module-storj_deps.html","title":"Module: storj/deps","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/deps Source: lib/deps.js Members &lt;static&gt; bitcore A modular node for Bitcoin and blockchain-based apps Source: lib/deps.js See: https://bitcore.io/ &lt;static&gt; kad Implementation of the Kademlia distributed hash table Source: lib/deps.js See: http://kadtools.github.io/ &lt;static&gt; kfs Kademlia inspired local file store based on LevelDB Source: lib/deps.js See: http://bookch.in/kfs Ã— Search results Close "},"module-storj_patches.html":{"id":"module-storj_patches.html","title":"Module: storj/patches","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/patches License: AGPL-3.0 Source: lib/patches.js Ã— Search results Close "},"module-storj_sips.html":{"id":"module-storj_sips.html","title":"Module: storj/sips","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/sips License: AGPL-3.0 Source: lib/sips/index.js Members &lt;static&gt; SIP0003 module:storj/sips/0003 Source: lib/sips/index.js Ã— Search results Close "},"module-storj_sips_0003.html":{"id":"module-storj_sips_0003.html","title":"Module: storj/sips/0003","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/sips/0003 Source: lib/sips/0003/index.js Members &lt;static&gt; TriggerManager TriggerManager Source: lib/sips/0003/index.js Ã— Search results Close "},"module-storj_tunnel_errors.html":{"id":"module-storj_tunnel_errors.html","title":"Module: storj/tunnel/errors","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/tunnel/errors License: AGPL-3.0 Source: lib/tunnel/error-codes.js Members &lt;static&gt; GATEWAY_CLOSED Source: lib/tunnel/error-codes.js &lt;static&gt; INVALID_FRAME_TYPE Source: lib/tunnel/error-codes.js &lt;static&gt; UNEXPECTED Source: lib/tunnel/error-codes.js Ã— Search results Close "},"module-storj_utils.html":{"id":"module-storj_utils.html","title":"Module: storj/utils","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/utils License: LGPL-3.0 Source: lib/utils.js Methods &lt;static&gt; createEciesCipher(privateKey, publicKey) Creates an ECIES ciper object from a private and a public key Parameters: Name Type Description privateKey String The private key of the sender publicKey String The public key of the recipient Source: lib/utils.js Returns: Type Object &lt;static&gt; createStreamTrimmer(trimFront, totalBytes) Returns a through stream that trims the output based on the given range Parameters: Name Type Description trimFront Number Number of bytes to trim off front of stream totalBytes Number The total length of the stream in bytes Source: lib/utils.js &lt;static&gt; ensureNtpClockIsSynchronized(callback) Determines if the system clock is syncronized with network Parameters: Name Type Description callback function Called with (err, delta) Source: lib/utils.js &lt;static&gt; existsSync(file) Check if file exists Parameters: Name Type Description file String Path to file Source: lib/utils.js Returns: Type Boolean &lt;static&gt; generateToken() Generates a unique token Source: lib/utils.js Returns: Type String &lt;static&gt; getContactURL(contact) Returns a stringified URL from the supplied contact object Parameters: Name Type Description contact Object Properties Name Type Description address String port Number nodeID String Source: lib/utils.js Returns: Type String &lt;static&gt; getNextPowerOfTwo(number) Returns the next power of two number Parameters: Name Type Description number Number Source: lib/utils.js Returns: Type Number &lt;static&gt; getNtpTimeDelta(callback) Returns the delta between system time and NTP time Parameters: Name Type Description callback function Called with (err, delta) Source: lib/utils.js &lt;static&gt; isCompatibleVersion(version) Returns whether or not the supplied semver tag is compatible Parameters: Name Type Description version String The semver tag from the contact Source: lib/utils.js Returns: compatible Type Boolean &lt;static&gt; isDirectory(dirPath) Check if a path is a directory Parameters: Name Type Description dirPath String Path to a directory Source: lib/utils.js Returns: Type Boolean &lt;static&gt; isValidContact(contact, loopback) Determines if the supplied contact is valid Parameters: Name Type Description contact Contact The contact information for a given peer loopback Boolean Allows contacts that are localhost Source: lib/utils.js Returns: Type Boolean &lt;static&gt; rmd160(input, encoding) Returns the RIPEMD-160 hash of the input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String &lt;static&gt; rmd160sha256(input, encoding) Returns the RIPEMD-160 SHA-256 hash of this input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String &lt;static&gt; sha1(input, encoding) Returns the SHA-1 hash of the input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String &lt;static&gt; sha1whirlpool(input, encoding) Returns the SHA-1 WHIRLPOOL hash of this input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String &lt;static&gt; sha256(input, encoding) Returns the SHA-256 hash of the input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String &lt;static&gt; simpleDecrypt(password, data) Decrypts the given data with the supplied password and base58 decodes it Parameters: Name Type Description password String The passphrase to use for decryption data String The string to decrypt Source: lib/utils.js Returns: Type String &lt;static&gt; simpleEncrypt(password, data) Encrypts the given data with the supplied password and base58 encodes it Parameters: Name Type Description password String The passphrase to use for encryption data String The string to encrypt Source: lib/utils.js Returns: Type String &lt;static&gt; tmpdir() Check for env STORJ_TEMP todetermine temp directory Source: lib/utils.js &lt;static&gt; toNumberBytes(size, unit) Returns number of bytes from human readable size and unit strings Parameters: Name Type Description size String | Number The size measurement unit String The unit of measure (MB|GB|TB) Source: lib/utils.js Returns: Type Number &lt;static&gt; whirlpool(input, encoding) Returns the WHIRLPOOL hash of the input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String Ã— Search results Close "},"module-storj_version.html":{"id":"module-storj_version.html","title":"Module: storj/version","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/version Source: lib/version.js Members &lt;inner, constant&gt; protocol :String The supported protocol version Type: String Source: lib/version.js &lt;inner, constant&gt; software :String The current software version Type: String Source: lib/version.js Ã— Search results Close "},"Monitor.html":{"id":"Monitor.html","title":"Class: Monitor","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Monitor Monitor new Monitor(network, options) Wraps a Network instance and provides events for gathering statistics about node operation Parameters: Name Type Description network Network The network interface to monitor options Object License: AGPL-3.0 Source: lib/network/monitor.js Methods &lt;static&gt; getConnectedPeers(source, callback) Gets the list of currently known Contacts Parameters: Name Type Description source Network The network instance to use callback function Source: lib/network/monitor.js &lt;static&gt; getContractsDetails(source, callback) Gets the total contracts stored Parameters: Name Type Description source Network The network instance to use callback function Source: lib/network/monitor.js &lt;static&gt; getDiskUtilization(source, callback) Gets the amount of used space compared to amount shared Parameters: Name Type Description source Network The network instance to use callback function Source: lib/network/monitor.js &lt;static&gt; getPaymentAddressBalances(source, callback) Gets the balance of SJCX/SJCT from a FarmerInterface Parameters: Name Type Description source Network The network instance to use callback function Source: lib/network/monitor.js getSnapshot() Returns the current snapshot Source: lib/network/monitor.js Returns: snapshot Type Object start() Starts the network monitor Source: lib/network/monitor.js Returns: Type Monitor stop() Stops the network monitor Source: lib/network/monitor.js Returns: Type Monitor Events update Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description stats Object Source: lib/network/monitor.js Ã— Search results Close "},"Network.html":{"id":"Network.html","title":"Class: Network","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Network Network new Network(options) Storj network interface Parameters: Name Type Description options Object Properties Name Type Description keyPair KeyPair Node's cryptographic identity storageManager StorageManager Storage manager backend bridgeUri String URL for bridge server seed lookup logger Object Logger instance seedList Array List of seed URIs to join rpcAddress String Public node IP or hostname rpcPort Number Listening port for RPC doNotTraverseNat Boolean Skip NAT traversal strategies maxTunnels Number Max number of tunnels to provide tunnelServerPort Number Port for tunnel server to use tunnelGatewayRange Object Properties Name Type Description min Number Min port for gateway bind max Number Max port for gateway bind rateLimiterOpts Object Options for RateLimiter Properties: Name Type Description keyPair KeyPair storageManager StorageManager node kad.Node The underlying DHT node triggerManager TriggerManager bridgeClient BridgeClient contact Contact transportAdapter Transport router kad.Router The underlying DHT router dataChannelServer DataChannelServer License: AGPL-3.0 Source: lib/network/index.js Fires: Network#event:ready Methods connect(uri, callback) Connects to the node at the given URI Parameters: Name Type Description uri String The storj protocol URI to connect callback function Called on connection or error Source: lib/network/index.js join(callback) Opens the connection to the network Parameters: Name Type Description callback function Called on successful network join Source: lib/network/index.js leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Source: lib/network/index.js publish(topic, contents, options) Publishes a topic with content to the network Parameters: Name Type Description topic String The serialized opcode topic contents Object Arbitrary publication contents options Object Options to pass to kad-quasar Source: lib/network/index.js subscribe(topic, handler) Subscribes to a topic on the network Parameters: Name Type Description topic String The serialized opcode topic handler Object Function to handle received publications Source: lib/network/index.js Events connected Triggered when the node has entered the overlay network Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Source: lib/network/index.js error Triggered when an error occurs Source: lib/network/index.js ready Triggered when the transport's network interface is ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Source: lib/network/index.js Ã— Search results Close "},"Padder.html":{"id":"Padder.html","title":"Class: Padder","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Padder Padder new Padder() Takes an input stream and pads the tail with zeroes to the next byte mulitple License: LGPL-3.0 Source: lib/file-handling/padder.js Ã— Search results Close "},"ProofStream.html":{"id":"ProofStream.html","title":"Class: ProofStream","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: ProofStream ProofStream new ProofStream(merkleLeaves, hexChallenge) Provides interface for proving possession of a file for an AuditStream Parameters: Name Type Description merkleLeaves Array Bottom leaves of the audit merkle tree hexChallenge String The challenge data in hex to prepend to shard License: LGPL-3.0 Source: lib/audit-tools/proof-stream.js Methods getProofResult() Returns the generated proof structure Source: lib/audit-tools/proof-stream.js Returns: Type Array Ã— Search results Close "},"Protocol.html":{"id":"Protocol.html","title":"Class: Protocol","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Protocol Protocol new Protocol(options) Defines the Storj protocol methods and mounts on a Network instance to handle Storj protocol messages Parameters: Name Type Description options Object Properties Name Type Description network Network Network instance to bind to License: AGPL-3.0 Source: lib/network/protocol.js Methods getRouteMap() Returns bound references to the protocol handlers Source: lib/network/protocol.js Returns: handlers Type Object handleAudit(params, callback) Handles AUDIT messages Parameters: Name Type Description params Object RPC message parameters callback function Completion callback Source: lib/network/protocol.js handleConsign(params, callback) Handles CONSIGN messages Parameters: Name Type Description params Object RPC message parameters callback function Completion callback Source: lib/network/protocol.js handleFindTunnel(params, callback) Handles FIND_TUNNEL messages Parameters: Name Type Description params Object RPC message parameters callback function Completion callback Source: lib/network/protocol.js handleMirror(params, callback) Handles MIRROR messages Parameters: Name Type Description params Object RPC message parameters callback function Completion callback Source: lib/network/protocol.js handleOffer(params, callback) Handles OFFER messages Parameters: Name Type Description params Object RPC message parameters callback function Completion callback Source: lib/network/protocol.js handleOpenTunnel(params, callback) Handles OPEN_TUNNEL messages Parameters: Name Type Description params Object RPC message parameters callback function Completion callback Source: lib/network/protocol.js handleProbe(params, callback) Handles PROBE messages Parameters: Name Type Description params Object RPC message parameters callback function Completion callback Source: lib/network/protocol.js handleRetrieve(params, callback) Handles RETRIEVE messages Parameters: Name Type Description params Object RPC message parameters callback function Completion callback Source: lib/network/protocol.js handleTrigger(params, callback) Handles TRIGGER messages Parameters: Name Type Description params Object RPC message parameters callback function Completion callback Source: lib/network/protocol.js Ã— Search results Close "},"RAMStorageAdapter.html":{"id":"RAMStorageAdapter.html","title":"Class: RAMStorageAdapter","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: RAMStorageAdapter RAMStorageAdapter new RAMStorageAdapter() Implements an in-memory storage adapter License: AGPL-3.0 Source: lib/storage/adapters/ram.js Extends StorageAdapter Methods &lt;abstract&gt; _close(callback) Closes the storage adapter Parameters: Name Type Description callback function Called on complete Inherited From: StorageAdapter#_close Source: lib/storage/adapter.js &lt;abstract&gt; _open(callback) Opens the storage adapter Parameters: Name Type Description callback function Called on complete Inherited From: StorageAdapter#_open Source: lib/storage/adapter.js createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Inherited From: StorageAdapter#createReadStream Source: lib/storage/adapter.js Returns: Type ReadableStream del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Inherited From: StorageAdapter#del Source: lib/storage/adapter.js get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#get Source: lib/storage/adapter.js peek(key, callback) Calls the implemented StorageAdapter#_peek and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#peek Source: lib/storage/adapter.js put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Inherited From: StorageAdapter#put Source: lib/storage/adapter.js size(callback) Calls the implemented StorageAdapter#_size Parameters: Name Type Description callback function Called with error or number of bytes stored Inherited From: StorageAdapter#size Source: lib/storage/adapter.js Events add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js Ã— Search results Close "},"RateLimiter.html":{"id":"RateLimiter.html","title":"Class: RateLimiter","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: RateLimiter RateLimiter new RateLimiter(options) Tracks the number of messages received from a given nodeID and prevents handling of message received during the limited timespan Parameters: Name Type Description options Object Properties Name Type Description rate Number The number of milliseconds before resetting limit Number The number of messages allowed per rate License: AGPL-3.0 Source: lib/network/rate-limiter.js Methods getResetTime() Returns the time left before counter reset Source: lib/network/rate-limiter.js Returns: Type Number isLimited(nodeID) Checks if the given nodeID is currently rate limited Parameters: Name Type Description nodeID String The nodeID for the contact to check Source: lib/network/rate-limiter.js Returns: Type Boolean resetCounter() Resets the rate limit count Source: lib/network/rate-limiter.js updateCounter(nodeID) Increment the counter for the given nodeID Parameters: Name Type Description nodeID String The nodeID of the contact to track Source: lib/network/rate-limiter.js Ã— Search results Close "},"ReadableDataChannelStream.html":{"id":"ReadableDataChannelStream.html","title":"Class: ReadableDataChannelStream","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: ReadableDataChannelStream ReadableDataChannelStream new ReadableDataChannelStream(channel, token, hash) A readable stream for transferring data via DataChannelClient Parameters: Name Type Description channel DataChannelClient The data channel client to use token String The authorization token for transfer hash String The hash of the data to transfer Source: lib/data-channels/readable-stream.js Methods destroy() Closes the underlying connection Source: lib/data-channels/readable-stream.js Returns: didDestroy - Indicates if the stream was destroyed Type Boolean Events data Triggered when a chunk of data has been received from the remote host Source: lib/data-channels/readable-stream.js end Triggered when all data has been received from the remote host Source: lib/data-channels/readable-stream.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/readable-stream.js Ã— Search results Close "},"RenterInterface.html":{"id":"RenterInterface.html","title":"Class: RenterInterface","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: RenterInterface RenterInterface new RenterInterface(options) Creates and a new farmer interface Parameters: Name Type Description options Object Properties Name Type Description keyPair KeyPair Node's cryptographic identity storageManager StorageManager Storage manager backend bridgeUri String URL for bridge server seed lookup logger Object Logger instance seedList Array List of seed URIs to join rpcAddress String Public node IP or hostname rpcPort Number Listening port for RPC doNotTraverseNat Boolean Skip NAT traversal strategies maxTunnels Number Max number of tunnels to provide tunnelServerPort Number Port for tunnel server to use tunnelGatewayRange Object Properties Name Type Description min Number Min port for gateway bind max Number Max port for gateway bind rateLimiterOpts Object Options for RateLimiter Properties: Name Type Description keyPair KeyPair storageManager StorageManager node kad.Node The underlying DHT node triggerManager TriggerManager bridgeClient BridgeClient contact Contact transportAdapter Transport router kad.Router The underlying DHT router dataChannelServer DataChannelServer License: AGPL-3.0 Source: lib/network/interfaces/renter.js Fires: Network#event:ready Extends Network Methods connect(uri, callback) Connects to the node at the given URI Parameters: Name Type Description uri String The storj protocol URI to connect callback function Called on connection or error Inherited From: Network#connect Source: lib/network/index.js getConsignmentPointer(farmer, contract, audit, callback) Requests a consignment pointer from the given farmer for opening a DataChannelClient for transferring the the data shard to the farmer Parameters: Name Type Description farmer Contact The farmer contact object for requesting token contract Contract The storage contract for this consignment audit AuditStream The audit object for merkle leaves callback RenterInterface~getConsignmentPointerCallback Source: lib/network/interfaces/renter.js getConsignToken(farmer, contract, audit, callback) Requests a consignment token from the given farmer for opening a DataChannelClient for transferring the the data shard to the farmer Parameters: Name Type Description farmer Contact The farmer contact object for requesting token contract Contract The storage contract for this consignment audit AuditStream The audit object for merkle leaves callback RenterInterface~getConsignTokenCallback Deprecated: since version 1.4.0 Source: lib/network/interfaces/renter.js getMirrorNodes(sources, destinations, callback) Requests that the given destination farmers mirror the data from the source DataChannelPointer. Parameters: Name Type Description sources Array.&lt;DataChannelPointer&gt; Pointers for each destination destinations Array.&lt;Contact&gt; The farmers to replicate to callback RenterInterface~getMirrorNodesCallback Results handler Source: lib/network/interfaces/renter.js getRetrievalPointer(farmer, contract, callback) Requests a retrieval token from the given farmer for opening a DataChannelClient for transferring the data shard from the farmer Parameters: Name Type Description farmer Contact The farmer contact object for requesting token contract Contract The storage contract for this consignment callback RenterInterface~getRetrievalPointerCallback Token handler Source: lib/network/interfaces/renter.js getRetrieveToken(farmer, contract, callback) Requests a retrieval token from the given farmer for opening a DataChannelClient for transferring the the data shard from the farmer Parameters: Name Type Description farmer Contact The farmer contact object for requesting token contract Contract The storage contract for this retrieval callback RenterInterface~getConsignTokenCallback Deprecated: since version 1.4.0 Source: lib/network/interfaces/renter.js getStorageOffer(contract [, blacklist], callback) Publishes a storage Contract for solicitation of offers based on the supplied shard metadata. Parameters: Name Type Argument Description contract Contract Proposed storage contract to solicit for offers blacklist Array &lt;optional&gt; Optional farmer blacklist for offers callback RenterInterface~getStorageOfferCallback Offer handler Source: lib/network/interfaces/renter.js getStorageProof(farmer, item, callback) Issues an audit request to the given farmer for the data and returns the ProofStream#getProofResult structure for verification. Parameters: Name Type Description farmer Contact Farmer contact from which proof is needed item StorageItem The storage item on which to perform the audit callback RenterInterface~getStorageProofCallback Proof handler Source: lib/network/interfaces/renter.js join(callback) Opens the connection to the network Parameters: Name Type Description callback function Called on successful network join Inherited From: Network#join Source: lib/network/index.js leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Inherited From: Network#leave Source: lib/network/index.js publish(topic, contents, options) Publishes a topic with content to the network Parameters: Name Type Description topic String The serialized opcode topic contents Object Arbitrary publication contents options Object Options to pass to kad-quasar Inherited From: Network#publish Source: lib/network/index.js subscribe(topic, handler) Subscribes to a topic on the network Parameters: Name Type Description topic String The serialized opcode topic handler Object Function to handle received publications Inherited From: Network#subscribe Source: lib/network/index.js Type Definitions getConsignmentPointerCallback(err, pointer) This callback is called upon receipt of a consignment token from RenterInterface#getConsignmentPointer Parameters: Name Type Description err Error | null If requesting the token failed, an error object pointer DataChannelPointer Pointer for a DataChannelClient Source: lib/network/interfaces/renter.js getConsignTokenCallback(err, token) This callback is called upon receipt of a consignment token from RenterInterface#getConsignToken Parameters: Name Type Description err Error | null If requesting the token failed, an error object token String Consignment token for a DataChannelClient Source: lib/network/interfaces/renter.js getConsignTokenCallback(err, token) This callback is called upon receipt of a consignment token from RenterInterface#getConsignToken Parameters: Name Type Description err Error | null If requesting the token failed, an error object token String Consignment token for a DataChannelClient Source: lib/network/interfaces/renter.js getMirrorNodesCallback(err, results) This callback is called upon acknowledgement of a mirror request Parameters: Name Type Description err Error | null If requesting all mirrors failed, an error object results Array.&lt;Contact&gt; The farmers who successfully mirrored Source: lib/network/interfaces/renter.js getRetrievalPointerCallback(err, pointer) This callback is called upon receipt of a retrieval token from RenterInterface#getRetrieveToken Parameters: Name Type Description err Error | null If requesting the token failed, an error object pointer DataChannelPointer Pointer for a DataChannelClient Source: lib/network/interfaces/renter.js getStorageOfferCallback(err, farmer, contract) This callback is called upon receipt of an offer from RenterInterface#getStorageOffer Parameters: Name Type Description err Error | null An error if one is encountered farmer Contact The farmer who offered to fulfill the contract contract Contract The Contact offered by the farmer Source: lib/network/interfaces/renter.js getStorageProofCallback(err, proof) This callback is called upon receipt of an audit proof from RenterInterface#getStorageProof Parameters: Name Type Description err Error | null If requesting the proof failed, an error object proof Array Result from ProofStream#getProofResult Source: lib/network/interfaces/renter.js Events connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js Ã— Search results Close "},"StorageAdapter.html":{"id":"StorageAdapter.html","title":"Class: StorageAdapter","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: StorageAdapter StorageAdapter new StorageAdapter() Abstract base class for storage adapter License: AGPL-3.0 Source: lib/storage/adapter.js Methods &lt;abstract&gt; _close(callback) Closes the storage adapter Parameters: Name Type Description callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _del(key, callback) Delete the shard data at the given key Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _get(key, callback) Performs lookup and provides an StorageItem to the callback Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _keys(callback) Returns the hashes of all shards stored Parameters: Name Type Description callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _open(callback) Opens the storage adapter Parameters: Name Type Description callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _peek(key, callback) Performs lookup and provides an StorageItem to the callback but does not initialize any shard read/write stream Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _put(key, item, callback) Stores the StorageItem Parameters: Name Type Description key String Shard hash item Item Item to store callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _size(callback) Returns the number of bytes stored Parameters: Name Type Description callback function Called on complete Source: lib/storage/adapter.js createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Source: lib/storage/adapter.js Returns: Type ReadableStream del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Source: lib/storage/adapter.js get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Source: lib/storage/adapter.js peek(key, callback) Calls the implemented StorageAdapter#_peek and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Source: lib/storage/adapter.js put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Source: lib/storage/adapter.js size(callback) Calls the implemented StorageAdapter#_size Parameters: Name Type Description callback function Called with error or number of bytes stored Source: lib/storage/adapter.js Events add Triggered when a new item is added Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js ready Triggered when the adapter is ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Source: lib/storage/adapter.js Ã— Search results Close "},"StorageItem.html":{"id":"StorageItem.html","title":"Class: StorageItem","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: StorageItem StorageItem new StorageItem(data) Represents a storage item, including contracts, challenges, the shard itself along with metadata describing download count, payments, etc Parameters: Name Type Description data Object Properties Name Type Description hash String | null Shard hash to use as storage key shard Stream | null Raw binary blob of shard contracts Object Dictionary of nodeID:Contract trees Object Dictionary of nodeID:merkleLeaves challenges Object Dictionary of nodeID:privateAuditData meta Object Dictionary of arbitrary nodeID:metadata License: AGPL-3.0 Source: lib/storage/item.js Methods addAuditRecords(contact, audit) Adds the trees and challenges to the item keyed by nodeID Parameters: Name Type Description contact Contact The contact associated with the trees audit Audit | AuditStream The audit or challenge generator Source: lib/storage/item.js addContract(contact, contract) Adds the contract data keyed by nodeID Parameters: Name Type Description contact Contact The contact associated with the trees contract Contract The storage contract instance Source: lib/storage/item.js addMetaData(contact, meta) Adds the meta data keyed by nodeID Parameters: Name Type Description contact Contact The contact associated with the trees meta Object Arbitrary metadata about the shard Source: lib/storage/item.js updateTimestamp() Updates the timestamp for the item Source: lib/storage/item.js Ã— Search results Close "},"StorageManager.html":{"id":"StorageManager.html","title":"Class: StorageManager","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: StorageManager StorageManager new StorageManager(storage, options) Interface for managing contracts, shards, and audits Parameters: Name Type Description storage StorageAdapter Storage adapter to use options Object Properties Name Type Description disableReaper Boolean Don't perform periodic reaping of stale contracts maxCapacity Number Max number of bytes to allow in storage License: AGPL-3.0 Source: lib/storage/manager.js Extends EventEmitter Methods clean(callback) Enumerates all storage contracts and reaps stale data Parameters: Name Type Description callback function Called on complete Source: lib/storage/manager.js close(callback) Closes the underlying storage adapter Parameters: Name Type Description callback function Called on complete Source: lib/storage/manager.js load(hash, callback) Loads the storage Item at the given key Parameters: Name Type Description hash String Shard hash to load data for callback function Called with error or StorageItem Source: lib/storage/manager.js open(callback) Opens the underlying storage adapter Parameters: Name Type Description callback function Called on complete Source: lib/storage/manager.js save(item, callback) Saves the storage StorageItem at the given key Parameters: Name Type Description item StorageItem The StorageItem to store callback function Called on complete Source: lib/storage/manager.js Events locked Triggered when the underlying storage adapter reaches capacity Source: lib/storage/manager.js unlocked Triggered when the underlying storage adapter has newly freed space Source: lib/storage/manager.js Ã— Search results Close "},"StorageMigration.html":{"id":"StorageMigration.html","title":"Class: StorageMigration","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: StorageMigration StorageMigration new StorageMigration(source, target) Migrates data stored with one StorageAdapter to another Parameters: Name Type Description source StorageAdapter The source adapter target StorageAdapter The migration destination License: AGPL-3.0 Source: lib/storage/migration.js Methods start() Starts the migration process Source: lib/storage/migration.js stop() Stops the migration process Source: lib/storage/migration.js Ã— Search results Close "},"Transport.html":{"id":"Transport.html","title":"Class: Transport","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Transport Transport new Transport(contact, options) Custom HTTP transport adapter Parameters: Name Type Description contact kad.Contact Contact object to binding to port options Object Properties Name Type Description logger Logger Logger for diagnositcs cors Boolean Enable cross origin resource sharing maxTunnels Number Number of tunnels to provide to network doNotTraverseNat Boolean Do not try to punch out of NAT tunnelServerPort Number Port for tunnel server to bind tunnelGatewayRange Object Properties Name Type Description min Number Min port for gateway bind max Number Max port for gateway bind License: AGPL-3.0 Source: lib/network/transport.js Methods createPortMapping(port, callback) Creates a port mapping with UPnP Parameters: Name Type Description port Number The port to forward callback function Callback function Source: lib/network/transport.js send(contact, message, callback) Sends the RPC message to the given contact Parameters: Name Type Description contact Contact message kad.Message callback function Source: lib/network/transport.js Ã— Search results Close "},"TriggerManager.html":{"id":"TriggerManager.html","title":"Class: TriggerManager","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TriggerManager TriggerManager new TriggerManager() Implements behavior triggers as described in SIP-0003 License: AGPL-3.0 Source: lib/sips/0003/trigger-manager.js See: https://github.com/storj/sips/blob/master/sip-0003.md Methods add(nodeID, behaviors) Adds a trigger handler for the given nodeID and behavior Parameters: Name Type Description nodeID String | Array The nodeID(s) to authorize for the trigger (supports `*` wildcard) behaviors Object Behavior name to {TriggerManager~triggerHandler}s Source: lib/sips/0003/trigger-manager.js process(messageParams, callback) Process a received trigger message Parameters: Name Type Description messageParams Object The received message params callback TriggerManager~processCallback Result of trigger process Source: lib/sips/0003/trigger-manager.js remove(nodeID, behaviors) Removes a trigger handler for the given nodeID and behavior Parameters: Name Type Description nodeID String | Array The nodeID(s) to deauthorize for the trigger behaviors String | Array Behavior name to unregister Source: lib/sips/0003/trigger-manager.js Type Definitions destroyTrigger() Optionally called from trigger handler to unregister the trigger handler Source: lib/sips/0003/trigger-manager.js processCallback(err, params) Called upon the processing of a trigger message Parameters: Name Type Description err Error | null Optional error resulting from processing params Object Response parameters to send back Source: lib/sips/0003/trigger-manager.js replyToSender(err, params) Passed to the trigger handler for replying to the message Parameters: Name Type Description err Error | null Optional error to respond with params Object Response parameters to return Source: lib/sips/0003/trigger-manager.js triggerHandler(messageParams, replyToSender, destroyTrigger) Called when a trigger is received from authorized source Parameters: Name Type Description messageParams Object The RPC message parameters replyToSender TriggerManager~replyToSender Respond to the trigger destroyTrigger TriggerManager~destroyTrigger Unregisters trigger Source: lib/sips/0003/trigger-manager.js Ã— Search results Close "},"TunnelClient.html":{"id":"TunnelClient.html","title":"Class: TunnelClient","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelClient TunnelClient new TunnelClient(tunnelServerUri, targetServerUri [, options]) Creates a tunnel connection to a TunnelServer Parameters: Name Type Argument Description tunnelServerUri String URI for remote tunnel server targetServerUri String Destination for forwarding messages options Object &lt;optional&gt; Properties Name Type Argument Description logger Object &lt;optional&gt; A logger object to use License: AGPL-3.0 Source: lib/tunnel/client.js Methods close() Closes the tunnel connection Source: lib/tunnel/client.js Returns: tunnelDidClose Type Boolean open() Opens the tunnel connection Source: lib/tunnel/client.js Events close Triggered when the tunnel is closed Source: lib/tunnel/client.js open Triggered when the tunnel is opened Source: lib/tunnel/client.js Ã— Search results Close "},"TunnelDemuxer.html":{"id":"TunnelDemuxer.html","title":"Class: TunnelDemuxer","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelDemuxer TunnelDemuxer new TunnelDemuxer() Demultiplexes a multiplexed tunnel stream License: AGPL-3.0 Source: lib/tunnel/demultiplexer.js Fires: TunnelDemuxer#event:data Events data Parameters: Name Type Description demuxedMessage Object Properties Name Type Description type String The message type (rpc, datachannel) data Buffer | String The message payload flags Object Properties Name Type Description binary Boolean WebSocket opcode binary flag quid String Quasi-unique associatation ID Source: lib/tunnel/demultiplexer.js Ã— Search results Close "},"TunnelerInterface.html":{"id":"TunnelerInterface.html","title":"Class: TunnelerInterface","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelerInterface TunnelerInterface new TunnelerInterface(options) Creates a new tunneler interface (a passive non-renter/non-farmer node) and is just a Network instance, with more appropriate default options including an in-memory storage adapter. Parameters: Name Type Description options Object Properties Name Type Argument Default Description keyPair KeyPair Node's cryptographic identity bridgeUri String URL for bridge server seed lookup logger Object Logger instance seedList Array List of seed URIs to join rpcAddress String Public node IP or hostname rpcPort Number &lt;optional&gt; 8080 Listening port for RPC doNotTraverseNat Boolean &lt;optional&gt; true Skip NAT traversal maxTunnels Number &lt;optional&gt; Max number of tunnels to provide tunnelServerPort Number &lt;optional&gt; 8081 Port for tunnel server tunnelGatewayRange Object Properties Name Type Argument Default Description min Number &lt;optional&gt; 8082 Min port for bind max Number &lt;optional&gt; 9005 Max port for bind rateLimiterOpts Object Options for RateLimiter License: AGPL-3.0 Source: lib/network/interfaces/tunneler.js Extends Network Methods connect(uri, callback) Connects to the node at the given URI Parameters: Name Type Description uri String The storj protocol URI to connect callback function Called on connection or error Inherited From: Network#connect Source: lib/network/index.js join(callback) Opens the connection to the network Parameters: Name Type Description callback function Called on successful network join Inherited From: Network#join Source: lib/network/index.js leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Inherited From: Network#leave Source: lib/network/index.js publish(topic, contents, options) Publishes a topic with content to the network Parameters: Name Type Description topic String The serialized opcode topic contents Object Arbitrary publication contents options Object Options to pass to kad-quasar Inherited From: Network#publish Source: lib/network/index.js subscribe(topic, handler) Subscribes to a topic on the network Parameters: Name Type Description topic String The serialized opcode topic handler Object Function to handle received publications Inherited From: Network#subscribe Source: lib/network/index.js Events connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contract Contract The complete contract, signed by us and farmer contact Contact The farmer contact the offer is from Inherited From: Network#event:unhandledOffer Source: lib/network/index.js Ã— Search results Close "},"TunnelGateway.html":{"id":"TunnelGateway.html","title":"Class: TunnelGateway","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelGateway TunnelGateway new TunnelGateway(options, port) Creates a tunnel gateway and emits manages entry and exit messages Parameters: Name Type Description options Object Options to pass to http.Server/https.Server Properties Name Type Argument Description logger Object &lt;optional&gt; A logger to use port Number Port to bind gateway entrance License: AGPL-3.0 Source: lib/tunnel/gateway.js Fires: TunnelGateway#event:message/rpc TunnelGateway#event:message/datachannel Methods close(callback) Closes the gateway Parameters: Name Type Description callback function Optional completion callback Source: lib/tunnel/gateway.js getEntranceAddress() Returns the alias data for the gateway Source: lib/tunnel/gateway.js Returns: alias Type Object | null getEntranceToken() Returns the authorization token for this gateway Source: lib/tunnel/gateway.js Returns: alias Type Object open(callback) Opens the gateway Parameters: Name Type Description callback function Optional completion callback Source: lib/tunnel/gateway.js respond(message) Dispatches the supplied response the the given pending RPC by ID Parameters: Name Type Description message Object The JSON-RPC message response Source: lib/tunnel/gateway.js Returns: sent - Whether or not the message was sent Type Boolean terminate(quid, code [, message]) Terminates the specified channel Parameters: Name Type Argument Description quid String The quasi-unique socket identifier code Number The status code message String &lt;optional&gt; Status message Source: lib/tunnel/gateway.js Returns: terminated - Whether or not the channel was terminated Type Boolean transfer(quid, data) Writes the supplied data to the socket at the given quid Parameters: Name Type Description quid String The quasi-unique socket identifier data String | Buffer The data to be transferred Source: lib/tunnel/gateway.js Returns: sent - Whether or not the data was transferred Type Boolean Events close Triggered when the gateway is closed Source: lib/tunnel/gateway.js message/datachannel Triggered when a message is received over a datachannel Parameters: Name Type Description data Buffer | String The data frame received flags Object WebSocket flags included Properties Name Type Description binary Boolean Frame was sent with 0x02 opcode quid String Quasi-unique ID assigned to this socket Source: lib/tunnel/gateway.js message/rpc Triggered when a message is received over RPC Parameters: Name Type Description message Object The parsed RPC message received Source: lib/tunnel/gateway.js open Triggered when the gateway is opened Source: lib/tunnel/gateway.js Ã— Search results Close "},"TunnelMuxer.html":{"id":"TunnelMuxer.html","title":"Class: TunnelMuxer","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelMuxer TunnelMuxer new TunnelMuxer() Multiplexes events from a TunnelGateway and exposes a readable stream to piped down to a TunnelClient (and vice-versa). License: AGPL-3.0 Source: lib/tunnel/multiplexer.js Methods source(source) Set up event listeners for a TunnelGateway or TunnelClient Parameters: Name Type Description source TunnelGateway | TunnelClient Input source to add Source: lib/tunnel/multiplexer.js Returns: source Type TunnelGateway | TunnelClient Ã— Search results Close "},"TunnelServer.html":{"id":"TunnelServer.html","title":"Class: TunnelServer","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelServer TunnelServer new TunnelServer(options) Creates a Tunnel server for NATed or firewalled clients to use to join the overlay network. Parameters: Name Type Description options Object Properties Name Type Argument Default Description server http.Server &lt;optional&gt; Transport adapter to bind to serverPort Number &lt;optional&gt; 4001 Port to bind if no server given maxTunnels Number &lt;optional&gt; 3 Maximum number of gateways to open gatewayPortRange Object &lt;optional&gt; Properties Name Type Argument Default Description min Number &lt;optional&gt; 4002 Min gateway port bind max Number &lt;optional&gt; 4003 Min gateway port bind logger Object &lt;optional&gt; A Logger object to use License: AGPL-3.0 Source: lib/tunnel/server.js Methods close(callback) Closes the tunnel server Parameters: Name Type Description callback function Source: lib/tunnel/server.js createGateway(callback) Creates a new TunnelGateway and prepares it for use Parameters: Name Type Description callback function Called on TunnelGateway#event:open Source: lib/tunnel/server.js getListeningPort() Returns the port the tunnel server is listening on Source: lib/tunnel/server.js Returns: port Type Number hasTunnelAvailable() Returns whether or not this tunnel server has any available tunnels Source: lib/tunnel/server.js Returns: Type Boolean Events locked Triggered when the server has no more available tunnels Source: lib/tunnel/server.js ready Triggered when the server is listening Source: lib/tunnel/server.js unlocked Triggered when the server has an available tunnel Source: lib/tunnel/server.js Ã— Search results Close "},"Unpadder.html":{"id":"Unpadder.html","title":"Class: Unpadder","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Unpadder Unpadder new Unpadder() Takes an input stream and removes padded zeroes from the tail License: LGPL-3.0 Source: lib/file-handling/unpadder.js Ã— Search results Close "},"UploadState.html":{"id":"UploadState.html","title":"Class: UploadState","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: UploadState UploadState new UploadState(options) Internal state machine used by BridgeClient Parameters: Name Type Description options Object Properties Name Type Description id String Bucket ID for the upload state file String Path to the file to track numShards Number The number of shards to transfer concurrency Number The number shards to transfer at once worker function The queue task processor function onComplete function Reference to callback after complete License: LGPL-3.0 Source: lib/bridge-client/upload-state.js Methods cleanup() Unlinks the referenced tmp files Source: lib/bridge-client/upload-state.js Events killed Triggered when the upload queue has been killed Source: lib/bridge-client/upload-state.js Ã— Search results Close "},"Verification.html":{"id":"Verification.html","title":"Class: Verification","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Verification Verification new Verification(proof) Interface for verifying the result of an audit proof Parameters: Name Type Description proof Array The result of ProofStream#getProofResult License: LGPL-3.0 Source: lib/audit-tools/verification.js Methods verify(merkleRoot, totalDepth) Verifies the proof given the merkle root and tree depth Parameters: Name Type Description merkleRoot String Merkle root totalDepth Number Depth of merkle tree Source: lib/audit-tools/verification.js Returns: result - Array with expected result and verified result Type Array Ã— Search results Close "},"WritableDataChannelStream.html":{"id":"WritableDataChannelStream.html","title":"Class: WritableDataChannelStream","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: WritableDataChannelStream WritableDataChannelStream new WritableDataChannelStream(channel, token, hash) A writable stream for transferring data via DataChannelClient Parameters: Name Type Description channel DataChannelClient The data channel client to use token String The authorization token for transfer hash String The hash of the data to transfer Source: lib/data-channels/writable-stream.js Methods destroy() Closes the underlying connection Source: lib/data-channels/writable-stream.js Returns: didDestroy - Indicates if the stream was destroyed Type Boolean Events error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/data-channels/writable-stream.js finish Triggered when all data has been flushed and remote host receives it Source: lib/data-channels/writable-stream.js Ã— Search results Close "},"tutorial-command-line-interface.html":{"id":"tutorial-command-line-interface.html","title":"Tutorial: Using the Command Line Tools","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Using the Command Line Tools This package comes equipped with a command line interface for performing a number of useful operations on the Storj network. The CLI program is generally focused on interacting with a remote Bridge service and makes use of the library's BridgeClient class to do so. In addition to interacting with a bridge node, the tool also exposes some general purpose utilities. To use the CLI, follow the instructions in the README to install the module globally or if you are working from within the git repository, you can use: npm linkCommunicating with a BridgeOnce you have access to the storj command, register and authenticate with the bridge: &gt; $ storj register [...] &gt; Enter your email address &gt; gordon@storj.io [...] &gt; Enter your password &gt; ************* [info] Registered! Check your email to activate your account.Follow the activation link you receive via email and come back to the CLI to pair with your account: &gt; $ storj login [...] &gt; Enter your email address &gt; gordon@storj.io [...] &gt; Enter your password &gt; ************* [info] This device has been successfully paired.Now you can create buckets, transfer files, and manage your bridge account. Audits, Proofs, and VerificationsThe CLI also includes some utility commands for generating file possession audits, proving possession, and verifying proofs. You can generate a challenge set and merkle tree for a file easily: &gt; $ storj prepare-audits 2 CONTRIBUTING.md [info] Generating challenges and merkle tree... [info] [info] Merkle Root [info] ----------- [info] 9c8c37935f58d46e3301efe4f44724b8785a81a5 [info] [info] Challenges [info] ---------- [info] c8573773616e072230d40131e7ce8537d384825e337e5903ff7367ddea798c52 [info] 7c4d4f57f40d5c95f962e7cd72347e4077e1885aaffd8c1ccbbd02c8d7c48dce [info] [info] Merkle Leaves [info] ------------- [info] aaf42766d87a37e6dffbae7172fd0073006bf5f3 [info] ccee086dbc8a16b93b79912cb37f3b037bbf8269A farmer can use parts of this data to prove possession of a file shard: &gt; $ storj prove-file aaf42766d87a37e6dffbae7172fd0073006bf5f3,ccee086dbc8a16b93b79912cb37f3b037bbf8269 c8573773616e072230d40131e7ce8537d384825e337e5903ff7367ddea798c52 CONTRIBUTING.md [info] Generating proof of possession... [info] [info] Challenge Response [info] ------------------ [info] [[&quot;153a0d4b1d228043992fec585cadb51974b053f7&quot;],&quot;ccee086dbc8a16b93b79912cb37f3b037bbf8269&quot;]The result of this operation can be used by the original renter to verify the the proof and confirm that the farmer still has possession of the file: &gt; $ storj verify-proof 9c8c37935f58d46e3301efe4f44724b8785a81a5 2 '[[&quot;153a0d4b1d228043992fec585cadb51974b053f7&quot;],&quot;ccee086dbc8a16b93b79912cb37f3b037bbf8269&quot;]' [info] [info] Expected: 9c8c37935f58d46e3301efe4f44724b8785a81a5 [info] Actual: 9c8c37935f58d46e3301efe4f44724b8785a81a5 [info] [info] The proof response is validFor more detailed usage information of the command line interface, run storj --help. Temporary FilesOn Windows temporary files are stored: C:\\Users\\&lt;user&gt;\\AppData\\Local\\Temp Ã— Search results Close "},"tutorial-contract-topics.html":{"id":"tutorial-contract-topics.html","title":"Tutorial: Publishing Storage Contracts","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Publishing Storage Contracts Nodes solicit storage contracts with the network by publishing information about their storage requirements as outlined in Protocol Specification. Storj implements a distributed publish/subscribe system based on an algorithm called Quasar. Quasar works by allowing nodes to advertise topics of interest to their neighbors and keeping a record of these topics in their neighborhood by storing them in an attenuated bloom filter. Each node has a view of the topics in which their neighbors are interested up to 3 hops away. By the nature of this design, the network forms gravity wells wherein messages of interest are efficiently relayed to nodes that are subscribed to the topic without flooding the network. This approach works well when there is a diverse number of topics. The Storj protocol leverages this by defining a matrix of criteria and descriptors in the form of opcodes representing the degree of which the criteria must be met. CriteriaAt the time of writing, there are 4 criteria column in the topic matrix: Size Duration Availability Speed SizeRefers to the size of the data to be stored. DurationRefers to the length of time for which the data should be stored. AvailabilityRefers to the relative uptime of required by the contract for retrieval of the stored data. SpeedRefers to the throughput desired for retrieval of the stored data. DescriptorsAt the time of writing, there are 3 descriptor opcodes representing low, medium, and high degrees of the criteria. Low: 0x01 Medium: 0x02 High: 0x03 The ranges represented by these descriptors are advisory and may change based on network performance and improvements to hardware over time. ------------------------------------------------------------------------------- | Descriptor | Size | Duration | Availability | Speed | |-----------------|-------------|------------|--------------|-----------------| | Low (`0x01`) | 0mb - 8mb | 0d - 30d | 0% - 50% | 0mbps - 6mbps | |-----------------|-------------|------------|--------------|-----------------| | Medium (`0x02`) | 8mb - 16mb | 30d - 90d | 50% - 80% | 6mbps - 12mbps | |-----------------|-------------|------------|--------------|-----------------| | High (`0x03`) | 16mb - 32mb | 90d - 270d | 80% - 99% | 12mbps - 32mbps | -------------------------------------------------------------------------------Topic FormatWhen publishing or subscribing to a given topic representing the degrees of these criteria, nodes must serialize the opcodes as the hex representation of the bytes in proper sequence. This sequence is defined as: prefix|size|duration|availability|speedThe first byte, &quot;prefix&quot;, is the static identifier for a contract publication. Contracts are not the only type of publication shared in the network, so the prefix acts as a namespace for a type of publication topic. The prefix for a contract publication is: 0x0f. To illustrate by example, we can determine the proper topic by analyzing the use case for a given file shard. For instance, if we want to store an asset that is displayed on a web page we can infer the following: The file is small The file may change often, so we should only store it for medium duration The file needs to always be available The file should be transferred quickly Using the matrix, we can determine the proper opcode sequence: [0x0f, 0x01, 0x02, 0x03, 0x03]Serialized as hex, our topic string becomes: 0f01020303Another example, by contrast, is data backup. Data backup is quite different than the previous example: The file is large (perhaps part of a hard drive backup) The file will not change and should be stored long term The file will not be accessed often, if ever The file does not need to be transferred at high speed Using the matrix, we can determine the proper opcode sequence: [0x0f, 0x03, 0x03, 0x01, 0x01]Serialized as hex, our topic string becomes: 0f03030101The resulting hex string from the serialized opcode byte sequence should be used as the topic parameter of a PUBLISH RPC as defined in the Protocol Specification. Nodes that are subscribed to the topic will receive the proposed storage contract and may begin contract negotiation with you directly. Ã— Search results Close "},"tutorial-data-channels.html":{"id":"tutorial-data-channels.html","title":"Tutorial: Transferring File Shards","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Transferring File Shards Nodes on the Storj network implement a separate &quot;data channel&quot; for file transfer. Each node must expose a WebSocket server that accepts connections from clients who wish to use the channel for shard consignments and retrieval. The WebSocket server must be accessible at the same path as the JSON-RPC server and is negotiated by sending the Sec-WebSocket-Key header to indicate the connection upgrade as defined by RFC6455. Once the WebSocket connection is open, the client must send a JSON formatted message including the necessary information for the farmer to authorize the data channel. Authorizing a ChannelThe JSON message the client must provide to the farmer before establishing the channel must contain the token provided from a previous CONSIGN or RETRIEVE request, the hash of the data being transferred, and the operation (either PUSH or PULL). { &quot;token&quot;: &quot;5a7ac2dd58377085bad57f864b3a493c288b7c07&quot;, &quot;hash&quot;: &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;operation&quot;: &quot;PUSH&quot; } Authorization message frames must use opcode 0x1 (textual). The receiving farmer must check that she issued the received token within a reasonable amount of time (recommend 10 minutes) and that the supplied hash is associated with that token before sending or receiving any other data. If the authorization fails, the farmer must close the data channel, optionally responding with a status message. Status CodesFarmers can communicate the result of an operation by sending back a special status code and message when closing the connection. NORMAL: 1000 UNEXPECTED: 1011 INVALID_MESSAGE: 3100 UNAUTHORIZED_TOKEN: 3101 FAILED_INTEGRITY: 3102 INVALID_OPERATION: 3103 Consigning a ShardTo consign a shard (to upload the shard to a farmer), first send the appropriate authorization message. If the farmer does not respond with a failed status message, the channel is open and you can begin sending binary frames. Farmers must track the amount of data received and ensure that it does not exceed the amount defined in the contract. Once the farmer has received the number of bytes defined in the contract, she must verify the data against the hash defined in the contract. If these checks are successfully executed, then the farmer must respond with a positive status message and terminate the channel. Shard message frames must use opcode 0x2 (binary). Example (browser-based)var channel = new WebSocket('&lt;farmer_uri&gt;'); channel.addEventListener('open', function() { channel.send(JSON.stringify({ token: '&lt;token&gt;', hash: '&lt;hash&gt;', operation: 'PUSH' }); channel.send(new Blob([/* ... */])); }); channel.addEventListener('close', function(e) { if (e.code !== 1000) { console.error('Error consigning data:', e.reason); } else { console.log('Successfully consigned data!'); } });Retrieving a ShardTo retrieve a shard from a farmer, first send the appropriate authorization message. The farmer will respond with a negative status message frame if you are not authorized and terminate the channel. If authorization is successful, you will immediately begin receiving binary message frames until there is no more data to be transferred - at which point the farmer must terminate the channel. Shard message frames must use opcode 0x2 (binary). Example (browser-based)var channel = new WebSocket('&lt;farmer_uri&gt;'); var fileparts = []; channel.addEventListener('open', function() { channel.send(JSON.stringify({ token: '&lt;token&gt;', hash: '&lt;hash&gt;', operation: 'PULL' }); }); channel.addEventListener('message', function(e) { fileparts.push(e.data); }); channel.addEventListener('close', function(e) { if (e.code !== 1000) { console.error(e.reason); } else { var file = new Blob(fileparts, { type: '&lt;mime_type&gt;' }); var url = URL.createObjectURL(file); location.href = url; } });File ReconstructionIn most cases a complete file is consigned to a number of different farmers. To reconstruct a file, you'll need to know the location of each shard and the concatenation order. With this information, you can open data channels to each of the farmers storing the file's shards (with whatever degree of parallelism suits your needs) and concatenate the binary blobs received in the proper order. Ã— Search results Close "},"tutorial-environment-variables.html":{"id":"tutorial-environment-variables.html","title":"Tutorial: Environment Variables","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Environment Variables Below is a list of environment variables that can be used to alter the behavior of the core library and associated tooling. STORJ_NETWORKThis value will be postfixed to your announced protocol version in the network. A value of testnet would advertise to the network you are running 0.7.0-testnet, which will isolate you to other nodes running the same exact version. See Running a Test Network for more information. STORJ_ALLOW_LOOPBACKBy default, the Network class will drop and ignore message from nodes who identify themeselves as a loopback interface like localhost, 127.0.0.1, etc. This is a security precaution to prevent others from causing you to send messages to yourself as well as prevent invalid contacts in your routing table. To disable this feature (primarily for local testing), set this variable to 1. STORJ_BRIDGEThis variable will change the default URI for the BridgeClient class. The default value is https://api.storj.io. If you run your own bridge, testing one locally, or otherwise would like to default to a different host, set this variable. This works well with the CLI (see Using the Command Line Tools) when testing against other bridges. STORJ_KEYPASSThis variable will set the --keypass used to unlock the keyring. Setting your password will make it so other users can't grep it with ps -a. STORJ_TEMPThis variable will set the folder to which the encrypted file will be placed when uploading a file. Shards will also be placed in this folder during upload. Ã— Search results Close "},"tutorial-file-encryption.html":{"id":"tutorial-file-encryption.html","title":"Tutorial: File Encryption Standards","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections File Encryption Standards This document serves to provide a detailed account of how files are encrypted by default by Storj Core to promote interoperability between different implementations of clients. Sharding and Encryption SchemeBefore data is stored in the network, the Storj Core library automatically handles file encryption, sharding, and key management for you. In order of operations: Complete file is encrypted with a unique key and initialization vector File is demultiplexed (or &quot;sharded&quot;) into individual chunks Each shard is offered to the network and transferred Key and IV is encrypted with a passphrase and stored locally Key and Initialization Vector GenerationFiles are encrypted using AES-256-CTR. The key is the result of a generated PBKDF2. To generate the PBKDF2 value, you will need a password and a salt. These two values are the result of some randomly generated bytes: Password: 512 random bytes Salt: 32 random bytes The key length of the PBKDF2 is 512 bytes, should use 25000 iterations, and use SHA-512 as the digest. To create the cipher/decipher and initialization vector, derive the SHA-256 hash of the resulting PBKDF2 for the cipher/decipher key and use the first 16 bytes of the original salt as the iv. The KeyRing class stores the original password and salt in an encrypted JSON document (using a user supplied passphrase) keyed by the ObjectId returned from Storj Bridge for the file object. The cleartext JSON document has two properties: pass and salt. { &quot;pass&quot;: &quot;c7c311ee213d10baefd620a004d76485190d82...&quot;, &quot;salt&quot;: &quot;6d33490c999e9d613ccf4b146446763df15de2...&quot; }This JSON string is encrypted with AES-256-CBC and encoded as Base58. Each of those encrypted JSON documents is stored in a directory called key.ring/ and the file name is the ObjectId returned from Storj Bridge for the file object. Portable Key Ring FormatA KeyRing created by Storj Core can be exported into a portable format, which is simply a gzipped tape archive (.tar.gz or .tgz). Importing this archive simply entails: Decompress and unpack the archive Decrypt each JSON document using the original passphrase Encrypt each document with the passphrase of the target keyring Move the files into the target keyring, optionally overwriting conflicts References DataCipherKeyIv EncryptStream DecryptStream KeyRing Ã— Search results Close "},"tutorial-private-testnet.html":{"id":"tutorial-private-testnet.html","title":"Tutorial: Running a Test Network","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Running a Test Network Setting up a private or partitioned version of the Storj network is very simple. The Storj protocol requires the inclusion of a protocol property nested inside the contact data included in every RPC message. See Protocol Specification for more information on the RPC message format. Protocol Identifier FormatNodes on the Storj network identify the version of the protocol they are running with the use of a semantic version tag. When a node is trying to determine whether or not another node is compatible with her version of the protocol, she checks the following: Is the MAJOR version the same? Is the MAJOR version 0? Is the MINOR version the same? If both nodes are running the same MAJOR version and that version is not 0, then the nodes are compatible. If the MAJOR version is 0, then the nodes are compatible only if the MINOR version is the same. For example: 0.5.1 is compatible with 0.5.3 0.5.1 is not compatible with 0.6.0 1.5.1 is compatible with 1.13.0 2.1.0 is not compatible with 1.13.0 Special IdentifiersThe semantic versions specification also allows for special identifiers by postfixing the version with a hyphen followed by some identifier. This is where the network partitioning magic happens. Let's say, for example, I work for &quot;Widgets Ltd&quot; and I want to deploy a Storj network within the Widgets Ltd private network. Every workstation would run a modified version of storj/farmer or maybe my own custom interface built atop storj/core. I would simply change my Storj-based software to use the version 1.5.0-widgetsltd. The Storj protocol sees this identifies as a strict match and therefore any nodes running this version of the software will only communicate with nodes running the exact protocol identifier. Changing the VersionChanging the version in storj/core is easy as pie. In your code, simply import the module and change the identifier like so: // Import core library var storj = require('storj'); // Modify protocol version storj.version.protocol = '1.5.0-widgetsltd'; // Get on with your stuff...If you are running &quot;vanilla&quot; Storj software, you can change the protocol version by setting the STORJ_NETWORK environment variable. This will add a postfix to the protocol version, which will partition the network to nodes that are running that exact version: STORJ_NETWORK=testnet storjshare --datadir /path/to/shardsThis concept applies broadly to deploying a custom Storj network for any purpose. This could be used for a public testnet (x.x.x-testnet) or for the private network example above. Ã— Search results Close "},"tutorial-protocol-spec.html":{"id":"tutorial-protocol-spec.html","title":"Tutorial: Protocol Specification","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Protocol Specification Nodes communicate with each other using JSON-RPC 2.0 over HTTPS. This requires farmers (nodes who are contracted by renter to store data) to be publicly addressable and enables access to content from web browsers, mobile phones, and any other devices that speak HTTP (hint: everything). This document outlines the specification for the RPC interface by defining the message structure, required methods, and expected response formats that are needed for a Storj protocol compliant implementation. Note that there may be other aspects of the protocol that are implemented as SIPs (Storj Improvement Proposals). See the end of this document for a list of implemented SIPs. Request FormatRequests are formed according to the JSON-RPC 2.0 specification and are issued via HTTP POST. The Storj protocol requires the use of named parameters - positional parameters are not supported. Example: { &quot;method&quot;: &quot;PING&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;89cc3ddb4209c6e7e301c10c0257adf4fd85f253&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;3045022100de2e162d017a1e9d0ebfe2a94df3fc847b68281a9882...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The receiving node for this request would then respond with the result, which in the case of a PING message, is simply an acknowledgement that includes the recipient's contact information and required signature and nonce: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }In the event that an error occurs, an error property must be added to the response. You still need to include your contact data in the result property of the response: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;OH GOD THERE'S SO MUCH BLOOD&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Joining the NetworkTo join the Storj network, one must only know the contact information for a single &quot;seed&quot; node. A node's contact information is defined as the following three properties: address - hostname, domain, or IP port - port number on which the node is listening nodeID - hash of the node's public key (see below) protocol - version of the protocol implementation This information can be expressed as a URI in the following format: storj://10.0.0.2:1337/89cc3ddb4209c6e7e301c10c0257adf4fd85f253In addition to knowing this information about the seed, you also will need to know this information about yourself, so that it can be provided to the nodes with which you are communicating. Your &quot;contact card&quot; must be provided as the contact parameter in every message sent (both requests and responses). This is because messages must be signed with your private key and your nodeID is used by recipients to verify two things: That you own the private key corresponding to your claimed nodeID That the message was in fact sent by you and not an attacker In the Storj network, nodes are identified by the hash of the public portion of an ECDSA key pair. Key pairs are generated using curve SECP256K1 and a node's nodeID is the &quot;pubkeyhash&quot;, defined as: RIPEMD160(SHA256(public_key))This pubkeyhash, combined with a message and signature is enough data to reconstruct the complete public key and is used in the Storj network to sign and verify messages. This ensures that nodes are unable to assume the identity of another node by claiming it has the same nodeID. PROBEBefore a node can join the network, it must determine whether or not it is reachable (or publicly addressable). This can be determined by sending a PROBE request to a known seed. { &quot;method&quot;: &quot;PROBE&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The PROBE RPC message triggers the recipient to attempt to reach the supplied Contact directly by sending a PING RPC message. If the target Contact reponds to the PING, then the PROBE should yield a success response, which is indicated by simply responding to the RPC message with only the required parameters and no error property. { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }If the PING message triggered by the PROBE fails, then the recipient of the PROBE RPC must respond with an error indicating to the sender that she is not addressable. { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;PROBE FAILED&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }If the PROBE fails, you cannot successfully join the overlay and need to establish a tunnel through a node that is addressable on the network. FIND_TUNNELFinding a node that is willing to tunnel your connection to the overlay begins with a FIND_TUNNEL RPC message sent to a known seed. Nodes on the network maintain a record of known nodes that are willing to tunnel, by subscribing to &quot;tunnel announcements&quot; over the publish/subscribe system. For more information on how nodes announce willingness to tunnel, see the documentation for Tunnelling Connections. { &quot;method&quot;: &quot;FIND_TUNNEL&quot;, &quot;params&quot;: { &quot;relayers&quot;: [], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When a node receives a FIND_TUNNEL message, it should respond with ALPHA (3) contacts that are close the the sender's nodeID who have previously published their willingness to tunnel. If the recipient herself is willing to tunnel the connection, she may include herself in the response even if her nodeID is not closer to the sender's nodeID than her known tunnels. { &quot;result&quot;: { &quot;tunnels&quot;: [ { &quot;address&quot;: &quot;10.0.0.4&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, { &quot;address&quot;: &quot;10.0.0.5&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, { &quot;address&quot;: &quot;10.0.0.6&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The result of a FIND_TUNNEL message looks almost identical to the result of a FIND_NODE message, with the exception being the name of the result key is tunnels instead of nodes. Now that the original sender possesses the contact information for some known tunnels, she should keep them in her record so that she can later respond to other's FIND_TUNNEL requests appropriately. Before the node can join the overlay (after determining it is not publicly addressable), it needs to establish a connection tunnel through one of the Contacts received from the FIND_TUNNEL request. OPEN_TUNNELEstablishing a tunnel is initiated by sending an OPEN_TUNNEL RPC message to a node who has indicated their willingness to tunnel. Only the minimum required parameters need to be sent. In the future, the protocol may be enhanced to include additional information in the OPEN_TUNNEL RPC for negotiating payment channels or other conditions. { &quot;method&quot;: &quot;OPEN_TUNNEL&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The recipient of the OPEN_TUNNEL message must determine whether or not she can satisfy the request. This decision may be based upon an arbitrary limit set by the node regarding how many concurrent tunnels she wishes to open, available bandwidth, etc. If the node is capable of establishing the tunnel, she must do so, assigning a dedicated address or port to receive messages and data channel requests (see Transferring File Shards). Once the tunnel's dedicated entry point has been established, she responds to the sender of the OPEN_TUNNEL request with a unique WebSocket URI that includes a token, as well as an alias property which contains the contact information for the new entry point through which data will enter the tunnel. { &quot;result&quot;: { &quot;tunnel&quot;: &quot;ws://10.0.0.3:1337/tun?token=2bfb23f98e72&quot;, &quot;alias&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1338 }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }This response indicates that a tunnel has been established and the original sender can receive messages from the overlay by opening a WebSocket connection to the tunnel address in the reply. In addition, the sender must update it's Contact information to the included alias so that it can be reached by other peers in the overlay. If the recipient of the OPEN_TUNNEL message is not able to establish a tunnel for the sender, then she may respond with an error so that the sender can attempt to open a tunnel with other known contact. { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;Failed to establish tunnel, multiplexer full&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Once your node has determined that it is publicly addressable on the network or has successfully established a tunnel, it can join the overlay network by issuing a FIND_NODE request sent to one or more known seeds. The request must include a key, contact (you), along with a signature and nonce. FIND_NODEWhen issuing a FIND_NODE request, you provide a key that represents the nodeID of the contact of which you would like to know their neighbors. When joining the network, this value is your own nodeID. { &quot;method&quot;: &quot;FIND_NODE&quot;, &quot;params&quot;: { &quot;key&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When a node receives a FIND_NODE RPC message, it must perform a lookup in it's routing table and respond with a nodes array containing the known contacts that are &quot;closest&quot; to the provided key. This is based on the XOR metric as the Storj network uses a Kademlia-based overlay. In addition, if the receiving node is not already aware of the requesting node, it may add the requester to it's own routing table to later inform other requesters. { &quot;result&quot;: { &quot;nodes&quot;: [ { &quot;address&quot;: &quot;10.0.0.4&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, { &quot;address&quot;: &quot;10.0.0.5&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, { &quot;address&quot;: &quot;10.0.0.6&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of the FIND_NODE response, the node attempting to join the network may iteratively send the same FIND_NODE request to contacts that have been newly added to the routing table to build out a wider view of the network. Once the joining node is satisfied with the size of the routing table (or there are no more nodes to discover), this is considered a successful join. Soliciting StorageOnce a node has a sufficiently complete routing table and view of the network, it's time to buddy up with it's neighbors to cooperate in the sharing and relay of publications. A &quot;publication&quot; is essentially a request for storage. When a node in the network wishes to store some data, it notifies it's closest neighbors who, if interested, will respond to negotiate a storage contract. If the neighbors are not offering storage or do not wish to fulfill the terms of the storage contract, they must check to see if any of their neighbors are and forward the publication to them. If no known neighbors are interested, then the publication is sent to a random node in that neighbor's routing table and the process repeats until an interested node fulfills the contract. SUBSCRIBEIn order to know what publications in which your neighbors are interested, we select the 3 nodes in our routing table that are identified by a nodeID that is closest to ours and we issue a SUBSCRIBE message to each of them: { &quot;method&quot;: &quot;SUBSCRIBE&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }To properly handle a SUBSCRIBE message, the recipient must respond with an attenuated bloom filter, with a size 160 bits and a depth of 3. This data structure represents 3 sets of topics to which the recipient's neighbors are subscribed 3 &quot;hops&quot; away. { &quot;result&quot;: { &quot;filters&quot;: [ &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When the original requesting node receives this response, it must update it's local attenuated bloom filter to reflect this response, starting at it's filter at index 1 (since index 0 is reserved for topic to which the node itself is interested). UPDATEAfter the requester updates it's local view of it's neighbor's publication subscriptions, it must in turn update it's neighbors with it's own publication subscriptions by providing it's own attenuated bloom filter: { &quot;method&quot;: &quot;UPDATE&quot;, &quot;params&quot;: { &quot;filters&quot;: [ &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }This method is essentially the &quot;push&quot; version of the SUBSCRIBE message, where instead of providing subscription information as a response, we provide it as a request. Whenever a node subscribes to a new publication topic, it should initiate another SUBSCRIBE/UPDATE loop with it's neighbors to ensure that it may cooperate in publication relay effectively. PUBLISHOnce a node has a view of the publications to which it's neighbors are subscribed, it is capable of issuing a PUBLISH message containing a topic and some content. This message is sent to the node's nearest neighbors, who then relay it to their neighbors based upon their own view of nearby subscriptions. The topic property and the corresponding contents data is arbitrary, but this mechanism is used for publishing &quot;asks&quot; for storage contracts. In this case, the topic is equal to the Contract type and the contents is equal to the proposed contract itself. See Publishing Storage Contracts for more information on how to choose a valid contract type for your storage needs. { &quot;method&quot;: &quot;PUBLISH&quot;, &quot;params&quot;: { &quot;uuid&quot;: &quot;7f0c40a2-e465-4f3e-b617-3d53460e34f7&quot;, &quot;topic&quot;: &quot;0f02010303&quot;, &quot;contents&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: null, &quot;farmer_id&quot;: null, &quot;farmer_signature&quot;: null, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: null }, &quot;publishers&quot;: [ &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; ], &quot;ttl&quot;: 1455228597837, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of a PUBLISH message, a node must first check to make sure it has not already received the publication. This is done by caching the uuid of received publications. If the node has already seen the publication, it should respond with an error message indicating such. The node should also make sure that the publication has not expired by checking the ttl against the current UNIX time. If the node has not previously seen the publication and the message has not expired, then it must check to see if the publication topic is of interest to itself by testing it's attenuated bloom filter at index 0 for the topic. If the node is interested in the publication, it may take action accordingly. In the case of storage contract, the node may begin communicating directly with the original publisher to finalize the contract. Regardless of whether or not the node is interested in the publication, it should acknowledge receipt of the publication to the forwarder: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Then, it must append negative information to the publication message by adding it's own nodeID to the publishers property. Once the message has been updated with the negative information, the node must check it's attenuated bloom filter to see if any of it's neighbors are also interested and, if so, forward the message along to them. If no neighbors are interested, the node must select a random contact from the routing table and forward the message to that contact. Negotiating Storage ContractsWhen a node receives a contract proposal in the form of a PUBLISH message and that proposal meets the recipient's criteria, it can send an OFFER message to the original publisher. OFFERThe offer message must contain the original contract, supplemented with the information that is required of the offering node, which at minimum must include farmer_id, farmer_signature, and payment_destination. The *_signature property value should be the hex-encoded signature of the JSON string representation of the contract, minus both signature fields and with keys sorted alphanumerically. In addition to these fields, the offering node (or &quot;farmer&quot;) may modify the other fields in the contract to their liking if they wish to counter the original offer: { &quot;method&quot;: &quot;OFFER&quot;, &quot;params&quot;: { &quot;contract&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: null, &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The receiving node must check the offer and determine whether or not the modified contract terms are satisfactory. If so, it may finalize the contract by adding it's signature to the renter_signature field: { &quot;result&quot;: { &quot;contract&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: &quot;304402202ccc152ee81fbff7e802c290cabea0c62384bb12...&quot;, &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Alternatively, the receiving node may counter the offer by modifying any of the fields and returning those in the response. The farmer must check the contract against it's signature to determine if the terms of the contract have been changed. This counter offer loop can continue until one party abandons the offer loop or until both parties have signed the same contract. Once a contract has been finalized, each node should store a copy locally that can be keyed by the data_hash. Executing a Storage ContractOnce a storage contract has been signed by both parties, the renter may execute the terms of the contract by issuing a CONSIGN message to the farmer. The purpose of this message is to deliver the data referenced by the contract for the farmer to store. CONSIGNThe consign message must contain the hex-encoded data_shard itself, the contract_hash, as well as an audit_tree that contains the bottom leaves of the audit strategy's merkle tree (see Auditing a Storage Contract below). { &quot;method&quot;: &quot;CONSIGN&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;audit_tree&quot;: [ &quot;40a98e19c298631cba19d6c19691360ce08ccf36&quot;, &quot;02f0d971096305e797da9165cd50d4d1bb19590b&quot;, &quot;a44ad75d8aa118cdd73df77ae2543d3e87f94576&quot;, &quot;d84e8bfac28a98df418d0c3029f77a4d9f338e9e&quot;, &quot;7408bb5b0a9eefa56f3234fc83d2423f76c4b857&quot;, &quot;d1b71886c910d34b31cee9e23316abded9ef3fe0&quot;, &quot;0ac89686a12e26aaf952180c0fec5373224c4c1e&quot;, &quot;98c304116e7eb89839ff6c96202eb4c3cbdaf8e0&quot;, &quot;c7937b8a1be9da426e076eff70c5b4edf8a66270&quot;, &quot;c6c2c5cdafb99e4d62185d42e59522d15c33d676&quot;, &quot;1f87ca29e75944aa36e676b3ddf27e49a8ca4fe2&quot;, &quot;8585e356a517535b8a36ec9222b955c5b61a5227&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of a CONSIGN message, the farmer must lookup the reference contract by the supplied data_hash and verify that the renter is authorized to store the data and that the number of items in the audit_tree is equal to the next power of 2 of the audit_count supplied in the original contract. Once verified, the farmer must respond with a generated token that the renter or another authorized party can use to open a data channel with the farmer (via websocket) to deliver the data as a binary stream. For more information on the Data Channel specification see the tutorial for Transferring File Shards. In addition, the farmer should verify that the current UNIX time is greater than or equal to the agreed upon store_begin and less than the agreed upon store_end. If everything checks out, the farmer must store the consigned data in such a way that it may later be retrieved by it's hash. Once the farmer has done this, it must acknowledge the renter to confirm: { &quot;result&quot;: { &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Using Mirrors for RedundancyIn most cases it is desirable for the renter to store multiple copies of the shard across a number of farmers in the event that one of the contracted farmers leaves the network, loses the data, or otherwise breaches the terms of the storage contract. This can be accomplished by simply performing an iterative PUBLISH - OFFER - CONSIGN loop for the desired level of redundancy, followed by the establishment of a data channel as described in Transferring File Shards. However, this method can introduce a significant amount of latency for completing a full upload that increases linearly with the number of redundant shards. Additionally, the amount of bandwidth consumed by the renter increases in the same way as the renter will have to upload the data for each redundant shard. MIRRORIn these scenarios, renters can offload the burden of storing multiple copies of a shard to the farmers by issuing a MIRROR RPC in lieu of establishing a data channel. A MIRROR RPC instructs a contracted farmer to retrieve the data already uploaded to another farmer by providing them with a retrieval token authorized by another farmer (this is performed by issuing a RETRIEVE RPC message - see Downloading Consigned Data later in this document). This allows the renter to incur the bandwidth and latency once and instead pay the recently contracted farmer to transfer the data to another farmer for redundancy. To initiate this process, instead of opening a data channel, issue a MIRROR RPC message to the farmer after contract negotiation is complete: { &quot;method&quot;: &quot;MIRROR&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;token&quot;: &quot;ce898e520cede42fd847ba5176b6d6b6ea47481f&quot;, &quot;farmer&quot;: { &quot;address&quot;: &quot;remote.farmer.host&quot;, &quot;port&quot;: 4000, &quot;nodeID&quot;: &quot;e77e46ceb7f8dbf2904eff254a479f90a4f8ddbd&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; } Note that you should wait until data is successfully consigned to the first farmer before sending a MIRROR RPC for replication. Once the mirroring farmer receives the request, it should open a data channel to the original farmer and pass along the supplied token and data hash in the initial authorization frame. Once the mirroring farmer begins receiving data it must respond to the renter's request with a simple acknowledgement to indicate that the mirror operation was successfully initiated. { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; } Note that data transfer may fail after the original acknowledgement. It is important to regularly issue AUDIT messages to farmers storing your data. If a mirror farmer later fails an audit, the renter should negotiate a new contract and attempt to create a new mirror to retain the expected level of redundancy. Auditing a Storage ContractBefore a renter issues a CONSIGN RPC, it must pre-calculate a series of &quot;challenges&quot;, the number of which must equal the audit_count defined in the negotiated contract. A challenge is simply 32 random bytes encoded as hex. The generated challenges must not be shared until the renter wishes to issue an AUDIT request. When issuing a CONSIGN request, the renter must include an audit_tree which contains the bottom leaves of a merkle tree. Each of the bottom leaves of the tree must be equal to the double RIPEMD160(SHA256(challenge + shard)) encoded as hex. In order to ensure that the resulting merkle tree is properly &quot;balanced&quot;, the number of bottom leaves must be equal to the next power of 2 of the audit count. To ensure this, the additional leaves can simply be the double RIPEMD160(SHA256('')) (the same hash function for an audit, but applied to an empty buffer). AUDITTo audit a farmer is to request proof that it is still honoring the terms of the storage contract without the need to have them supply the entire data_shard. To do this, the renter must supply the farmer with one of the secret pre-calculated challenges: { &quot;method&quot;: &quot;AUDIT&quot;, &quot;params&quot;: { &quot;audits&quot;: [ { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;challenge&quot;: &quot;6290bb9e1766bf3fc00eea3bb14146925611026d453e1aa95c32973f8baa5c98&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of an AUDIT request, the farmer must lookup the data_shard by the supplied data_hash, then calculate the single RIPEMD160(SHA256(challenge + shard)). The result of this operation should hash again to match one of the items supplied in the audit_tree property of the original CONSIGN request. In addition to supplying this single-hashed value as proof that the farmer is still honoring the terms of the contract, the farmer must also provide the uncles required to rebuild the merkle tree. This proof response is specified as a series of nested JSON arrays: { &quot;result&quot;: { &quot;proofs&quot;: [ [[[ [[&quot;6a2f02144c461e178dc4496c263313e64d7a56ab&quot; ],&quot;efb0dfa48813e3289ba8d16e9e23cf1efa1a99fd&quot; ],&quot;dfb8877b84e7a7496a4b08b2aef6ffd02ccbfccc&quot; ],&quot;82c60f546bcaaabeb908c911b1fadb816e039409&quot; ],&quot;5e265b0256cd471c6af22bd66b59ed9242067654&quot;] ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }For clarification, given a simple merkle tree: +-- Hash_0 (Root) | +-- Hash_1 | | +-- Hash_3 | | +-- Hash_4 | +-- Hash_2 | | +-- Hash_5 | | +-- Hash_6 = RIPEMD160(SHA256(RIPEMD160(SHA256(challenge + shard))))The resulting format of a proof for an audit matching Hash_6 would appear as: [Hash_1, [Hash_5, [RIPEMD160(SHA256(challenge + shard))]]]And, the resulting format of a proof for an audit matching Hash_3 would appear as: [[[RIPEMD160(SHA256(challenge + shard))], Hash_5], Hash_2]Upon receipt of the farmer's proof, the renter must verify that the proof is valid by using it to rebuild the merkle tree. See Verification#verify for an implementation example. If the proof is verified successfully, then the renter is expected to issue a payment to the payment_destination defined in the original contract. The amount of the payment should be equal to: (payment_storage_price / audit_count) + (payment_download_price * downloads_since_last_audit)If the verification fails then the contract is null and no payment is required. Conversely, if the verification succeeds and the renter does not issue the payment in a timely manner, then the contract is also null and the farmer may decide to cease storage of the data. RETRIEVEWhen a renter wishes to retrieve data that is stored under contract, it can issue a RETRIEVE RPC message that includes the data_hash to the farmer storing the data: { &quot;method&quot;: &quot;RETRIEVE&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }After the recipient of the RETRIEVE message verifies the sender's signature it must lookup the storage contract by the supplied data_hash and verify that the sender is the party with which the contract was negotiated. If all tests pass, then the farmer must respond with a generated token to allow the renter to open a data channel (via websocket) to retrieve the data as a binary stream. After the data shard is delivered successfully, the farmer must increment it's record of the downloads_since_last_audit (which must be reset after the next audit). For more information on the Data Channel specification see the tutorial for Transferring File Shards. { &quot;result&quot;: { &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }In addition, the renter must check the integrity of the returned data_shard by calculating the hash and checking it against the expected data_hash. If the test fails, then this effectively a failed audit and the contract is null. Implemented SIPs SIP0003 Application Specific Triggers Ã— Search results Close "},"tutorial-renting-data.html":{"id":"tutorial-renting-data.html","title":"Tutorial: Renting Data to the Network","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Renting Data to the Network This tutorial covers the process for using StorjCORE to rent data to farmers on the network programmatically using a number of tools included in the library. This walkthrough should also serve as an overview for a number of the tools included in the library and how they work together. BootstrappingBefore we can join the network, we need to set up a few required components: KeyPair - for representing our identity on the network StorageAdapter - for persisting our contracts and shard metadata StorageManager - for managing our persistence layer Start by importing the storj module and instantiating these objects: var storj = require('storj'); var keypair = new storj.KeyPair(); var persistence = new storj.EmbeddedStorageAdapter('/path/to/datadir'); var manager = new storj.StorageManager(persistence);Now that we have a way of identifying ourselves to the network and keeping a record of our contracts, we can use the RenterInterface to join the network. var renter = new storj.RenterInterface({ keyPair: keypair, storageManager: manager, rpcAddress: 'ip.or.hostname', rpcPort: 1337 }); renter.join(function(err) { if (err) { return console.error('Failed to join the network'); } // CONTINUED IN NEXT EXAMPLE... });File PreparationNow that we have a connection to the network, we are ready to store some data. Before we can actually store the data, we need to get some information about the shards we need to store. We need to know: The hash of each shard that will be stored The size of each shard that will be stored The length of time we wish to store the data The number of audits we intend to issue over the life of the contract To get this information we need to process the file using a few more of the core components: FileDemuxer - for breaking the file into shards DataCipherKeyIv - for generating encryption key EncryptStream - for encrypting the shards Contract - for constructing the terms of the storage We will start by demultiplexing the file into several shard streams. Let's break our file into 6 shards. We will start by creating a FileDemuxer: var demuxer = new storj.FileDemuxer('/path/to/file');Now that we have prepared to shard a file, we need to set up event listeners on the demuxer for whenever a new shard stream is available. Once a shard stream is available, we need to encrypt it and calculate it's hash and size so we can create an appropriate Contract to offer the network. In addition we will write the encrypted shard to temporary storage so we don't have to process the file again when we are ready to transfer the data: var tmpdir = require('os').tmpdir(); var crypto = require('crypto'); var path = require('path'); demuxer.on('shard', function(shardStream) { var tmpName = path.join(tmpdir, crypto.randomBytes(6).toString('hex')); var tmpFile = fs.createWriteStream(tmpName); var key = new storj.DataCipherKeyIv('password', 'salt'); var encrypter = new storj.EncryptStream(key); var hasher = crypto.createHash('sha256'); var size = 0; encrypter.on('data', function(bytes) { hasher.update(bytes); size += bytes.length; }); tmpFile.on('finish', function() { // CONTINUED IN NEXT EXAMPLE... }); shardStream.pipe(encrypter).pipe(tmpFile); });Contract NegotiationWhen each shard is finished being encrypted and we know it's size and hash, it is time to create a Contract and offer it to the network. The example below is continued from inside the tmpFile.on('finish', callback) in the example above: var hash = utils.rmd160sha256(hasher.digest()); var contract = new storj.Contract({ renter_id: keypair.getNodeID(), data_size: size, data_hash: hash, store_begin: Date.now(), store_end: Date.now() + 604800000, // 7 days from now audit_count: 12 }); renter.getStorageOffer(contract, function(err, farmer, contract) { // CONTINUED IN NEXT EXAMPLE... });Now we have created a Contract for the shard and we are waiting for an offer from a farmer on the network. When we receive one, the callback supplied to RenterInterface#getStorageOffer above will trigger and we can proceed to transfer the shard to the farmer, but first we need to tell the farmer we are ready to transfer the shard to them and include the audit information they will need in the future. We will be using: AuditStream - for generating audit challenges and merkle tree StorageItem - for storing our private record of challenges Let's continue by reading the encrypted shard temporary file we just created and generating the challenges and merkle tree and saving a copy of the contract and associated challenges: var item = new storj.StorageItem({ hash: hash }); var auditGenerator = new storj.AuditStream(12); var encryptedShard = fs.createReadStream(tmpName); auditGenerator.on('finish', function() { item.addContract(farmer, contract); item.addAuditRecords(farmer, auditGenerator); manager.save(item, function(err) { if (err) { return console.error(err); } // CONTINUED IN NEXT EXAMPLE... }); }); encryptedShard.pipe(auditGenerator);Transferring ShardsNow that we have stored a copy of our contract and challenges, it's time to authorize a &quot;data channel&quot; (as described in Transferring File Shards) and transfer the shard to the farmer. We will be using: DataChannelClient - for opening the channel and transferring the data renter.getConsignToken(farmer, contract, auditGenerator, function(err, token) { if (err) { return console.error(err); } var client = new storj.DataChannelClient(farmer); var encryptedShard = fs.createReadStream(tmpName); client.on('open', function() { var datachannel = client.createWriteStream(token, hash); datachannel.on('finish', function() { // CONTINUED IN NEXT EXAMPLE }); encryptedShard.pipe(datachannel); }); });Remember that these operations for contract negotiation and shard transfer are taking place for each shard in the original file. You'll want to keep track of shards and their associated contracts by grouping references to them logically as the file that they compose. This is the responsibility of implementing clients. If you do not wish to manage this yourself, consider running a Bridge or using the Storj API. Replicating Shards for RedundancyOnce we have successfully consigned our data to a farmer, we can ensure that in the event that farmer disappears, our data can be recovered from elsewhere. We use mirrors to accomplish this. Mirroring is a method for passively replicating our data, meaning that instead of uploading it again, we instruct a new farmer to retrieve it from the location we already stored it. To do this we are going to need: DataChannelPointer - for representing the location of the shard We are also going to use the async module for managing flow control. First we'll need to negotiate a few more contracts, then authorize some retrieval tokens (outlined later in this document), and finally request some mirrors. var redundancy = 3; var mirrors = []; function _getMirroringContract(n, next) { renter.getStorageOffer(contract, function(err, mirror, contract) { renter.getRetrieveToken(farmer, contract, function(err, token) { if (err) { return next(err); } mirrors.push(mirror); next(null, new storj.DataChannelPointer(farmer, hash, token)); }); }); } async.timesSeries(redundancy, _getMirroringContract, function(err, sources) { if (err) { return console.error(err); } renter.getMirrorNodes(sources, mirrors, function(err, completed) { if (err) { return console.error('Failed to replicate to all mirrors'); } console.info('Replicated to %s mirrors', completed.length); }); });Auditing Farmer StorageNow that we have successfully consigned a shard, we will want to be sure that the farmer is being honest about storing it. We can verify this by requesting a proof using the challenges we generated previously. We will be using: Verification - for validating the farmer's challenge response var merkleRoot = auditGenerator.getPrivateRecord().root; var treeDepth = auditGenerator.getPrivateRecord().depth; renter.getStorageProof(farmer, item, function(err, proof) { if (err) { return console.error(err); } var verification = new storj.Verification(proof); var verifyResult = verification.verify(merkleRoot, treeDepth); if (verifyResult[0] !== verifyResult[1]) { return console.error('The proof is not valid'); } manager.save(item, function(err) { if (err) { return console.error(err); } // CONTINUED IN NEXT EXAMPLE }); });Retrieving ShardsNow that we have verified that the farmer is storing the shard, we know that we can later retrieve it when needed. The process for doing this is very similar to the process for storing the shard, only this time we'll be asking for a retrieval token and we will be receiving data over the data channel instead of sending. We'll also be using: DecryptStream - for decrypting the shard stream renter.getRetrieveToken(farmer, contract, function(err, token) { if (err) { return console.error(err); } var client = new storj.DataChannelClient(farmer); var decrypter = new storj.DecryptStream(keypair); var fileDestination = fs.createWriteStream('/path/to/download/shard'); client.on('open', function() { var download = client.createReadStream(token, hash); download.pipe(decrypter).pipe(fileDestination); }); fileDestination.on('finish', function() { console.info('Successfully downloaded shard!'); }); });This concludes the tutorial. To dive deeper, follow the reference links throughout this walkthrough and read the documentation on each of the classes used here. Ã— Search results Close "},"tutorial-tunnel-connections.html":{"id":"tutorial-tunnel-connections.html","title":"Tutorial: Tunnelling Connections","body":" Storj Core Modules storjstorj/constantsstorj/datachannel/errorsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/tunnel/errorsstorj/utilsstorj/version Classes AuditStreamBlacklistBridgeClientContactContactCheckerContractDataChannelClientDataChannelPointerDataChannelServerDataCipherKeyIvDecryptStreamEmbeddedStorageAdapterEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingMonitorNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterReadableDataChannelStreamRenterInterfaceStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderUploadStateVerificationWritableDataChannelStream Events AuditStream#event:finishDataChannelClient#event:errorDataChannelClient#event:openDataChannelServer#event:connectionDataChannelServer#event:errorDataChannelServer#event:shardDownloadedDataChannelServer#event:shardUploadedDecryptStream#event:dataDecryptStream#event:endEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateReadableDataChannelStream#event:dataReadableDataChannelStream#event:endReadableDataChannelStream#event:errorRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateStorageManager#event:lockedStorageManager#event:unlockedTunnelClient#event:closeTunnelClient#event:openTunnelDemuxer#event:dataTunnelerInterface#event:connectedTunnelerInterface#event:disconnectedTunnelerInterface#event:errorTunnelerInterface#event:readyTunnelerInterface#event:unhandledOfferTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlockedUploadState#event:killedWritableDataChannelStream#event:errorWritableDataChannelStream#event:finish Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Tunnelling Connections One of the most daunting problems to tackle when designing a stable and reliable distributed network is the traversal of various constraints such as NAT and firewalls. In some cases, software can use various strategies to &quot;punch out&quot; of these constraints and become publicly addressable on the Internet. The StorjCORE library makes use of these strategies, but when they fail we must devise more complex tactics for ensuring that network participants are reachable by their peers. The Storj protocol defines a series of RPC messages that can be exchanged in order to establish a &quot;tunnel&quot;. See the Protocol Specification for more detail on these RPC messages and their purposes. A tunnel is, in essence, a proxy that allows a client that is not exposed to the Internet to be addressable as if it were. This works by a private node opening a long-lived connection to a public node who establishes a dedicated means for accepting messages on behalf of the private node and &quot;pipes&quot; any data received via those means directly back to the private node over the previously established connection. Once a tunnel has been established, the private node can begin identifying herself to the network using her tunnel's address, instead of her own. Private nodes do not need to use the tunnel to contact other nodes on the network, but rather only to be contacted. Tunneling Diagram Announcing WillingnessWhen a node joins the network and is publicly addressable, it has the ability to announce to the network that it is willing and capable of tunneling connections on behalf on nodes who are private or unable to punch out to become addressable on the Internet. The process of doing this uses the same publish/subscribe system described in the Publishing Storage Contracts specification which enables nodes to maintain a view of subscriptions in their neighborhood of the network as described in the Protocol Specification. The difference between a contract publication and a tunnel announcement is in the opcode used for the topic and in the contents of the publication. Tunnel announcement publications use the opcode prefix 0x0e followed by a single criteria degree opcode to indicate their willingness to tunnel (0x00 to indicate &quot;I am no longer tunneling&quot; and 0x01 to indicate &quot;I am ready to tunnel&quot;). Whenever the condition changes, such as a node's maximum number of tunnels is reached or when a tunnel becomes available, it should issue a PUBLISH RPC message to it's nearest neighbors. { &quot;method&quot;: &quot;PUBLISH&quot;, &quot;params&quot;: { &quot;uuid&quot;: &quot;7f0c40a2-e465-4f3e-b617-3d53460e34f7&quot;, &quot;topic&quot;: &quot;0e01&quot;, &quot;contents&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337 }, &quot;publishers&quot;: [ &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; ], &quot;ttl&quot;: 1455228597837, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Public nodes should subscribe to these topics so that they can maintain an up-to-date list of nodes who are capable and willing to tunnel connections, so they can respond accurately to FIND_TUNNEL messages from private nodes. Establishing a TunnelAfter a private node has discovered some willing tunnels using the FIND_TUNNEL RPC message defined in the Protocol Specification, it can now begin the handshake to establish the tunnel. This begins by sending the OPEN_TUNNEL RPC message to the desired tunneler node. The recipient of OPEN_TUNNEL will check: Do I have enough remaining tunnels? (based on arbitrary limit set by node) Am I already tunneling for this nodeID? Has a payment channel been opened? (future spec) If the tunneling node has enough tunnels, is not already tunneling the node, and (in a future spec) if a payment channel has been opened for bandwidth, then the tunneling node opens a new dedicated HTTP/WS server on an available port that will be used by the requester as it's &quot;contact&quot; information included in RPC messages. Before responding to the OPEN_TUNNEL RPC, the tunneler must also generate a unique authorization token that will be appended to the query string of it's tunnel entry point and provided back to the requester. { &quot;result&quot;: { &quot;tunnel&quot;: &quot;ws://10.0.0.3:1337/tun?token=2bfb23f98e72&quot;, &quot;alias&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1338 }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Now the private node can connect to the tunnel URI provided and receive any messages sent to the alias contact information. Connecting to a TunnelOnce the OPEN_TUNNEL handshake is completed, the private node can establish a WebSocket connection to the tunneler, providing the token in the request's query string. Example (browser-based)var tunnel = new WebSocket('ws://10.0.0.3:1337/tun?token=2bfb23f98e72'); tunnel.addEventListener('open', function() { console.log('Tunnel established!'); }); tunnel.addEventListener('message', function(e) { console.log('Received tunneled message:', e.data); // Handle tunneled message here... });Handling Tunneled MessagesOnce the WebSocket tunnel has been opened and authorized, both the private node and the tunneling node have a bidirectional communication channel. RPC messages received by the tunnel to the dedicated entry point will be written to the tunnel and must be handled by the private node. RPC messages are sent with the WebSocket opcode 0x2 (binary) and must be parsed by the private node and then handled as if it were received directly. The binary chunk representing the RPC message must be prefixed with a special opcode (0x0c) indicating that it should be demuxed and handled as an RPC message. Once the tunneled message has been appropriately handled, the private node can instruct the tunnel to respond to the request by simply writing it's response message back to the tunnel using the same WebSocket opcode 0x2 (binary) with the appropriate 0x0c prefix. The tunneling node must parse the message and issue a response back to the originator of the message. Tunneled Shard TransferTransferring file shards through a tunnel is also carried out transparently from the perspective of the remote node. The remote node will negotiate a data channel via the appropriate RPC messages sent to the destination through the tunnel and use the resulting token and hash to open a data channel with the tunneler. The tunneler will use the existing WebSocket tunnel to it's private node to indicate the intent to establish a data channel by sending a special message called a &quot;signal&quot;. The SIGNAL message indicates to the private node's tunnel client that the tunnel server has established a data channel on it's behalf and will begin sending the received frames to the tunnel client. The SIGNAL message will simply include a unique identifier for the client to use for mux/demuxing subsequent frames in the case of multiple concurrent tunneled data channels. A SIGNAL message uses the WebSocket opcode 0x2 (binary), and prefixes the contained data with it's own opcode 0x0d. The prefix is followed by the WebSocket opcode sent by the originator to the tunnel server, which is followed by a quasi-unique 6 byte identifier assigned to the originator. For example, a tunnel client might receive a chunk of data that says &quot;hello world&quot; as part of a CONSIGN data channel: &lt;Buffer 0d 02 9d b4 a0 58 5f 31 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;In the above byte array, 0d indicates that this is a data channel signal, 02 indicates that the originator sent this data to the tunnel as binary, 9d b4 a0 58 5f 31 is the quasi-unique identifier for the originator so the client can demux the stream, and 68 65 6c 6c 6f 20 77 6f 72 6c 64 is the binary payload (in this case, &quot;hello world&quot;). When a tunnel client receives a SIGNAL message like this, it should check to see if it has already opened a local WebSocket connection to it's own data channel server. If it has not, it must open one using the quasi-unique identifier to track it, and writing any data in the signal to the socket using the WebSocket opcode included in the signal. The data channel server will also write back to the local WebSocket opened by the tunnel client, which is responsible for converting the data into the appropriate signal format and write the result back to the tunnel server. The tunnel server must then use the signal metadata to multiplex the streams out to their respective data channel originators. When the loopback data channel connection is terminated on the farmer side, a special message needs to be sent to the tunneler to indicate that the connection should be closed. In this case the tunneled node will send a JSON payload as the last frame that includes a code and message. This frame should be tagged as a textual frame to differentiate it from previous parts of the transferred data. An example of this JSON in the termination signal might be: {&quot;code&quot;:1000,&quot;message&quot;:&quot;Finished&quot;}So serialized in the multiplexed tunnel format, that would look like: &lt;Buffer 0d 01 9d b4 a0 58 5f 31 65 22 3a 22 46 69 6e 69 73 68 65 64 22 7d ... &gt;Reference TunnelClient TunnelServer TunnelMuxer TunnelDemuxer DataChannelClient DataChannelServer Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
