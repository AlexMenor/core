<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_audit-tools_audit-stream.js.html":{"id":"lib_audit-tools_audit-stream.js.html","title":"Source: lib/audit-tools/audit-stream.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/audit-tools/audit-stream.js 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var constants = require('../constants'); var MerkleTree = require('mtree'); var utils = require('../utils'); var stream = require('readable-stream'); var inherits = require('util').inherits; /** * Represents a streaming audit challenge generator * @constructor * @license LGPL-3.0 * @param {Number} audits - Total number of challenges to generate * @emits AuditStream#finish */ function AuditStream(audits) { if (!(this instanceof AuditStream)) { return new AuditStream(audits); } assert(typeof audits === 'number', 'Invalid number of audits supplied'); assert(!Number.isNaN(audits), 'Invalid number of audits supplied'); assert(Number.isFinite(audits), 'Invalid number of audits supplied'); this._audits = audits; this._finished = false; this._challenges = []; this._inputs = this._prepareChallenges(); stream.Writable.call(this); this.on('finish', this._generateTree.bind(this)); } /** * Triggered when the stream has ended * @event AuditStream#finish */ inherits(AuditStream, stream.Writable); /** * Returns the bottom leaves of the merkle tree for sending to farmer * @returns {Array} leaves - Bottom merkle leaves of audit tree */ AuditStream.prototype.getPublicRecord = function() { assert(this._finished, 'Challenge generation is not finished'); return this._tree.level(this._tree.levels() - 1) .map((i) =&gt; i.toString('hex')); }; /** * Returns the challenges, the tree depth, and merkle root * @returns {Object} challenge - Private audit record with challenges */ AuditStream.prototype.getPrivateRecord = function() { assert(this._finished, 'Challenge generation is not finished'); return { root: this._tree.root(), depth: this._tree.levels(), challenges: this._challenges.map((i) =&gt; i.toString('hex')) }; }; /** * Implements the underlying write method * @private */ AuditStream.prototype._write = function(bytes, encoding, next) { var self = this; this._inputs.forEach(function(input, i) { if (i &lt; self._audits) { input.update(bytes); } }); next(); }; /** * Prepares the challenge hasher instances * @private */ AuditStream.prototype._prepareChallenges = function() { var iterations = 0; var inputs = []; while (iterations &lt; this._audits) { var challenge = this._generateChallenge(); var input = this._createResponseInput(challenge); this._challenges.push(challenge); inputs.push(input); iterations++; } while (iterations &lt; utils.getNextPowerOfTwo(this._audits)) { inputs.push(utils.rmd160sha256b('')); iterations++; } return inputs; }; /** * Generate the audit merkle tree from a series of challenges * @private */ AuditStream.prototype._generateTree = function() { var self = this; this._finished = true; this._tree = new MerkleTree(this._inputs.map(function(input, i) { if (i &gt;= self._audits) { return input; } else { const rmd1 = crypto.createHash('rmd160').update(input.digest()).digest(); const sha = crypto.createHash('sha256').update(rmd1).digest(); const rmd2 = crypto.createHash('rmd160').update(sha).digest(); return rmd2; } }), utils.rmd160sha256b); }; /** * Generate a random challenge buffer * @private * @returns {String} Hex encoded random bytes */ AuditStream.prototype._generateChallenge = function() { return crypto.randomBytes(constants.AUDIT_BYTES); }; /** * Create a challenge response input to merkle tree * @private */ AuditStream.prototype._createResponseInput = function(challenge) { return crypto.createHash('sha256').update(challenge); }; /** * Returns a new instance from the predefined challenges and tree * @param {Array} challenges - The precomputed challenges * @param {Array} tree - The bottom leaves of the existing merkle tree * @returns {AuditStream} */ AuditStream.fromRecords = function(challenges, tree) { assert(Array.isArray(challenges), 'Invalid challenges supplied'); assert(Array.isArray(tree), 'Invalid tree supplied'); assert( tree.length === utils.getNextPowerOfTwo(challenges.length), 'Challenges and tree do not match' ); tree = tree.map((i) =&gt; Buffer.from(i, 'hex')); var auditor = new AuditStream(challenges.length); auditor._challenges = challenges; auditor._tree = new MerkleTree(tree, utils.rmd160sha256b); auditor._finished = true; return auditor; }; module.exports = AuditStream; Ã— Search results Close "},"lib_network_contact.js.html":{"id":"lib_network_contact.js.html","title":"Source: lib/network/contact.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/contact.js 'use strict'; var assert = require('assert'); var kad = require('kad'); var inherits = require('util').inherits; var version = require('../version'); var utils = require('../utils'); var url = require('url'); /** * Represents a Storj contact (or peer) * @constructor * @license LGPL-3.0 * @param {Object} contact * @param {String} contact.address - Hostname of IP address * @param {Number} contact.port - RPC port number * @param {String} contact.nodeID - 160 bit node ID (hex) * @param {String} [contact.hdKey] - extended hd public key * @param {String} [contact.hdIndex] - derivation index for node * @param {String} [contact.userAgent] - User agent identifier * @param {String} contact.protocol - Semver tag for compatibility */ function Contact(options) { if (!(this instanceof Contact)) { return new Contact(options); } this.userAgent = options.userAgent || version.software; this.protocol = options.protocol || version.protocol; if (options.hdKey) { assert(utils.isValidHDNodeKey(options.hdKey), 'hdKey is expected to be extended public key'); assert(utils.isValidNodeIndex(options.hdIndex), 'hdIndex is expected to be a non-hardened index'); this.hdKey = options.hdKey; this.hdIndex = options.hdIndex; } else { this.hdKey = undefined; this.hdIndex = undefined; } kad.contacts.AddressPortContact.call(this, options); } inherits(Contact, kad.contacts.AddressPortContact); /** * Indicates if URL is valid contact * @param {String} * @returns {Boolean} */ Contact.isValidUrl = function(uri) { let contact = null; try { contact = url.parse(uri); assert(contact.protocol === 'storj:', 'Invalid protocol'); assert( Buffer.from(contact.path.substr(1), 'hex').length * 8 === 160, 'Invalid node ID' ); assert( utils.isValidContact(Contact.fromUrl(uri), process.env.STORJ_ALLOW_LOOPBACK), 'Invalid contact data' ); } catch (err) { return false; } return true; }; /** * Returns a Storj contact from the URI * @private * @param {String} uri */ Contact.fromUrl = function(uri) { var parsed = url.parse(uri); return new Contact({ address: parsed.hostname, port: Number(parsed.port), nodeID: parsed.path.substr(1) }); }; module.exports = Contact; Ã— Search results Close "},"lib_contract_index.js.html":{"id":"lib_contract_index.js.html","title":"Source: lib/contract/index.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/contract/index.js 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var merge = require('merge'); var JSONSchema = require('jsen'); var stringify = require('json-stable-stringify'); var bitcore = require('bitcore-lib'); var constants = require('../constants'); var Message = require('bitcore-message'); var ms = require('ms'); /** * Represents a storage contract between a renter and a farmer * @constructor * @license AGPL-3.0 * @version 0 * @param {Object} contract * @param {String} contract.type - Unique identifier for the contract * @param {String} [contract.renter_hd_key] - Node extended public key in base58 * @param {Number} [contract.renter_hd_index] - Derivation index for signature * @param {String} contract.renter_id - Node ID of the renter * @param {String} contract.renter_signature - Renter's cryptographic signature * @param {String} contract.farmer_id - Node ID of the farmer * @param {String} contract.farmer_signature - Farmer's cryptographic signature * @param {Number} contract.data_size - Number of bytes to store * @param {String} contract.data_hash - RIPEMD-160 SHA-256 hash of the data * @param {Number} contract.store_begin - UNIX timestamp to start contract * @param {Number} contract.store_end - UNIX timestamp to end the contract * @param {Number} contract.audit_count - Number of audits renter will perform * @param {Number} contract.payment_storage_price - Total price for storage * @param {Number} contract.payment_download_price - Price per download * @param {String} contract.payment_destination - Bitcoin address to send funds * @param {Object} criteria * @param {Number} criteria.size - Criteria degree OPCODE * @param {Number} criteria.duration - Criteria degree OPCODE * @param {Number} criteria.availability - Criteria degree OPCODE * @param {Number} criteria.speed - Criteria degree OPCODE */ function Contract(contract, criteria) { if (!(this instanceof Contract)) { return new Contract(contract, criteria); } this._properties = merge(Object.create(Contract.DEFAULTS), contract); this._criteria = this._inferCriteria(criteria); this._clean(); assert.ok(this._validate(), 'Invalid contract specification was supplied'); } /** * Defines the JSON Schema of a {@link Contract} * @static */ Contract.Schema = require('./schema.json'); Contract.validate = JSONSchema(Contract.Schema); /** * Defines some default properties of a {@link Contract} * @static */ Contract.DEFAULTS = { version: 0, renter_hd_key: false, renter_hd_index: false, renter_id: null, renter_signature: null, farmer_id: null, farmer_signature: null, data_size: 1234, data_hash: null, store_begin: 2000000000, store_end: 3000000000, audit_count: 10, payment_storage_price: 0, payment_download_price: 0, payment_destination: null }; /** * Defines some default criteria of a {@link Contract} * @static */ Contract.CRITERIA = { size: constants.OPCODE_DEG_MED, duration: constants.OPCODE_DEG_MED, availability: constants.OPCODE_DEG_MED, speed: constants.OPCODE_DEG_MED }; /** * Defines the criteria matrix for a {@link Contract} * @static */ Contract.MATRIX = { size: function(size) { if (size &gt; 0 &amp;&amp; size &lt;= (32 * 1024 * 1024)) { return constants.OPCODE_DEG_LOW; } if (size &gt; (32 * 1024 * 1024) &amp;&amp; size &lt;= (512 * 1024 * 1024)) { return constants.OPCODE_DEG_MED; } if (size &gt; (512 * 1024 * 1024) &amp;&amp; size &lt;= (4096 * 1024 * 1024)) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, duration: function(duration) { if (duration &gt; 0 &amp;&amp; duration &lt;= ms('30d')) { return constants.OPCODE_DEG_LOW; } if (duration &gt; ms('30d') &amp;&amp; duration &lt;= ms('90d')) { return constants.OPCODE_DEG_MED; } if (duration &gt; ms('90d') &amp;&amp; duration &lt;= ms('320d')) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, availability: function(availability) { if (availability &gt;= 0.5 &amp;&amp; availability &lt;= 0.7) { return constants.OPCODE_DEG_LOW; } if (availability &gt; 0.7 &amp;&amp; availability &lt;= 0.9) { return constants.OPCODE_DEG_MED; } if (availability &gt; 0.9 &amp;&amp; availability &lt;= 1) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, speed: function(speed) { if (speed &gt; 0 &amp;&amp; speed &lt;= 6) { return constants.OPCODE_DEG_LOW; } if (speed &gt; 6 &amp;&amp; speed &lt;= 12) { return constants.OPCODE_DEG_MED; } if (speed &gt; 12 &amp;&amp; speed &lt;= 32) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; } }; /** * Removes all properties not in the schema from contract * @private * @param {Object} criteria - Criteria degree opcodes * @returns {Object} */ Contract.prototype._inferCriteria = function(criteria) { var opcodes = Object.create(Contract.CRITERIA); opcodes.size = Contract.MATRIX.size(this.get('data_size')); opcodes.duration = Contract.MATRIX.duration( this.get('store_end') - this.get('store_begin') ); // NB: Do not try to infer availability or speed, should be explicit return merge(opcodes, criteria); }; /** * Removes all properties not in the schema from contract * @private * @returns {Contract} self */ Contract.prototype._clean = function() { var keys = Object.keys(Contract.Schema.properties); for (var field in this._properties) { if (keys.indexOf(field) === -1) { delete this._properties[field]; } } return this; }; /** * Validates the contract specification * @private * @returns {Boolean} validity */ Contract.prototype._validate = function() { return Contract.validate(this._properties); }; /** * Checks if the contract is complete * @returns {Boolean} completed */ Contract.prototype.isComplete = function() { for (var prop in this._properties) { if (this._properties[prop] === null) { return false; } } return true; }; /** * Returns the string representation of the contract, minus the signature * fields, sorted alphanumerically for signing and verifying * @returns {String} */ Contract.prototype.getSigningData = function() { var sorted = this.toObject(); delete sorted.renter_signature; delete sorted.farmer_signature; return stringify(sorted); }; /** * Signs the contract as the given actor * @param {String} actor - One of 'farmer' or 'renter' * @param {Buffer} secret - ECDSA private key * @returns {String} signature */ Contract.prototype.sign = function(actor, secret) { return this.set(actor + '_signature', this.signExternal(secret)); }; /** * Verify the contract signature for the given actor * @param {String} actor - One of 'farmer' or 'renter' * @param {Buffer} pubkeyhash - ECDSA nodeID * @returns {Boolean} isValidSignature */ Contract.prototype.verify = function(actor, pubkeyhash) { return this.verifyExternal( this.get(actor + '_signature'), pubkeyhash ); }; /** * Signs the contract with the proved key and returns the signature * @param {String} secret - ECDSA private key * @returns {String} externalSignature */ Contract.prototype.signExternal = function(secret) { var message = Message(this.getSigningData()); return message.sign(bitcore.PrivateKey.fromString(secret)); }; /** * Verify the provided signature for the contract * @param {String} signature - The contract signature to verify * @param {String} pubkeyhash - ECDSA nodeID * @returns {Boolean} isValidSignature */ Contract.prototype.verifyExternal = function(signature, pubkeyhash) { if (!pubkeyhash) { return false; } var message = Message(this.getSigningData()); var address = bitcore.Address.fromPublicKeyHash(Buffer(pubkeyhash, 'hex')); try { return message.verify(address, signature); } catch (err) { return false; } }; /** * Applies the provided fields to the contract and validates it * @param {Object} fields - Contract properties to update * @returns {Contract} self */ Contract.prototype.update = function(fields) { for (var prop in fields) { this.set(prop, fields[prop]); } return this; }; /** * Returns the value for the given contract property * @param {String} field_name - Contract property to get * @returns {String|Number|null} value */ Contract.prototype.get = function(field_name) { return this._properties[field_name]; }; /** * Sets the contract property to the given value * @param {String} field_name - Contract property to get * @returns {String|Number|null} value */ Contract.prototype.set = function(field_name, field_value) { this._properties[field_name] = field_value; this._clean(); assert.ok(this._validate(), 'Invalid contract property supplied'); return this._properties[field_name]; }; /** * Calculates the SHA-256 hash of the serialized contract * @returns {Buffer} */ Contract.prototype.getHash = function() { return crypto.createHash('sha256').update(this.toBuffer()).digest(); }; /** * Return OPCODE byte sequence for contract publication topic * @returns {Buffer} */ Contract.prototype.getTopicBuffer = function() { return Contract.createTopic(this._criteria); }; /** * Return OPCODE byte sequence for contract publication topic as hex string * @returns {String} */ Contract.prototype.getTopicString = function() { return this.getTopicBuffer().toString('hex'); }; /** * Converts the contract to a plain object * @returns {Object} */ Contract.prototype.toObject = function() { return JSON.parse(this.toJSON()); }; /** * Converts the contract to JSON string * @returns {String} */ Contract.prototype.toJSON = function() { return stringify(this._properties); }; /** * Converts the contract to Buffer * @returns {Buffer} */ Contract.prototype.toBuffer = function() { return new Buffer(this.toJSON(), 'utf8'); }; /** * Creates a contract from a plain object * @param {Object} object - Dictionary of contract data * @returns {Contract} */ Contract.fromObject = function(object) { return new Contract(object); }; /** * Creates a contract from a JSON string * @param {String} json - JSON encoded contract * @returns {Contract} */ Contract.fromJSON = function(json) { return new Contract(JSON.parse(json)); }; /** * Creates a contract from a Buffer * @param {Buffer} buffer - Raw binary blob of contract data * @returns {Contract} */ Contract.fromBuffer = function(buffer) { return new Contract(JSON.parse(buffer.toString('utf8'))); }; /** * Create a topical OPCODE byte sequence from the provided criteria * @param {Object} criteria * @param {Number} criteria.size - Criteria degree OPCODE * @param {Number} criteria.duration - Criteria degree OPCODE * @param {Number} criteria.availability - Criteria degree OPCODE * @param {Number} criteria.speed - Criteria degree OPCODE * @returns {Buffer} */ Contract.createTopic = function(criteria) { criteria = merge(Object.create(Contract.CRITERIA), criteria); return new Buffer([ constants.OPCODE_CONTRACT_PREFIX, criteria.size, criteria.duration, criteria.availability, criteria.speed ]); }; /** * Compares two contracts against each other * @param {Contract} c1 - Contract to compare * @param {Contract} c2 - Contract to compare * @returns {Boolean} */ Contract.compare = function(c1, c2) { var contract1 = c1.toObject(); var contract2 = c2.toObject(); var ignored = [ 'renter_id', 'renter_signature', 'farmer_id', 'farmer_signature', 'payment_destination' ]; ignored.forEach(function(prop) { delete contract1[prop]; delete contract2[prop]; }); return JSON.stringify(contract1) === JSON.stringify(contract2); }; /** * Returns the property names between two contracts that differ * @param {Contract} c1 - Contract to compare * @param {contract} c2 - Contract to compare * @returns {String[]} changedProperties */ Contract.diff = function(c1, c2) { var differs = []; var contract1 = c1.toObject(); var contract2 = c2.toObject(); for (var prop in contract1) { if (contract1[prop] !== contract2[prop]) { differs.push(prop); } } return differs; }; module.exports = Contract; Ã— Search results Close "},"lib_storage_adapters_embedded.js.html":{"id":"lib_storage_adapters_embedded.js.html","title":"Source: lib/storage/adapters/embedded.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/adapters/embedded.js 'use strict'; var inherits = require('util').inherits; var StorageAdapter = require('../adapter'); var levelup = require('levelup'); var kfs = require('kfs'); var path = require('path'); var assert = require('assert'); var utils = require('../../utils'); var mkdirp = require('mkdirp'); /** * Implements an LevelDB/KFS storage adapter interface * @extends {StorageAdapter} * @param {String} storageDirPath - Path to store the level db * @constructor * @license AGPL-3.0 */ function EmbeddedStorageAdapter(storageDirPath) { if (!(this instanceof EmbeddedStorageAdapter)) { return new EmbeddedStorageAdapter(storageDirPath); } this._validatePath(storageDirPath); this._path = storageDirPath; this._db = levelup(path.join(this._path, 'contracts.db'), { maxOpenFiles: EmbeddedStorageAdapter.MAX_OPEN_FILES }); this._fs = kfs(path.join(this._path, 'sharddata.kfs')); this._isOpen = true; } EmbeddedStorageAdapter.SIZE_START_KEY = '0'; EmbeddedStorageAdapter.SIZE_END_KEY = 'z'; EmbeddedStorageAdapter.MAX_OPEN_FILES = 1000; inherits(EmbeddedStorageAdapter, StorageAdapter); /** * Validates the storage path supplied * @private */ EmbeddedStorageAdapter.prototype._validatePath = function(storageDirPath) { if (!utils.existsSync(storageDirPath)) { mkdirp.sync(storageDirPath); } assert(utils.isDirectory(storageDirPath), 'Invalid directory path supplied'); }; /** * Implements the abstract {@link StorageAdapter#_get} * @private * @param {String} key * @param {Function} callback */ EmbeddedStorageAdapter.prototype._get = function(key, callback) { var self = this; this._db.get(key, { fillCache: false }, function(err, value) { if (err) { return callback(err); } var result = JSON.parse(value); var fskey = result.fskey || key; self._fs.exists(fskey, function(err, exists) { if (err) { return callback(err); } function _getShardStreamPointer(callback) { var getStream = exists ? self._fs.createReadStream.bind(self._fs) : self._fs.createWriteStream.bind(self._fs); if (!exists) { fskey = utils.rmd160(key, 'hex'); result.fskey = fskey; } getStream(fskey, function(err, stream) { if (err) { return callback(err); } result.shard = stream; callback(null, result); }); } _getShardStreamPointer(callback); }); }); }; /** * Implements the abstract {@link StorageAdapter#_peek} * @private * @param {String} key * @param {Function} callback */ EmbeddedStorageAdapter.prototype._peek = function(key, callback) { this._db.get(key, { fillCache: false }, function(err, value) { if (err) { return callback(err); } callback(null, JSON.parse(value)); }); }; /** * Implements the abstract {@link StorageAdapter#_put} * @private * @param {String} key * @param {Object} item * @param {Function} callback */ EmbeddedStorageAdapter.prototype._put = function(key, item, callback) { var self = this; item.shard = null; // NB: Don't store any shard data here item.fskey = utils.rmd160(key, 'hex'); self._db.put(key, JSON.stringify(item), { sync: true }, function(err) { if (err) { return callback(err); } callback(null); }); }; /** * Implements the abstract {@link StorageAdapter#_del} * @private * @param {String} key * @param {Function} callback */ EmbeddedStorageAdapter.prototype._del = function(key, callback) { var self = this; var fskey = key; self._peek(key, function(err, item) { if (!err &amp;&amp; item.fskey) { fskey = item.fskey; } self._db.del(key, function(err) { if (err) { return callback(err); } self._fs.unlink(fskey, function(err) { if (err) { return callback(err); } callback(null); }); }); }); }; /** * Implements the abstract {@link StorageAdapter#_flush} * @private * @param {Function} callback */ EmbeddedStorageAdapter.prototype._flush = function(callback) { this._fs.flush(callback); }; /** * Implements the abstract {@link StorageAdapter#_size} * @private * @param {String} [key] * @param {Function} callback */ EmbeddedStorageAdapter.prototype._size = function(key, callback) { var self = this; if (typeof key === 'function') { callback = key; key = null; } this._db.db.approximateSize( EmbeddedStorageAdapter.SIZE_START_KEY, EmbeddedStorageAdapter.SIZE_END_KEY, function(err, contractDbSize) { if (err) { return callback(err); } function handleStatResults(err, stats) { if (err) { return callback(err); } var kfsUsedSpace = stats.reduce(function(stat1, stat2) { return { sBucketStats: { size: stat1.sBucketStats.size + stat2.sBucketStats.size } }; }, { sBucketStats: { size: 0 } }).sBucketStats.size; callback(null, kfsUsedSpace, contractDbSize); } /* istanbul ignore if */ if (key) { self._fs.stat(utils.rmd160(key, 'hex'), handleStatResults); } else { self._fs.stat(handleStatResults); } } ); }; /** * Implements the abstract {@link StorageAdapter#_keys} * @private * @returns {ReadableStream} */ EmbeddedStorageAdapter.prototype._keys = function() { return this._db.createKeyStream(); }; /** * Implements the abstract {@link StorageAdapter#_open} * @private * @param {Function} callback */ EmbeddedStorageAdapter.prototype._open = function(callback) { var self = this; if (!this._isOpen) { return this._db.open(function(err) { if (err) { return callback(err); } self._isOpen = true; callback(null); }); } callback(null); }; /** * Implements the abstract {@link StorageAdapter#_close} * @private * @param {Function} callback */ EmbeddedStorageAdapter.prototype._close = function(callback) { var self = this; if (this._isOpen) { return this._db.close(function(err) { if (err) { return callback(err); } self._isOpen = false; callback(null); }); } callback(null); }; module.exports = EmbeddedStorageAdapter; Ã— Search results Close "},"lib_storage_adapter.js.html":{"id":"lib_storage_adapter.js.html","title":"Source: lib/storage/adapter.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/adapter.js 'use strict'; var stream = require('readable-stream'); var assert = require('assert'); var Item = require('./item'); var EventEmitter = require('events').EventEmitter; var inherits = require('util').inherits; var StorageItem = require('./item'); /** * Abstract base class for storage adapter * @constructor * @license AGPL-3.0 */ function StorageAdapter() { if (!(this instanceof StorageAdapter)) { return new StorageAdapter(); } EventEmitter.call(this); } /** * Triggered when the adapter is ready * @event StorageAdapter#ready */ /** * Triggered when a new item is added * @event StorageAdapter#add * @param {StorageItem} item */ /** * Triggered when an item is deleted * @event StorageAdapter#delete * @param {StorageItem} item */ /** * Triggered when an existing item is updated * @event StorageAdapter#update * @param {StorageItem} itemBeforeUpdate * @param {StorageItem} itemAfterUpdate */ inherits(StorageAdapter, EventEmitter); /** * Calls the implemented {@link StorageAdapter#_get} and validates the result * @param {String} key - Shard hash to get metadata for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.get = function(key, callback) { assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); return this._get(key, function(err, result) { if (err) { return callback(err); } callback(null, new StorageItem(result)); }); }; /** * Calls the implemented {@link StorageAdapter#_peek} and validates the result * @param {String} key - Shard hash to get metadata for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.peek = function(key, callback) { assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); return this._peek(key, function(err, result) { if (err) { return callback(err); } callback(null, new StorageItem(result)); }); }; /** * Calls the implemented {@link StorageAdapter#_put} and validates the input * @param {StorageItem} item - Item to write to storage * @param {Function} callback - Called on complete write */ StorageAdapter.prototype.put = function(item, callback) { var self = this; assert(item instanceof Item, 'Invalid storage item supplied'); assert(typeof callback === 'function', 'Callback function must be supplied'); item.updateTimestamp(); return this.peek(item.hash, function(doesNotExist, existingItem) { self._put(item.hash, item.toObject(), function(err) { if (err) { return callback(err); } if (doesNotExist) { self.emit('add', item); } else { self.emit('update', existingItem, item); } callback(null); }); }); }; /** * Calls the implemented {@link StorageAdapter#_del} * @param {String} key - Shard hash to delete the data for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.del = function(key, callback) { var self = this; assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); this.peek(key, function(err, item) { if (err) { return callback(err); } return self._del(key, function(err) { if (err) { return callback(err); } self.emit('delete', item); callback(null); }); }); }; /** * Calls the implemented {@link StorageAdapter#_size} * @param {String} [key] - Optional file key * @param {Function} callback - Called with error or number of bytes stored */ StorageAdapter.prototype.size = function(/* [,key] callback */) { return this._size.apply(this, arguments); }; /** * Calls the implemented {@link StorageAdapter#_flush} * @param {Function} callback - Called with error or null */ StorageAdapter.prototype.flush = function(callback) { assert(typeof callback === 'function', 'Callback function must be supplied'); return this._flush(callback); }; /** * Calls the implemented {@link StorageAdapter#_keys} and returns a readable * stream containing each stored item * @return {ReadableStream} */ StorageAdapter.prototype.createReadStream = function() { return this._keys().pipe(new stream.Transform({ objectMode: true, transform: (key, enc, next) =&gt; { this.peek(key.toString(), next); }, flush: (done) =&gt; done() })); }; /** * Performs lookup and provides an {@link StorageItem} to the callback * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._flush = function(/* callback */) { throw new Error('Method not implemented'); }; /** * Performs lookup and provides an {@link StorageItem} to the callback * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._get = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Performs lookup and provides an {@link StorageItem} to the callback but does * not initialize any shard read/write stream * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._peek = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Delete the shard data at the given key * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._del = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Stores the {@link StorageItem} * @abstract * @param {String} key - Shard hash * @param {Item} item - Item to store * @param {Function} callback - Called on complete */ StorageAdapter.prototype._put = function(/* item, callback */) { throw new Error('Method not implemented'); }; /** * Returns the hashes of all shards stored * @abstract * @returns {ReadableStream} */ StorageAdapter.prototype._keys = function() { throw new Error('Method not implemented'); }; /** * Returns the number of bytes stored * @abstract * @param {Function} callback - Called on complete */ StorageAdapter.prototype._size = function(/* callback */) { throw new Error('Method not implemented'); }; /** * Opens the storage adapter * @abstract * @param {Function} callback - Called on complete */ StorageAdapter.prototype._open = function(callback) { callback(null); }; /** * Closes the storage adapter * @abstract * @param {Function} callback - Called on complete */ StorageAdapter.prototype._close = function(callback) { callback(null); }; module.exports = StorageAdapter; Ã— Search results Close "},"lib_exchange-report.js.html":{"id":"lib_exchange-report.js.html","title":"Source: lib/exchange-report.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/exchange-report.js 'use strict'; var assert = require('assert'); /** * Represents a report to a bridge regarding the result of a shard exchange * @constructor * @param {Object} options * @param {String} options.reporterId * @param {String} [options.farmerId] * @param {String} [options.clientId] */ function ExchangeReport(options = {}) { /* eslint complexity: [2, 7] */ if (!(this instanceof ExchangeReport)) { return new ExchangeReport(options); } assert(options.reporterId, 'Invalid reporterId'); this._r = { dataHash: options.dataHash || null, reporterId: options.reporterId, farmerId: options.farmerId, clientId: options.clientId, exchangeStart: options.exchangeStart || null, exchangeEnd: options.exchangeEnd || null, exchangeResultCode: options.exchangeResultCode || null, exchangeResultMessage: options.exchangeResultMessage || null }; } ExchangeReport.SUCCESS = 1000; ExchangeReport.FAILURE = 1100; /** * Starts recording duration of exchange * @param {String} dataHash - The shard hash as reference */ ExchangeReport.prototype.begin = function(dataHash) { assert(dataHash, 'You must supply a dataHash to begin an exchange report'); this._r.dataHash = dataHash; this._r.exchangeStart = Date.now(); }; /** * Ends the recording time a set result code and message * @param {Number} resultCode - Exchange result code * @param {String} resultMessage - Exchange result message */ ExchangeReport.prototype.end = function(resultCode, resultMessage) { assert(resultCode, 'You must supply a result code'); assert(resultMessage, 'You must supply a result message'); this._r.exchangeEnd = Date.now(); this._r.exchangeResultCode = resultCode; this._r.exchangeResultMessage = resultMessage; }; /** * Returns a plain report object * @returns {Object} */ ExchangeReport.prototype.toObject = function() { return JSON.parse(JSON.stringify(this._r)); }; module.exports = ExchangeReport; Ã— Search results Close "},"lib_network_farmer.js.html":{"id":"lib_network_farmer.js.html","title":"Source: lib/network/farmer.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/farmer.js 'use strict'; const async = require('async'); const assert = require('assert'); const secp256k1 = require('secp256k1'); const https = require('https'); const http = require('http'); const crypto = require('crypto'); const kfs = require('kfs'); const path = require('path'); const kad = require('kad'); const Network = require('./'); const url = require('url'); const inherits = require('util').inherits; const StorageItem = require('../storage/item'); const Contract = require('../contract'); const merge = require('merge'); const constants = require('../constants'); const diskusage = require('diskusage'); const utils = require('../utils'); const {execFile} = require('child_process'); const du = require('du'); /** * Creates and a new farmer interface * @constructor * @license AGPL-3.0 * @extends {Network} * @param {Object} options * @param {String} options.paymentAddress - Optional payment address * @param {Array} options.opcodeSubscriptions - Contract opcodes to farm * @param {Number} options.maxOfferConcurrency - Max offers to have pending * @param {FarmerInterface~negotiator} options.contractNegotiator * @param {KeyPair} options.keyPair - Node's cryptographic identity * @param {StorageManager} options.storageManager - Storage manager backend * @param {String} options.bridges - An array of bridges to connect and accept contracts * @param {Object} options.logger - Logger instance * @param {Array} options.seedList - List of seed URIs to join * @param {String} options.rpcAddress - Public node IP or hostname * @param {Number} options.rpcPort - Listening port for RPC * @param {Boolean} options.doNotTraverseNat - Skip NAT traversal strategies * @param {Number} options.maxTunnels - Max number of tunnels to provide * @param {Number} options.tunnelServerPort - Port for tunnel server to use * @param {Object} options.tunnelGatewayRange * @param {Number} options.tunnelGatewayRange.min - Min port for gateway binding * @param {Number} options.tunnelGatewayRange.max - Max port for gateway binding * @param {Number} [options.offerBackoffLimit=4] - Do not send offers if more * than N transfers are active * @param {Object} [options.joinRetry] * @param {Number} [options.joinRetry.times] - Times to retry joining net * @param {Number} [options.joinRetry.interval] - MS to wait before retrying * @param {Number} [options.maxShardSize] - Max number of bytes to allow as contract shard size * @emits Network#ready * @property {KeyPair} keyPair * @property {StorageManager} storageManager * @property {kad.Node} node - The underlying DHT node * @property {TriggerManager} triggerManager * @property {Contact} contact * @property {Transport} transportAdapter * @property {kad.Router} router - The underlying DHT router * @property {DataChannelServer} dataChannelServer */ // eslint-disable-next-line max-statements function FarmerInterface(options) { if (!(this instanceof FarmerInterface)) { return new FarmerInterface(options); } options = merge.recursive(Object.create(FarmerInterface.DEFAULTS), options); this._contractCount = 0; this._dataReceivedCount = 0; this._negotiator = options.contractNegotiator; this._pendingOffers = []; this._offerBackoffLimit = options.offerBackoffLimit; this._maxShardSize = options.maxShardSize; assert(options.storagePath, 'storagePath is expected option'); Network.call(this, options); // Give warnings for deprecated configuration options this._deprecatedConfigV1(options); this._mapBridges(this._options.bridges); this._connectBridgesRunnning = false; this._connectBridgesInterval = null; this.spaceAvailable = true; if (options.spaceAvailable !== undefined) { this.spaceAvailable = options.spaceAvailable; } // Connecting the dots. Note: We should organize this better // so that it's not necesarry to set these after they // have been constructed. this._protocol.handleAlloc = this.handleAlloc.bind(this); this.transport.shardServer.farmerInterface = this; } inherits(FarmerInterface, Network); FarmerInterface.CONNECT_BRIDGE_INTERVAL = 10000; FarmerInterface.CHECK_SPACE_USED_INTERVAL = 86400000; FarmerInterface.FREE_SPACE_PADDING = 262144000; FarmerInterface.prototype._deprecatedConfigV1 = function(options) { if (options.renterWhitelist) { this._logger.warn('config renterWhitelist is deprecated, ' + 'please use bridges config instead'); } if (options.bridgeUri) { this._logger.warn('config bridgeUri is deprecated, please ' + 'use bridges config instead'); } if (options.renterWhitelist &amp;&amp; options.bridges) { this._logger.warn('config renterWhitelist and bridges are mutually ' + 'exclusive, bridges config used only'); } if (options.bridgeUri &amp;&amp; options.bridges) { this._logger.warn('config bridgeUri and bridges are mutually exclusive, ' + 'bridges config used only'); } } FarmerInterface.prototype.isBridgeConnected = function(contract) { if (!this.bridges) { this._logger.debug('no bridges are connected'); return false; } var isConnected = this.bridges.has(contract.get('renter_hd_key')); this._logger.debug('contract is associated with connected bridge: %s', isConnected); if (!isConnected) { return false; } return true; } /** * Called when a contract is found that meets subscription criteria and allows * us to modify the contract terms if we desire and then uses the return value * to determine if we should send the renter an offer * @callback FarmerInterface~negotiator * @param {Contract} contract - The contract object to negotiate * @returns {Boolean} */ // eslint-disable-next-line max-statements FarmerInterface.Negotiator = function(contract, callback) { /* eslint complexity: [2, 7] */ var self = this; const dataSize = contract.get('data_size'); if (this._maxShardSize &amp;&amp; this._maxShardSize &lt; dataSize) { return callback(false); } if (!this.isBridgeConnected(contract)) { return callback(false); } if (!contract.get('data_hash')) { self._logger.warn('contract received with invalid data_hash, ignoring'); return callback(false); } // NB: Backoff on sending offers if we are already have high active transfer var concurrentTransfer = ( self.transport.shardServer.activeTransfers &gt;= self._offerBackoffLimit ); self._logger.debug( 'active transfers %s is less than offerBackoffLimit %s: %s', self.transport.shardServer.activeTransfers, self._offerBackoffLimit, !concurrentTransfer ); if (concurrentTransfer) { self._logger.warn('too many active transfers, not sending offer'); return callback(false); } // Check that there is disk space available // TODO: This can be removed when there is better shard usage tracking diskusage.check(this._options.storagePath, (err, info) =&gt; { if (err) { self._logger.warn('unable to check disk usage for free space'); return callback(false); } if (info.available - dataSize &lt;= FarmerInterface.FREE_SPACE_PADDING) { self._logger.warn('disk space is at maximum capacity'); self.noSpaceLeft(true); return callback(false); } // NB: Only bid on contracts for data we don't have this.storageManager.load(contract.get('data_hash'), function(err, item) { if (err) { self._logger.debug('no storage item available for this shard'); return callback(true); } var renters = Object.keys(item.contracts); if (renters.indexOf(contract.get('renter_id')) === -1) { self._logger.debug('no contract currently staged for this shard'); return callback(true); } if (typeof item.shard.write === 'function') { self._logger.debug('no data currently stored for this shard'); return callback(true); } self._logger.debug('shard already stored, not sending offer'); callback(false); }); }); }; FarmerInterface.DEFAULTS = { paymentAddress: '', opcodeSubscriptions: ['0f01020202', '0f02020202', '0f03020202'], contractNegotiator: FarmerInterface.Negotiator, maxOfferConcurrency: constants.MAX_CONCURRENT_OFFERS, offerBackoffLimit: 4 }; /** * Wraps the super call to {@link Network#join} to listen for contract after * successfully establishing a connection to the network * @param {Function} callback - Called on successful join */ FarmerInterface.prototype.join = function(callback) { var self = this; Network.prototype.join.call(this, function(err) { if (err) { return callback(err); } self._listenForContracts(self._options.opcodeSubscriptions); self.on( 'connected', self._listenForContracts.bind(self, self._options.opcodeSubscriptions) ); /* istanbul ignore next*/ self.transport.shardServer.on('shardUploaded', function(){ if (self._dataReceivedCount &lt; Number.MAX_SAFE_INTEGER) { self._dataReceivedCount++; } else { self._dataReceivedCount = 0; } }); callback(); }); }; FarmerInterface.prototype._mapBridges = function(bridges) { this.bridges = new Map(); for (let i = 0; i &lt; bridges.length; i++) { this.bridges.set(bridges[i].extendedKey, { url: bridges[i].url, extendedKey: bridges[i].extendedKey, connected: false }); } }; FarmerInterface.prototype._connectBridges = function() { if (this._connectBridgesRunning) { return; } this._connectBridgesRunning = true; this.emit('bridgesConnecting'); async.eachSeries(this.bridges.values(), (bridge, next) =&gt; { if (bridge.connected) { return next(); } this.emit('bridgeConnecting', bridge); this._connectBridge(bridge, (err) =&gt; { if (err) { this._logger.error('Unable to connect to bridge: %s, reason: %s', bridge.url, err.message); return next(); } this.bridges.get(bridge.extendedKey).connected = true; this.emit('bridgeConnected', bridge); this._logger.info('Connected to bridge: %s', bridge.url); next(); }); }, (err) =&gt; { this._connectBridgesRunning = false; if (err) { return this._logger.error('Unable to connect to bridges'); } this.emit('bridgesConnected'); }); } /** * Will connect to configured bridges to start receiving storage * contracts from them. If the contact is already at the bridge it will * update the contact details, otherwise it will add the contact to * and begin the benchmarking phase. */ FarmerInterface.prototype.connectBridges = function() { this._connectBridges(); this._connectBridgesInterval = setInterval( this._connectBridges.bind(this), FarmerInterface.CONNECT_BRIDGE_INTERVAL ); }; /** * Mark if there is space available for accepting offers */ FarmerInterface.prototype.runSpaceCheck = function() { this._runSpaceCheck(); this._spaceCheckInterval = setInterval( this._runSpaceCheck.bind(this), FarmerInterface.CHECK_SPACE_USED_INTERVAL ); } FarmerInterface.prototype._runSpaceCheck = function() { du(this._options.storagePath, { filter: function(f) { return f.indexOf('contracts.db') !== -1 || f.indexOf('sharddata.kfs') !== -1; } }, (err, size) =&gt; { if (err) { return this._logger.error(err); } if (size &gt;= this.storageManager._options.maxCapacity) { this.noSpaceLeft(true); } else { this.noSpaceLeft(false); } }); } /** * This will change the state of the farmer so that it will stop receiving * messages to store data. */ FarmerInterface.prototype.noSpaceLeft = function(noSpace) { if (this.spaceAvailable === !noSpace) { return; } this.spaceAvailable = !noSpace; let keys = this.bridges.keys(); for (let i = 0; i &lt; keys.length; i++) { // Set to false so that the contact will be updated this.bridges.get(keys[i]).connected = false; } }; FarmerInterface.prototype._connectBridge = function(bridge, callback) { let headers = {}; let body = {}; let path = '/contacts/' + this.contact.nodeID; this.bridgeRequest(bridge.url, 'GET', path, headers, body, (err, contact) =&gt; { if (err &amp;&amp; err.statusCode !== 404) { return callback(err); } else if (err &amp;&amp; err.statusCode === 404) { return this._addBridgeContact(bridge, callback); } if (contact.address !== this.contact.address || contact.port !== this.contact.port || contact.spaceAvailable !== this.spaceAvailable || contact.protocol !== this.contact.protocol) { this._updateBridgeContact(bridge, callback); } else { callback(); } }); } FarmerInterface.prototype._addBridgeContact = function(bridge, callback) { let target = null; let challenge = null; let nonce = null; async.series([ (next) =&gt; { let headers = {}; let body = {}; let path = '/contacts/challenges'; this.bridgeRequest( bridge.url, 'POST', path, headers, body, (err, data) =&gt; { if (err) { return callback(err); } target = data.target; challenge = data.challenge; next(); } ); }, (next) =&gt; { this._completeChallenge(challenge, target, (err, _nonce) =&gt; { if (err) { return next(err); } nonce = _nonce; next(); }); }, (next) =&gt; { let path = '/contacts'; let headers = { 'x-challenge': challenge, 'x-challenge-nonce': nonce }; let body = { address: this.contact.address, port: this.contact.port, spaceAvailable: true, protocol: this.contact.protocol } this.bridgeRequest(bridge.url, 'POST', path, headers, body, next); } ], callback); } FarmerInterface.prototype._updateBridgeContact = function(bridge, callback) { const headers = {}; const body = { address: this.contact.address, port: this.contact.port, spaceAvailable: this.spaceAvailable, protocol: this.contact.protocol }; this.bridgeRequest(bridge.url, 'PATCH', '/contacts/' + this.contact.nodeID, headers, body, callback) } FarmerInterface.prototype._completeChallenge = function(challenge, target, callback) { const powScript = path.resolve(__dirname, './pow.js'); const args = [ powScript, JSON.stringify({challenge: challenge, target: target}) ]; const options = { timeout: 900000 }; this.emit('bridgeChallenge'); /* eslint no-unused-vars:0 */ execFile(process.execPath, args, options, (err, stdout, stderr) =&gt; { if (err) { return callback(err); } let nonce = parseInt(stdout); if (!Number.isSafeInteger(nonce)) { return callback(null, new Error('Unexpected nonce')); } callback(null, nonce); }); } /* eslint max-params:0 */ FarmerInterface.prototype._getSigHash = function(bridgeUrl, method, path, timestamp, rawbody) { const hasher = crypto.createHash('sha256'); hasher.update(method); hasher.update(bridgeUrl + path); hasher.update(timestamp.toString()); hasher.update(rawbody); return hasher.digest(); } /* eslint max-params:0 */ // eslint-disable-next-line max-statements FarmerInterface.prototype.bridgeRequest = function(bridgeUrl, method, path, headers, body, callback) { const urlObj = url.parse(bridgeUrl); const timestamp = Date.now(); const rawbody = JSON.stringify(body); const sighash = this._getSigHash(bridgeUrl, method, path, timestamp, rawbody); const privkey = Buffer.from(this.keyPair.getPrivateKeyPadded(), 'hex'); const sigObj = secp256k1.sign(sighash, privkey); const sig = secp256k1.signatureExport(sigObj.signature).toString('hex'); headers['x-node-timestamp'] = timestamp; headers['x-node-id'] = this.contact.nodeID; headers['x-node-signature'] = sig; headers['x-node-pubkey'] = this.keyPair.getPublicKey(); headers['content-type'] = 'application/json'; headers['content-length'] = Buffer.byteLength(rawbody); const options = { headers: headers, method: method, path: path, hostname: urlObj.hostname, port: parseInt(urlObj.port) }; let proto = null; if (urlObj.protocol === 'https:') { proto = https; } else if (urlObj.protocol === 'http:') { proto = http; } else { return callback(new Error('Unsupported protocol')); } const req = proto.request(options, (res) =&gt; { let str = ''; let json = null; if (res.statusCode &gt;= 400) { let error = new Error('Bridge request failed (' + res.statusCode + ')'); error.statusCode = res.statusCode; return callback(error); } res.setEncoding('utf8'); res.on('data', (chunk) =&gt; { str += chunk.toString(); }); res.on('end', () =&gt; { try { json = JSON.parse(str); } catch (err) { callback(new Error('Unable to parse response')); } callback(null, json); }); }); req.on('error', callback); req.write(rawbody); req.end(); } /** * Sends the given contract as an offer to the specified renter * @private * @param {Contract} contract - The contract to include in offer * @param {Contact} renter - The renter who originally published the contract */ FarmerInterface.prototype._sendOfferForContract = function(contract, contact) { var self = this; var message = new kad.Message({ method: 'OFFER', params: { contract: contract.toObject(), contact: self.contact } }); self._logger.debug('Sending offer for contract hash %s', contract.get('data_hash')); self._removeContractFromPendingList(contract); self.transport.send(contact, message, function(err, response) { if (err) { return self._logger.warn(err.message); } if (response.error || !response.result.contract) { return self._logger.warn( response.error ? response.error.message : 'Renter refused to sign' ); } self._handleOfferRes(response, contract, contact); }); }; /** * Returns the payment address supplied or the derived one from keypair * @returns {String} */ FarmerInterface.prototype.getPaymentAddress = function() { return this._options.paymentAddress || this.keyPair.getAddress(); }; /** * Handles a received contract and negotiates storage * @private * @param {Contract} contract */ FarmerInterface.prototype._negotiateContract = function(contract, contact) { var self = this; contract.set('farmer_id', self.keyPair.getNodeID()); contract.set('payment_destination', self.getPaymentAddress()); contract.sign('farmer', self.keyPair.getPrivateKeyPadded()); var item = new StorageItem({ hash: contract.get('data_hash') }); var renterId = contract.get('renter_id'); if (typeof renterId !== 'string') { self._removeContractFromPendingList(contract); return self._logger.warn('dropping invalid contract with no renter id'); } item.addContract({ nodeID: renterId }, contract); item.addMetaData({ nodeID: renterId }, {}); self.storageManager.save(item, function(err) { if (err) { self._removeContractFromPendingList(contract); return self._logger.error(err.message); } self._sendOfferForContract(contract, contact); }); }; /** * Checks if we should send an offer by checking the pending offers and running * the optional custom negotiator function * @private * @param {Contract} contract * @param {Function} callback */ FarmerInterface.prototype._shouldSendOffer = function(contract, callback) { var self = this; if (!this.spaceAvailable) { self._logger.debug('No space available to accept offer'); return callback(false); } this._negotiator.call(this, contract, function(shouldNegotiate) { /* eslint max-statements: [2, 16] */ self._logger.debug('negotiator returned: %s', shouldNegotiate); self.storageManager._storage.size( contract.get('data_hash'), function(err, usedSpace, contractDBSize) { if (err) { self._logger.error('Could not get usedSpace: %s',err.message); return callback(false); } var maxCapacity = self.storageManager._options.maxCapacity; var estimatedMaxBucketSize = Math.floor( (maxCapacity - contractDBSize) / kfs.constants.B ); var freeSpace = estimatedMaxBucketSize - usedSpace; var enoughFreeSpace = contract.get('data_size') &lt;= freeSpace; self._logger.debug( 'max KFS bucket size %s, used %s, free %s, shard size %s', estimatedMaxBucketSize, usedSpace, freeSpace, contract.get('data_size')); self._logger.debug('we have enough free space: %s', enoughFreeSpace); callback(shouldNegotiate &amp;&amp; enoughFreeSpace); } ); }); }; /** * Adds the contract data hash to the pending offers list * @private * @param {Contract} contract - The contract being negotiated */ FarmerInterface.prototype._addContractToPendingList = function(contract) { var id = contract.get('data_hash') + contract.get('renter_id'); if (this._pendingOffers.indexOf(id) !== -1) { return 0; } return this._pendingOffers.push(id); }; /** * Removes the contract data hash to the pending offers list * @param {Contract} contract - The contract being negotiated * @private */ FarmerInterface.prototype._removeContractFromPendingList = function(contract) { var index = this._pendingOffers.indexOf( contract.get('data_hash') + contract.get('renter_id') ); if (index === -1) { return; } this._pendingOffers.splice(index, 1); }; /** * Handles an offer response from a renter * @private */ FarmerInterface.prototype._handleOfferRes = function(res, contract, renter) { var self = this; var final = null; try { final = Contract.fromObject(res.result.contract); } catch (err) { return self._logger.warn('renter responded with invalid contract'); } if (!final.verify('renter', contract.get('renter_id'))) { return self._logger.warn('renter signature is invalid'); } self.storageManager.load(contract.get('data_hash'), function(err, item) { if (err) { item = new StorageItem({ hash: contract.get('data_hash') }); } item.addContract(renter, contract); item.addMetaData(renter, {}); self.storageManager.save(item, utils.noop); self._logger.info('Offer accepted'); if (self._contractCount &lt; Number.MAX_SAFE_INTEGER) { self._contractCount++; } else { self._contractCount = 0; } }); }; /** * Subscribes to a contract identifier on the network * @private * @param {Array} opcodes */ FarmerInterface.prototype._listenForContracts = function(opcodes) { this.subscribe(opcodes, this._handleContractPublication.bind(this)); }; /** * Handles received contract publications * @private * @param {Object} contract - The raw contract object */ FarmerInterface.prototype._handleContractPublication = function(contract) { var self = this; var contractObj; var contact = contract.contact; this._logger.debug('received contract offer...'); try { contractObj = Contract.fromObject(contract); } catch (err) { return; // If the contract is invalid just drop it } this._shouldSendOffer(contractObj, function(shouldSendOffer) { if (!shouldSendOffer) { return self._logger.debug('not sending an offer for the contract'); } self._addContractToPendingList(contractObj); self._negotiateContract(contractObj, contact); }); }; /** * Handles ALLOC messages * @param {Object} params * @param {Protocol~handleConsignCallback} callback */ FarmerInterface.prototype.handleAlloc = function(params, callback) { var self = this; var token = utils.generateToken(); let contractObj = null; try { contractObj = Contract.fromObject(params.contract); } catch (err) { callback(new Error('Invalid contract')); return; } this._shouldSendOffer(contractObj, function(shouldSendOffer) { if (!shouldSendOffer) { // TODO give back a reason callback(new Error('Not accepting contracts')); self._logger.debug('not sending an offer for the contract'); return; } self._addContractToPendingList(contractObj); contractObj.set('farmer_id', self.keyPair.getNodeID()); contractObj.set('payment_destination', self.getPaymentAddress()); contractObj.sign('farmer', self.keyPair.getPrivateKeyPadded()); var item = new StorageItem({ hash: contractObj.get('data_hash') }); var renterId = contractObj.get('renter_id'); if (typeof renterId !== 'string') { self._removeContractFromPendingList(contractObj); return self._logger.warn('dropping invalid contract with no renter id'); } item.addContract({ nodeID: renterId }, contractObj); item.addMetaData({ nodeID: renterId }, {}); self.storageManager.save(item, function(err) { if (err) { self._removeContractFromPendingList(contractObj); return self._logger.error(err.message); } self.transport.shardServer.accept( token, contractObj.get('data_hash'), params.contact ); callback(null, { token: token, contract: contractObj.toObject() }); }); }); } module.exports = FarmerInterface; Ã— Search results Close "},"lib_network_index.js.html":{"id":"lib_network_index.js.html","title":"Source: lib/network/index.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/index.js 'use strict'; const assert = require('assert'); const merge = require('merge'); const async = require('async'); const kad = require('kad'); const HDKey = require('hdkey'); const bitcore = require('bitcore-lib'); const secp256k1 = require('secp256k1'); const constants = require('../constants'); const request = require('request'); const Message = require('bitcore-message'); const Quasar = require('kad-quasar').Protocol; const utils = require('../utils'); const KeyPair = require('../crypto-tools/keypair'); const StorageManager = require('../storage/manager'); const Protocol = require('./protocol'); const Contact = require('./contact'); const Transport = require('./transport'); const EventEmitter = require('events').EventEmitter; const inherits = require('util').inherits; const diglet = require('diglet'); const shuffle = require('knuth-shuffle').knuthShuffle; const TriggerManager = require('../sips').SIP0003.TriggerManager; const OfferManager = require('../contract/offer-manager'); /** * Storj network interface * @constructor * @license AGPL-3.0 * @param {Object} options * @param {String} [options.hdKey] - Extended SIP32 private key at 'group index' * @param {Number} [options.hdIndex] - Derivation index for hdKey * @param {KeyPair} [options.keyPair] - Node's cryptographic identity * @param {StorageManager} options.storageManager - Storage manager backend * @param {String} options.bridges - An array of bridges to connect * @param {Object} options.logger - Logger instance * @param {Array} options.seedList - List of seed URIs to join * @param {String} options.rpcAddress - Public node IP or hostname * @param {Number} options.rpcPort - Listening port for RPC * @param {Number} options.listenPort - Optional different listening port for RPC to bind to * @param {Boolean} options.doNotTraverseNat - Skip NAT traversal strategies * @param {Number} options.maxTunnels - Max number of tunnels to provide * @param {Number} options.maxConnections - Max concurrent connections * @param {Object} options.tunnelGatewayRange * @param {Number} options.tunnelGatewayRange.min - Min port for gateway bind * @param {Number} options.tunnelGatewayRange.max - Max port for gateway bind * @param {Object} [options.joinRetry] * @param {Number} [options.joinRetry.times] - Times to retry joining net * @param {Number} [options.joinRetry.interval] - MS to wait before retrying * @emits Network#ready * @property {KeyPair} keyPair * @property {StorageManager} storageManager * @property {kad.Node} node - The underlying DHT node * @property {TriggerManager} triggerManager * @property {Contact} contact * @property {Transport} transportAdapter * @property {kad.Router} router - The underlying DHT router * @property {ShardServer} shardServer * @property {OfferManager} offerManager */ function Network(options) { if (!(this instanceof Network)) { return new Network(options); } this._initKeyPair(options); this.storageManager = options.storageManager; this.offerManager = new OfferManager(); this._tunnelers = kad.Bucket(); this._options = this._checkOptions(options); this._logger = options.logger; this._storage = new kad.storage.MemStore(); this._pubkeys = {}; this._hdcache = {}; this._open = false; this._initNetworkInterface(); } inherits(Network, EventEmitter); Network.prototype._initKeyPair = function(options) { if (options.hdKey) { assert(!options.keyPair, '&quot;keyPair&quot; is not expected with &quot;hdKey&quot;'); assert(options.hdIndex, '&quot;hdIndex&quot; is expected with &quot;hdKey&quot;'); this.hdKey = HDKey.fromExtendedKey(options.hdKey); this.hdIndex = options.hdIndex; var key = this.hdKey.deriveChild(this.hdIndex); this.keyPair = new KeyPair(key.privateKey.toString('hex')); } else { this.hdKey = null; this.hdIndex = null; this.keyPair = options.keyPair; } }; /** * Triggered when the transport's network interface is ready * @event Network#ready */ /** * Triggered when the node has entered the overlay network * @event Network#connected */ /** * Triggered when the node has exited the overlay network * @event Network#disconnected */ /** * Triggered when an error occurs * @event Network#error */ /** * Triggered when a valid offer is received, but we are not waiting for one * @event Network#unhandledOffer * @param {Contact} contact - The farmer contact the offer is from * @param {Contract} contract - The complete contract, signed by us and farmer * @param {Protocol~unhandledOfferResolver} */ /** * Triggered when an unhandled offer is handled by the * {@link Network#unhandledOffer} listener by calling the event's supplied * {@link Network~unhandledOfferResolver} * @event Network#unhandledOfferResolved * @param {Contact} contact - The farmer contact the offer is from * @param {Contract} contract - The complete contract, signed by us and farmer */ Network.STORJ_BRIDGE_KEY = 'xpub6AHweYHAxk1EhJSBctQD1nLWPog6Sy2eTpKQL' + 'ExR1hfzTyyZQWvU4EYNXv1NJN7GpLYXnDLt4PzN874g6zSjAQdFCHZN7U7nbYKYVDUzD42'; Network.DEFAULTS = { bridges: [ { url: process.env.STORJ_BRIDGE || 'https://api.storj.io', extendedKey: process.env.STORJ_BRIDGE_KEY || Network.STORJ_BRIDGE_KEY } ], seedList: [], joinRetry: { times: 1, interval: 5000 }, rpcAddress: '127.0.0.1', rpcPort: 4000, doNotTraverseNat: false, maxTunnels: 3, maxConnections: 150, tunnelServerPort: 4001, tunnelGatewayRange: { min: 4002, max: 4004 } }; Network.RPC_VALIDATION_EXEMPT = [ 'PROBE', 'FIND_TUNNEL', 'OPEN_TUNNEL' ]; /** * Check the options supplied to the constructor * @private */ Network.prototype._checkOptions = function(options) { assert( options.keyPair instanceof KeyPair || typeof options.hdKey === 'string', 'Invalid keypair supplied' ); assert( options.storageManager instanceof StorageManager, 'Invalid manager supplied' ); assert.ok(this._validateLogger(options.logger), 'Invalid logger supplied'); return merge(JSON.parse(JSON.stringify(Network.DEFAULTS)), options); }; /** * Validates the logger object supplied * @private */ Network.prototype._validateLogger = function(logger) { return logger &amp;&amp; logger.debug &amp;&amp; logger.warn &amp;&amp; logger.info &amp;&amp; logger.error; }; /** * Binds the transport adapter's hooks and events * @private */ Network.prototype._bindTransportHooks = function() { this.transport.on('error', this._handleTransportError.bind(this)); this.transport.before('serialize', this._signMessage.bind(this)); this.transport.before('receive', this._verifyMessage.bind(this)); this.transport.before('receive', kad.hooks.protocol( this._protocol.getRouteMap() )); // NB: After receiving a message, reset the net re-entry timeout this.transport.after('receive', () =&gt; { clearTimeout(this._reEntryTimeout); this._reEntryTimeout = setTimeout( () =&gt; this._enterOverlay(utils.noop), constants.NET_REENTRY ); }); }; /** * Opens the connection to the network * @param {Function} callback - Called on successful network join */ Network.prototype.join = function(callback) { var self = this; if (!this._ready) { return this.once('ready', this.join.bind(this, callback)); } this.node = new kad.Node({ transport: this.transport, router: this.router, storage: this._storage, logger: this._logger }); if (typeof callback === 'function') { self.once('error', callback); self.once('connected', function() { if (self.transport._isPublic) { self._listenForTunnelers(); } self.removeListener('error', callback); callback(null, self); }); } function onJoinComplete(err) { if (err) { return self.emit('error', err); } self.emit('connected'); } async.series( [ this._warnIfClockNotSynced.bind(this), // TODO: Make this not fail hard this.storageManager.open.bind(this.storageManager), this._setupTunnelClient.bind(this), ], function(err) { if (err) { return self.emit('error', err); } // enter overlay network and retry if failed async.retry( { times: self._options.joinRetry.times, interval: self._options.joinRetry.interval }, self._enterOverlay.bind(self), onJoinComplete ); } ); }; Network.prototype._getContactList = function(callback) { if (!this._options.bridges || !this._options.bridges[0] || !this._options.bridges[0].url) { return callback(new Error('No bridges configured')); } const baseURI = this._options.bridges[0].url; this._logger.info('resolving contacts from %s', baseURI); function _request(done) { request({ baseUrl: baseURI, uri: '/contacts', json: true, qs: {connected: true}, method: 'GET' }, function(err, res, body) { if (err) { return done(err); } if (res.statusCode &gt;= 400) { return done(new Error(body.error || body)); } done(null, body); }); } async.retry({ times: 3, interval: 5000 }, _request, callback); } /** * Iteratively attempt connection to network via supplied seeds * @private */ Network.prototype._enterOverlay = function(onConnected) { var self = this; function _trySeeds() { async.detectSeries(self._options.seedList, function(uri, next) { self._logger.info('attempting to join network via %s', uri); self.connect(uri, function(err) { if (err) { self._logger.warn('failed to connect to seed %s', uri); next(null, false); } else { self._logger.info('connected to the storj network via %s', uri); next(null, true); } }); }, function(err, result) { if (err || !result) { // NB: If we fail to join log a warning and retry in 10 mins self._logger.warn('failed to join the network, queuing re-entry'); } // NB: Force re-entry into network to refresh routes every 10 minutes clearTimeout(self._reEntryTimeout); self._reEntryTimeout = setTimeout(_trySeeds, constants.NET_REENTRY); onConnected(null); }); } if (this._options.seedList.length) { return _trySeeds(); } this._getContactList(function(err, seeds) { if (err) { return onConnected( new Error('Failed to discover seeds from bridge: ' + err.message) ); } self._options.seedList = shuffle(seeds) .filter((c) =&gt; c.nodeID !== self.contact.nodeID) .filter((c) =&gt; utils.isCompatibleVersion( c.protocol, process.env.STORJ_ALLOW_LOOPBACK )) .filter((c) =&gt; utils.isValidContact(c)) .map(utils.getContactURL); _trySeeds(); }); }; /** * Disconnects from the network * @param {Function} callback - Called when successful disconnect */ Network.prototype.leave = function(callback) { var self = this; async.series([ (next) =&gt; { if (this.transport &amp;&amp; this.transport.shardServer) { this.transport.shardServer.close(next); } else { next(); } }, (next) =&gt; { this.storageManager.close(function(err) { if (err) { return next(err); } if (!self.node) { return next(); } self.node.disconnect(function(err) { if (err) { return next(err); } self.emit('disconnected'); next(); }); }); } ], callback); }; /** * Publishes a topic with content to the network * @param {String} topic - The serialized opcode topic * @param {Object} contents - Arbitrary publication contents * @param {Object} options - Options to pass to kad-quasar */ Network.prototype.publish = function(topic, contents, options) { return this._pubsub.publish(topic, contents, options); }; /** * Subscribes to a topic on the network * @param {String} topic - The serialized opcode topic * @param {Object} handler - Function to handle received publications */ Network.prototype.subscribe = function(topic, handler) { return this._pubsub.subscribe(topic, handler); }; /** * Connects to the node at the given URI * @param {String} uri - The storj protocol URI to connect * @param {Function} callback - Called on connection or error */ Network.prototype.connect = function(uri, callback) { const self = this; callback = typeof callback === 'function' ? callback : function(err) { if (err) { self._logger.warn('failed to connect to %s, reason: %s', uri, err.message); } else { self._logger.info('connection established with %s', uri); } }; if (!Contact.isValidUrl(uri)) { return callback(new Error('Invalid contact URI supplied')); } return this.node.connect(Contact.fromUrl(uri), callback); }; /** * Will ping a neighbor * @param {String} neighbor - A contact * @param {Function} callback - Called on connection or error */ Network.prototype.ping = function(neighbor, callback) { var message = new kad.Message({ method: 'PING', params: { contact: this.contact } }); this.transport.send(neighbor, message, callback); }; /** * Initilizes the network interface * @private */ Network.prototype._initNetworkInterface = function() { EventEmitter.call(this); this.triggerManager = new TriggerManager(); this.contact = new Contact({ address: this._options.rpcAddress, port: this._options.rpcPort, nodeID: this.keyPair.getNodeID(), hdKey: this.hdKey ? this.hdKey.publicExtendedKey : undefined, hdIndex: this.hdIndex ? this.hdIndex : undefined }); this.transport = new Transport(this.contact, { logger: this._logger, storagePath: this._options.storagePath, maxTunnels: this._options.maxTunnels, maxConnections: this._options.maxConnections, tunnelGatewayRange: this._options.tunnelGatewayRange, doNotTraverseNat: this._options.doNotTraverseNat, storageManager: this.storageManager, listenPort: this._options.listenPort }); this.router = new kad.Router({ transport: this.transport, logger: this._logger }); this._protocol = new Protocol({ network: this }); this.transport.after('open', this._onTransportOpen.bind(this)); this._startRouterCleaner(); }; /** * Set up {@link ShardServer} after transport is ready * @private */ Network.prototype._onTransportOpen = function() { this._bindTransportHooks(); this._ready = true; this._pubsub = new Quasar(this.router, { logger: this._logger, randomRelay: true, maxRelayHops: constants.PUBLISH_TTL }); this.emit('ready'); }; /** * Signs an outgoing message * @private * @param {kad.Message} message * @param {Function} callback */ Network.prototype._signMessage = function(message, callback) { var nonce = Date.now(); var target = message.id + nonce; var signature = null; try { signature = this.keyPair.sign(target); } catch (err) { return callback(err); } if (kad.Message.isRequest(message)) { message.params.nonce = nonce; message.params.signature = signature; } else { message.result.nonce = nonce; message.result.signature = signature; } callback(); }; /** * Verifies that the supplied contact is valid and compatible * @private * @param {Contact} contact */ Network.prototype._validateContact = function(contact, callback) { if (!utils.isCompatibleVersion(contact.protocol)) { this.router.removeContact(contact); return callback(new Error('Protocol version is incompatible')); } if (!utils.isValidContact(contact, process.env.STORJ_ALLOW_LOOPBACK)) { this.router.removeContact(contact); return callback(new Error('Invalid contact data supplied')); } callback(null); }; /** * Verifies an incoming message * @private * @param {kad.Message} message * @param {Contact} contact * @param {Function} callback */ Network.prototype._verifyMessage = function(message, contact, callback) { var self = this; this._validateContact(contact, function(err) { if (err &amp;&amp; Network.RPC_VALIDATION_EXEMPT.indexOf(message.method) === -1) { return callback(err); } var messagekey = kad.Message.isRequest(message) ? 'params' : 'result'; var nonce = message[messagekey].nonce; var signature = message[messagekey].signature; if (Date.now() &gt; (constants.NONCE_EXPIRE + nonce)) { return callback(new Error('Message signature expired')); } var addr = bitcore.Address.fromPublicKeyHash(Buffer(contact.nodeID, 'hex')); var signobj = self._createSignatureObject(signature); self._verifySignature({ message: message, nonce: nonce, signobj: signobj, address: addr, contact: contact, signature: signature }, callback); }); }; /** * Verifies the validity of the supplied signature * @private */ Network.prototype._verifySignature = function(options, callback) { /* eslint max-statements: [2, 20] */ if (!options.signobj) { return callback(new Error('Invalid signature supplied')); } var signedmsg = Message(options.message.id + options.nonce); var magic = signedmsg.magicHash(); var recovery = options.signobj.i; var sig = secp256k1.signatureImport(options.signobj.toBuffer()); var pubKey = this._pubkeys[options.contact.nodeID]; if (!pubKey) { try { pubKey = secp256k1.recover(magic, sig, recovery, true); this._pubkeys[options.contact.nodeID] = pubKey; } catch (e) { return callback(e); } } if (!secp256k1.verify(magic, sig, pubKey)) { return callback(new Error('Signature verification failed')); } if (!this._verifyHDKeyContact(options.contact, pubKey)) { return callback(new Error('Invalid derived public key')); } callback(null); }; Network.prototype._verifyHDKeyContact = function(contact, publicKeyBuffer) { if (contact.hdKey) { var contactPub = this._hdcache[contact.hdKey + contact.hdIndex]; if (!contactPub) { var hdKey = HDKey.fromExtendedKey(contact.hdKey); var nodeKey = hdKey.deriveChild(contact.hdIndex); contactPub = nodeKey.publicKey; this._hdcache[contact.hdKey + contact.hdIndex] = contactPub; } if (contactPub.compare(publicKeyBuffer) === 0) { return true; } return false; } return true; }; /** * Creates a signature object from signature string * @private */ Network.prototype._createSignatureObject = function(signature) { var compactSig; var signobj; try { compactSig = new Buffer(signature, 'base64'); signobj = bitcore.crypto.Signature.fromCompact(compactSig); } catch (err) { return null; } return signobj; }; /** * Proxies error events from the underlying transport adapter * @private * @param {Error} error */ Network.prototype._handleTransportError = function(error) { this._logger.warn(error.message); }; /** * Subscribe to tunneler opcodes to manage known tunnelers * @private */ Network.prototype._listenForTunnelers = function() { var self = this; var tunserver = self.transport.tunnelServer; var prefix = Buffer([constants.OPCODE_TUNNELER_PREFIX], 'hex'); var available = Buffer([constants.OPCODE_DEG_LOW], 'hex'); var unavailable = Buffer([constants.OPCODE_DEG_NULL], 'hex'); function announce() { let hasTunnelAvailable = Object.keys( tunserver._proxies ).length &lt; tunserver._opts.maxProxiesAllowed; self._pubsub.publish( Buffer.concat([ prefix, hasTunnelAvailable ? available : unavailable ]).toString('hex'), self.contact ); setTimeout(announce, constants.TUNNEL_ANNOUNCE_INTERVAL); } if (this._options.maxTunnels) { announce(); } var tunUp = Buffer.concat([prefix, available]).toString('hex'); var tunDown = Buffer.concat([prefix, unavailable]).toString('hex'); this._pubsub.subscribe([tunUp, tunDown], function(contact, topic) { if (topic === tunUp) { if (!self._tunnelers.addContact(Contact(contact))) { self._tunnelers.removeContact(self._tunnelers.getContact(0)); self._tunnelers.addContact(Contact(contact)); } } else { self._tunnelers.removeContact(Contact(contact)); } }); }; /** * Determines if tunnel is needed * @private * @param {Function} callback */ Network.prototype._setupTunnelClient = function(callback) { var self = this; if (this.transport._isPublic) { return callback(null); } var neighbors = this._options.seedList .filter(Contact.isValidUrl) .map(Contact.fromUrl) .filter((c) =&gt; c.nodeID !== self.contact.nodeID); function _discoverIfReachable() { self._logger.info('requesting probe from nearest neighbor'); self._requestProbe(neighbors[0], function(err, result) { if (err || result.error) { return self._findTunnel(neighbors, callback); } self._logger.info( 'you are publicly reachable, skipping tunnel establishment' ); callback(null); }); } if (!neighbors.length) { self._getContactList(function(err, result) { if (err) { return callback(new Error('Failed to get seeds for probe')); } neighbors = result.map(function(c) { return new Contact(c); }); _discoverIfReachable(); }); } else { _discoverIfReachable(); } }; /** * Requests a probe from the nearest neighbor * @private */ Network.prototype._requestProbe = function(neighbor, callback) { var message = new kad.Message({ method: 'PROBE', params: { contact: this.contact } }); this.transport.send(neighbor, message, callback); }; /** * Finds a potential tunneler * @private * @param {Array} neighbors * @param {Function} callback */ Network.prototype._findTunnel = function(neighbors, callback) { var self = this; var tunnelers = []; var message = new kad.Message({ method: 'FIND_TUNNEL', params: { contact: this.contact, relayers: [] } }); // NB: If we are going to be tunneled, we better not accept any tunnel // NB: connections from other nodes, so let's override our maxTunnels. this._options.maxTunnels = 0; this.transport.tunnelServer._opts.maxProxiesAllowed = 0; if (!neighbors.length) { return callback( new Error('Could not find a neighbor to query for tunnels') ); } async.detectSeries(neighbors, function(neighbor, callback) { self._logger.info('requesting tunnelers from neighbor'); self.transport.send(neighbor, message, function(err, resp) { if (err) { return callback(null, false); } if (!resp.result.tunnels.length) { return callback(null, false); } tunnelers = tunnelers.concat(resp.result.tunnels).filter( t =&gt; t.nodeID !== self.contact.nodeID ); callback(null, true); }); }, function() { if (!tunnelers.length) { return callback( new Error('Failed to find tunnels from neighbors') ); } self._establishTunnel(tunnelers, callback); }); }; /** * Creates a tunnel to a public node * @private * @param {Function} callback */ Network.prototype._establishTunnel = function(tunnels, callback) { var self = this; var remoteAddress, remotePort, proxyPort; function established() { return proxyPort &amp;&amp; remotePort &amp;&amp; remoteAddress; } function openTunnel(done) { if (!tunnels.length) { return done(new Error('No tunnelers were returned')); } var tun = new Contact(tunnels[0]); var msg = kad.Message({ method: 'OPEN_TUNNEL', params: { contact: self.contact } }); tunnels.shift(); self.transport.send(tun, msg, function(err, resp) { if (err) { return done(); } remoteAddress = tun.address; remotePort = tun.port; proxyPort = resp.result.proxyPort; done(); }); } async.until(established, openTunnel, function(err) { if (err) { return callback( new Error('Failed to establish tunnel, reason: ' + err.message) ); } var tunnelWasOpened = false; var tunnelDidError = false; var localAddress = self.transport._server.address(); if (!localAddress) { return callback(new Error( 'Local transport not initialized, refusing to establish new tunnel' )); } self._tunnelClient = new diglet.Tunnel({ localAddress: 'localhost', localPort: localAddress.port, remoteAddress: remoteAddress, remotePort: proxyPort, logger: self._logger }); self._tunnelClient.once('established', () =&gt; { self._logger.info('tunnel successfully established'); tunnelWasOpened = true; self._tunneled = true; self.contact.address = remoteAddress; self.contact.port = remotePort; callback(); }); self._tunnelClient.on('error', function onTunnelError(err) { /* istanbul ignore else */ if (!tunnelDidError) { tunnelDidError = true; self._logger.warn( 'tunnel connection lost, reason: %s', err.message ); self._establishTunnel(tunnels, tunnelWasOpened ? utils.noop : callback); } else { self._logger.debug( 'stale tunnel client encountered an error: %s, ignoring', err.message ); } }); self._tunnelClient.open(); }); }; /** * Cleans invalid contacts from routing table * @private */ Network.prototype._cleanRoutingTable = function() { var dropped = []; for (var k in this.router._buckets) { var bucket = this.router._buckets[k]; var bucketList = bucket.getContactList(); for (var i = 0; i &lt; bucketList.length; i++) { var isValidContact = utils.isValidContact( bucketList[i], process.env.STORJ_ALLOW_LOOPBACK ); var isValidProtocol = utils.isCompatibleVersion(bucketList[i].protocol); if (!isValidContact || !isValidProtocol) { dropped.push(bucketList[i]); bucket.removeContact(bucketList[i]); } } } return dropped; }; /** * Cleans the routing table on an interval * @private */ Network.prototype._startRouterCleaner = function() { var self = this; setInterval(function() { self._logger.debug('cleaning bad contacts from routing table'); var dropped = self._cleanRoutingTable(); self._logger.debug('dropping %s bad contacts from router', dropped.length); }, constants.ROUTER_CLEAN_INTERVAL); }; /** * Warns the user if their clock is not synchronized with NTP server * @private */ Network.prototype._warnIfClockNotSynced = function(callback) { var self = this; utils.ensureNtpClockIsSynchronized(function(err, delta) { if (err) { self._logger.warn(err.message); } else { self._logger.info('clock is synchronized with ntp, delta: %s ms', delta); } callback(null); }); }; module.exports = Network; Ã— Search results Close "},"lib_crypto-tools_keypair.js.html":{"id":"lib_crypto-tools_keypair.js.html","title":"Source: lib/crypto-tools/keypair.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/crypto-tools/keypair.js 'use strict'; var bitcore = require('bitcore-lib'); var crypto = require('crypto'); var merge = require('merge'); var Message = require('bitcore-message'); var curve = bitcore.deps.elliptic.curves.secp256k1; var ecdsa = new bitcore.deps.elliptic.ec(curve); /** * Represents a ECDSA key pair * @constructor * @license LGPL-3.0 * @param {String|Buffer|undefined} privateKey - WIF encoded ECDSA private key */ function KeyPair(privkey) { if (!(this instanceof KeyPair)) { return new KeyPair(privkey); } if (privkey) { this._privkey = bitcore.PrivateKey.fromString(privkey); } else { this._privkey = bitcore.PrivateKey.fromRandom(); } this._pubkey = this._privkey.toPublicKey(); } /** * Returns the private key * @returns {String} key */ KeyPair.prototype.getPrivateKey = function() { return this._privkey.toString(); }; /** * Returns the private key padded at 32 bytes * @returns {String} key */ KeyPair.prototype.getPrivateKeyPadded = function() { return this._privkey.bn.toBuffer({size: 32}).toString('hex'); }; /** * Returns the public key * @returns {String} key */ KeyPair.prototype.getPublicKey = function() { return this._pubkey.toString(); }; /** * Returns the NodeID derived from the public key * @returns {String} nodeID - RIPEMD160 hash of public key */ KeyPair.prototype.getNodeID = function() { return bitcore.crypto.Hash.sha256ripemd160( this._pubkey.toBuffer() ).toString('hex'); }; /** * Returns the bitcoin address version of the nodeID * @returns {String} address - Base58 encoded address */ KeyPair.prototype.getAddress = function() { return bitcore.Address.fromPublicKeyHash( new Buffer(this.getNodeID(), 'hex') ).toString(); }; /** * Signs the supplied message with the private key * @param {String|Buffer} message - The message to sign * @param {Object} options * @param {Boolean} [options.compact=true] - Compact signature format * @returns {String} signature */ KeyPair.prototype.sign = function(message, options) { var sign = null; var opts = merge({ compact: true }, options); if (opts.compact) { sign = Message(message).sign(this._privkey); } else { if (!Buffer.isBuffer(message)) { message = new Buffer(message, 'utf8'); } sign = ecdsa.sign( crypto.createHash('sha256').update(message).digest('hex'), this.getPrivateKey() ).toDER('hex'); } return sign; }; module.exports = KeyPair; Ã— Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: index.js /** * @module storj * @license (AGPL-3.0 AND LGPL-3.0) */ 'use strict'; require('./lib/patches')(); // NB: Apply any monkey patches /** {@link Network} */ exports.Network = require('./lib/network'); /** {@link Protocol} */ exports.Protocol = require('./lib/network/protocol'); /** {@link Renter} */ exports.Renter = require('./lib/network/renter'); /** {@link Farmer} */ exports.Farmer = require('./lib/network/farmer'); /** {@link Monitor} */ exports.Monitor = require('./lib/network/monitor'); /** {@link Transport} */ exports.Transport = require('./lib/network/transport'); /** {@link ShardServer} */ exports.ShardServer = require('./lib/network/shard-server'); /** {@link Contact} */ exports.Contact = require('./lib/network/contact'); /** {@link Contract} */ exports.Contract = require('./lib/contract'); /** {@link OfferStream} */ exports.OfferStream = require('./lib/contract/offer-stream'); /** {@link OfferManager} */ exports.OfferManager = require('./lib/contract/offer-manager'); /** {@link AuditStream} */ exports.AuditStream = require('./lib/audit-tools/audit-stream'); /** {@link ProofStream} */ exports.ProofStream = require('./lib/audit-tools/proof-stream'); /** {@link Verification} */ exports.Verification = require('./lib/audit-tools/verification'); /** {@link StorageManager} */ exports.StorageManager = require('./lib/storage/manager'); /** {@link StorageAdapter} */ exports.StorageAdapter = require('./lib/storage/adapter'); /** {@link StorageMigration} */ exports.StorageMigration = require('./lib/storage/migration'); /** {@link EmbeddedStorageAdapter} */ exports.EmbeddedStorageAdapter = require('./lib/storage/adapters/embedded'); /** {@link RAMStorageAdapter} */ exports.RAMStorageAdapter = require('./lib/storage/adapters/ram'); /** {@link StorageItem} */ exports.StorageItem = require('./lib/storage/item'); /** {@link KeyPair} */ exports.KeyPair = require('./lib/crypto-tools/keypair'); /** {@link module:storj/version} */ exports.version = require('./lib/version'); /** {@link module:storj/constants} */ exports.constants = require('./lib/constants'); /** {@link module:storj/utils} */ exports.utils = require('./lib/utils'); /** {@link module:storj/deps} */ exports.deps = require('./lib/deps'); /** {@link module:storj/sips} */ exports.sips = require('./lib/sips'); Ã— Search results Close "},"lib_constants.js.html":{"id":"lib_constants.js.html","title":"Source: lib/constants.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/constants.js /** * @module storj/constants * @license LGPL-3.0 */ 'use strict'; module.exports = { /** @constant {String} CIPHER_ALG - Cipher/Decipher algorithm */ CIPHER_ALG: 'aes-256-ctr', /** @constant {Number} PREFIX - NodeID prefix (same as bitcoin) */ PREFIX: 0x00, /** @constant {Number} NONCE_EXPIRE - Time to honor a signed message */ NONCE_EXPIRE: 15000, /** @constant {Number} RPC_TIMEOUT - Max wait time for a RPC response */ RPC_TIMEOUT: 15000, /** @constant {Number} PUBLISH_TTL - Max time for publication relay */ PUBLISH_TTL: 6, /** @constant {Number} NET_REENTRY - Max wait time before re-entering net */ NET_REENTRY: 600000, /** @constant {Number} AUDIT_BYTES - Number of bytes for audit challenge */ AUDIT_BYTES: 32, /** @constant {Number} CLEAN_INTERVAL - Interval for reaping stale shards */ CLEAN_INTERVAL: 86400000, /** @constant {Number} CONSIGN_THRESHOLD - Threshold for consign time */ CONSIGN_THRESHOLD: 86400000, /** @constant {Number} TOKEN_EXPIRE - Reject datachannl token after time */ TOKEN_EXPIRE: 1800000, /** @constant {Number} TUNNEL_ANNOUNCE_INTERVAL - Announce tunnel state */ TUNNEL_ANNOUNCE_INTERVAL: 900000, /** @constant {Number} OFFER_TIMEOUT - Max wait time for storage offer */ OFFER_TIMEOUT: 15000, /** @constant {Number} ROUTER_CLEAN_INTERVAL - Drop bad contacts */ ROUTER_CLEAN_INTERVAL: 60000, /** @constant {Number} OPCODE_TUNRPC_PREFIX - Opcode for tunnel rpc message */ OPCODE_TUNRPC_PREFIX: 0x0c, /** @constant {Number} OPCODE_TUNDCX_PREFIX - Opcode for tunnel datachannel */ OPCODE_TUNDCX_PREFIX: 0x0d, /** @constant {Number} OPCODE_TUNNELER_PREFIX - Prefix opcode for tunneler */ OPCODE_TUNNELER_PREFIX: 0x0e, /** @constant {Number} OPCODE_CONTRACT_PREFIX - Prefix opcode for contracts */ OPCODE_CONTRACT_PREFIX: 0x0f, /** @constant {Number} OPCODE_DEG_NULL - Opcode for null criteria degree */ OPCODE_DEG_NULL: 0x00, /** @constant {Number} OPCODE_DEG_LOW - Opcode for low criteria degree */ OPCODE_DEG_LOW: 0x01, /** @constant {Number} OPCODE_DEG_MED - Opcode for medium criteria degree */ OPCODE_DEG_MED: 0x02, /** @constant {Number} OPCODE_DEG_HIGH - Opcode for medium criteria degree */ OPCODE_DEG_HIGH: 0x03, /** @constant {Number} MAX_CONCURRENT_OFFERS - Number of concurrent offers */ MAX_CONCURRENT_OFFERS: 3, /** @constant {Number} MAX_CONCURRENT_AUDITS - Number of concurrent audits */ MAX_CONCURRENT_AUDITS: 3, /** @constant MAX_FIND_TUNNEL_RELAYS - Max times to relay FIND_TUNNEL */ MAX_FIND_TUNNEL_RELAYS: 2, /** @constant MAX_NODE_INDEX - Maximum node index */ MAX_NODE_INDEX: 0x7fffffff, /** @constant HD_KEY_DERIVATION_PATH - Key derivation path for HD keys */ HD_KEY_DERIVATION_PATH: 'm/3000\\'/0\\'' }; Ã— Search results Close "},"lib_deps.js.html":{"id":"lib_deps.js.html","title":"Source: lib/deps.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/deps.js /** * @module storj/deps */ 'use strict'; /** * Kademlia inspired local file store based on LevelDB * @see http://bookch.in/kfs */ exports.kfs = require('kfs'); /** * Implementation of the Kademlia distributed hash table * @see http://kadtools.github.io/ */ exports.kad = require('kad'); exports.kad.Quasar = require('kad-quasar'); /** * A modular node for Bitcoin and blockchain-based apps * @see https://bitcore.io/ */ exports.bitcore = require('bitcore-lib'); exports.bitcore.ECIES = require('bitcore-ecies'); Ã— Search results Close "},"lib_patches.js.html":{"id":"lib_patches.js.html","title":"Source: lib/patches.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/patches.js /** * @module storj/patches * @license AGPL-3.0 */ 'use strict'; var kad = require('kad'); var constants = require('./constants'); module.exports = function() { // NB: Increase response timeout for RPC calls kad.constants.T_RESPONSETIMEOUT = constants.RPC_TIMEOUT; }; Ã— Search results Close "},"lib_sips_index.js.html":{"id":"lib_sips_index.js.html","title":"Source: lib/sips/index.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/sips/index.js /** * @module storj/sips * @license AGPL-3.0 */ 'use strict'; /** {@link module:storj/sips/0003} */ module.exports.SIP0003 = require('./0003'); Ã— Search results Close "},"lib_sips_0003_index.js.html":{"id":"lib_sips_0003_index.js.html","title":"Source: lib/sips/0003/index.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/sips/0003/index.js /** * @module storj/sips/0003 */ 'use strict'; /** {@link TriggerManager} */ exports.TriggerManager = require('./trigger-manager'); Ã— Search results Close "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/utils.js /** * @module storj/utils * @license LGPL-3.0 */ 'use strict'; var http = require('http'); var stream = require('readable-stream'); var assert = require('assert'); var HDKey = require('hdkey'); var constants = require('./constants'); var KeyPair = require('./crypto-tools/keypair'); var crypto = require('crypto'); var semver = require('semver'); var ip = require('ip'); var ntp = require('ntp-client'); var bitcore = require('bitcore-lib'); var ECIES = require('bitcore-ecies'); var through = require('through'); var fs = require('fs'); var base58 = bitcore.deps.bs58; var os = require('os'); /** * Returns the SHA-1 hash of the input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.sha1 = function(input, encoding) { return crypto.createHash('sha1').update(input, encoding).digest('hex'); }; /** * Returns the SHA-256 hash of the input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.sha256 = function(input, encoding) { return crypto.createHash('sha256').update(input, encoding).digest('hex'); }; /** * Returns the SHA-256 hash of the input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {Buffer} */ module.exports.sha256b = function(input, encoding) { return crypto.createHash('sha256').update(input, encoding).digest(); }; /** * Returns the SHA-512 hash of the input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.sha512 = function(input, encoding) { return crypto.createHash('sha512').update(input, encoding).digest('hex'); }; /** * Returns the RIPEMD-160 hash of the input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.rmd160 = function(input, encoding) { return crypto.createHash('rmd160').update(input, encoding).digest('hex'); }; /** * Returns the RIPEMD-160 hash of the input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {Buffer} */ module.exports.rmd160b = function(input, encoding) { return crypto.createHash('rmd160').update(input, encoding).digest(); }; /** * Returns the WHIRLPOOL hash of the input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.whirlpool = function(input, encoding) { return crypto.createHash('whirlpool').update(input, encoding).digest('hex'); }; /** * Returns the RIPEMD-160 SHA-256 hash of this input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.rmd160sha256 = function(input, encoding) { return module.exports.rmd160( Buffer(module.exports.sha256(input, encoding), 'hex') ); }; /** * Returns the RIPEMD-160 SHA-256 hash of this input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {Buffer} */ module.exports.rmd160sha256b = function(input, encoding) { return module.exports.rmd160b(module.exports.sha256b(input, encoding)) }; /** * Returns the SHA-1 WHIRLPOOL hash of this input * @param {String|Buffer} input - Data to hash * @param {String} encoding - The encoding type of the data * @returns {String} */ module.exports.sha1whirlpool = function(input, encoding) { return module.exports.sha1( Buffer(module.exports.whirlpool(input, encoding), 'hex') ); }; /** * Returns the next power of two number * @param {Number} number * @returns {Number} */ module.exports.getNextPowerOfTwo = function(num) { return Math.pow(2, Math.ceil(Math.log(num) / Math.log(2))); }; /** * Generates a unique token * @returns {String} */ module.exports.generateToken = function() { return module.exports.rmd160sha256(crypto.randomBytes(512)); }; /** * Returns a stringified URL from the supplied contact object * @param {Object} contact * @param {String} contact.address * @param {Number} contact.port * @param {String} contact.nodeID * @returns {String} */ module.exports.getContactURL = function(contact) { return [ 'storj://', contact.address, ':', contact.port, '/', contact.nodeID ].join(''); }; /** * Returns whether or not the supplied semver tag is compatible * @param {String} version - The semver tag from the contact * @returns {Boolean} compatible */ module.exports.isCompatibleVersion = function(version) { if (!version) { return false; } var local = require('./version').protocol; var remote = version; var sameMajor = semver.major(local) === semver.major(remote); var diffs = ['prerelease', 'prepatch', 'preminor', 'premajor']; if (diffs.indexOf(semver.diff(remote, local)) !== -1) { return false; } else { return sameMajor; } }; /** * Determines if the supplied contact is valid * @param {Contact} contact - The contact information for a given peer * @param {Boolean} loopback - Allows contacts that are localhost * @returns {Boolean} */ module.exports.isValidContact = function(contact, loopback) { if (!contact) { return false; } var isValidAddr = ip.isV4Format(contact.address) || ip.isV6Format(contact.address) || ip.isPublic(contact.address); var isValidPort = contact.port &gt; 0; var isAllowedAddr = ip.isLoopback(contact.address) ? !!loopback : true; return isValidPort &amp;&amp; isValidAddr &amp;&amp; isAllowedAddr; }; /** * Determines if a value is hexadecimal string * @param {*} a - The value to be tested * @returns {Boolean} */ module.exports.isHexaString = function(a) { if (typeof a !== 'string') { return false; } return /^[0-9a-fA-F]+$/.test(a); }; /** * Creates an ECIES ciper object from a private and a public key * @param {String} privateKey - The private key of the sender * @param {String} publicKey - The public key of the recipient * @returns {Object} */ module.exports.createEciesCipher = function(privateKey, publicKey) { var cipher = ECIES(); cipher.privateKey(KeyPair(privateKey)._privkey); cipher.publicKey(bitcore.PublicKey.fromDER(Buffer(publicKey, 'hex'))); return cipher; }; /** * Validates the logger object supplied * @private */ module.exports.validateLogger = function(logger) { return logger &amp;&amp; logger.debug &amp;&amp; logger.warn &amp;&amp; logger.info &amp;&amp; logger.error; }; /** * Encrypts the given data with the supplied password and base58 encodes it * @param {String} password - The passphrase to use for encryption * @param {String} data - The string to encrypt * @returns {String} */ module.exports.simpleEncrypt = function(password, str) { var aes256 = crypto.createCipher('aes-256-cbc', password); var a = aes256.update(str, 'utf8'); var b = aes256.final(); var buf = new Buffer(a.length + b.length); a.copy(buf, 0); b.copy(buf, a.length); return base58.encode(buf); }; /** * Decrypts the given data with the supplied password and base58 decodes it * @param {String} password - The passphrase to use for decryption * @param {String} data - The string to decrypt * @returns {String} */ module.exports.simpleDecrypt = function(password, str) { var aes256 = crypto.createDecipher('aes-256-cbc', password); var a = aes256.update(new Buffer(base58.decode(str))); var b = aes256.final(); var buf = new Buffer(a.length + b.length); a.copy(buf, 0); b.copy(buf, a.length); return buf.toString('utf8'); }; /** * Returns the delta between system time and NTP time * @param {Function} callback - Called with (err, delta) */ module.exports.getNtpTimeDelta = function(callback) { var timeBeforeRequest = new Date(); ntp.getNetworkTime( ntp.defaultNtpServer, ntp.defaultNtpPort, function(err, networkTime) { if (err) { return callback(err); } var systemTime = Date.now(); var latency = parseInt((systemTime - timeBeforeRequest) / 2); var delta = networkTime.getTime() - Math.abs(systemTime - latency); callback(null, delta); } ); }; /** * Determines if the system clock is syncronized with network * @param {Function} callback - Called with (err, delta) */ module.exports.ensureNtpClockIsSynchronized = function(callback) { module.exports.getNtpTimeDelta(function(err, delta) { if (err) { return callback(err); } if (Math.abs(delta) &gt; constants.NONCE_EXPIRE) { return callback(new Error('System clock is not syncronized with NTP')); } callback(null, delta); }); }; /** * Returns a through stream that trims the output based on the given range * @param {Number} trimFront - Number of bytes to trim off front of stream * @param {Number} totalBytes - The total length of the stream in bytes */ module.exports.createStreamTrimmer = function(trimFront, totalBytes) { var bytesTrimmedFront = 0; var bytesRead = 0; return through(function(data) { if (trimFront - bytesTrimmedFront &gt; data.length) { bytesTrimmedFront += data.length; bytesRead += 0; this.queue(new Buffer([])); } else if (trimFront &gt; bytesTrimmedFront) { var frontTrimmedSlice = data.slice(trimFront - bytesTrimmedFront); bytesTrimmedFront += data.length; bytesRead += frontTrimmedSlice.length; this.queue(frontTrimmedSlice); } else if (bytesRead &lt; totalBytes) { var backTrimmedSlice = data.slice(0, totalBytes - bytesRead); bytesRead += backTrimmedSlice.length; this.queue(backTrimmedSlice); } else { this.queue(null); } }); }; /** * Check if file exists * @param {String} file - Path to file * @returns {Boolean} */ module.exports.existsSync = function(file) { try { fs.statSync(file); } catch (err) { return false; } return true; }; /** * Check if a path is a directory * @param {String} dirPath - Path to a directory * @returns {Boolean} */ module.exports.isDirectory = function(dirPath) { try { return fs.statSync(dirPath).isDirectory(); } catch (err) { return false; } }; /** * Check for env STORJ_TEMP todetermine temp directory */ module.exports.tmpdir = function() { var tmpdir = process.env.STORJ_TEMP; if ( !tmpdir || (typeof tmpdir === 'undefined') || !module.exports.existsSync(tmpdir) ) { tmpdir = os.tmpdir(); } return tmpdir; }; /** * Empty function stub * @private */ module.exports.noop = function() {}; /** * Calculate bucket id from a given user id and bucket name * @param {String} user - user id * @param {String} bucketName - bucket name */ module.exports.calculateBucketId = function(user, bucketName) { var rmd160sha256 = module.exports.rmd160sha256; var hash = rmd160sha256(user + bucketName, 'utf-8'); return hash.substring(0, 24); }; /** * Calculate file id from a given bucket id and file name * @param {String} bucket - bucket id * @param {String} fileName - file name */ module.exports.calculateFileId = function(bucket, fileName) { var rmd160sha256 = module.exports.rmd160sha256; var hash = rmd160sha256(bucket + fileName, 'utf-8'); return hash.substring(0, 24); }; /** * Calculate file id from a user id, bucket name, and file name * @param {String} user - user id * @param {String} bucketName - bucket name * @param {String} fileName - file name */ module.exports.calculateFileIdByName = function(user, bucketName, fileName) { var bucket = module.exports.calculateBucketId(user, bucketName); var hash = module.exports.calculateFileId(bucket, fileName); return hash; }; /** * Checks if the supplied HD key is valid (base58 encoded) and proper length * @param {String} hdKey - The HD key in base 58 encoding * @returns {Boolean} isValidHDKey */ module.exports.isValidHDNodeKey = function(hdKey) { return typeof hdKey === 'string' &amp;&amp; /^[1-9a-km-zA-HJ-NP-Z]{1,111}$/.test(hdKey); }; /** * Checks if the input is a non-hardened HD key index * @param {Number} hdIndex - The HD key index * @returns {Boolean} isValidHDKeyIndex */ module.exports.isValidNodeIndex = function(n) { return !Number.isNaN(n) &amp;&amp; (parseInt(n) === n) &amp;&amp; n &gt;= 0 &amp;&amp; n &lt;= constants.MAX_NODE_INDEX; }; /** * Returns a HD key object using corrent key derivation path using the * given seed * @see https://github.com/Storj/complex * @param {Buffer} seed64 - 64 byte seed for generating key * @returns {HDKey} */ module.exports.createComplexKeyFromSeed = function(seed64) { assert(Buffer.isBuffer(seed64), 'Seed must be a buffer'); assert(seed64.length === 64, 'Seed must be 64 bytes in length'); var hdKey = HDKey.fromMasterSeed(seed64).derive( constants.HD_KEY_DERIVATION_PATH ); return hdKey.privateExtendedKey; }; /** * Returns a request object for uploading a shard to a farmer * @param {Contact} farmer - Farmer contact object * @param {String} shardHash - The hash of the shard to upload * @param {String} transferToken - The authorized transfer token * @returns {http.ClientRequest} */ module.exports.createShardUploader = function(farmer, hash, token) { function _createUploadStream() { return http.request({ method: 'POST', protocol: 'http:', hostname: farmer.address, port: farmer.port, path: `/shards/${hash}?token=${token}`, headers: { 'content-type': 'application/octet-stream', 'x-storj-node-id': farmer.nodeID } }); } return new stream.Transform({ transform: function(chunk, encoding, callback) { if (!this._uploader) { this._uploader = _createUploadStream(); this._uploader.on('response', this.emit.bind(this, 'response')); this._uploader.on('error', (err) =&gt; { this.unpipe(); this.emit('error', err); }); } this._uploader.write(chunk, encoding, callback); }, flush: function(callback) { if (this._uploader) { this._uploader.end(); } callback(); } }); }; /** * Returns a request object for downloading a shard from a farmer * @param {Contact} farmer - Farmer contact object * @param {String} shardHash - The hash of the shard to upload * @param {String} transferToken - The authorized transfer token * @returns {http.ClientRequest} */ module.exports.createShardDownloader = function(farmer, hash, token) { function _createDownloadStream() { return http.get({ protocol: 'http:', hostname: farmer.address, port: farmer.port, path: `/shards/${hash}?token=${token}`, headers: { 'content-type': 'application/octet-stream', 'x-storj-node-id': farmer.nodeID } }); } return new stream.Readable({ read: function() { if (!this._downloader) { this._downloader = _createDownloadStream(); this._downloader.on('response', (res) =&gt; { res .on('data', this.push.bind(this)) .on('error', this.emit.bind(this, 'error')) .on('end', this.push.bind(this, null)); }) .on('error', this.emit.bind(this, 'error')); } } }); }; /** * Helper for passing an error only logger callback * @param {Logger} logger - Logger object * @returns {Function} */ module.exports.warnOnError = function(logger) { return function(err) { if (err) { logger.warn(err.message); } }; }; Ã— Search results Close "},"lib_version.js.html":{"id":"lib_version.js.html","title":"Source: lib/version.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/version.js /** * @module storj/version */ 'use strict'; var semver = require('semver'); var assert = require('assert'); var postfix = process.env.STORJ_NETWORK ? '-' + process.env.STORJ_NETWORK : ''; module.exports = { /** @constant {String} protocol - The supported protocol version */ protocol: '1.2.0' + postfix, /** @constant {String} software - The current software version */ software: require('../package').version }; assert( semver.valid(module.exports.protocol), 'Invalid protocol version specified' ); Ã— Search results Close "},"lib_network_monitor.js.html":{"id":"lib_network_monitor.js.html","title":"Source: lib/network/monitor.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/monitor.js 'use strict'; var Network = require('./index'); var EventEmitter = require('events').EventEmitter; var inherits = require('util').inherits; var assert = require('assert'); var merge = require('merge'); var async = require('async'); var request = require('request'); /** * Wraps a {@link Network} instance and provides events for gathering * statistics about node operation * @constructor * @license AGPL-3.0 * @param {Network} network - The network interface to monitor * @param {Object} options */ function Monitor(network, options) { if (!(this instanceof Monitor)) { return new Monitor(network, options); } assert(network instanceof Network, 'Invalid network instance supplied'); this._source = network; this._options = merge(Object.create(Monitor.DEFAULTS), options); this._statistics = {}; this._collectors = { soft: [ Monitor.getConnectedPeers, Monitor.getDiskUtilization ], hard: [ Monitor.getPaymentAddressBalances ] }; EventEmitter.call(this); } inherits(Monitor, EventEmitter); /** * Triggered when a valid offer is received, but we are not waiting for one * @event Monitor#update * @param {Object} stats */ Monitor.DEFAULTS = { softInterval: 10000, // NB: Interval for simple jobs hardInterval: 3 * 60 * 1000 // NB: Interval for resource heavy jobs }; /** * Starts the network monitor * @returns {Monitor} */ Monitor.prototype.start = function() { if (this._softInterval &amp;&amp; this._hardInterval) { return false; } this._softInterval = setInterval( this._collectSoftStats.bind(this), this._options.softInterval ); this._hardInterval = setInterval( this._collectHardStats.bind(this), this._options.hardInterval ); return true; }; /** * Stops the network monitor * @returns {Monitor} */ Monitor.prototype.stop = function() { if (!this._softInterval &amp;&amp; !this._hardInterval) { return false; } clearInterval(this._softInterval); clearInterval(this._hardInterval); delete this._softInterval; delete this._hardInterval; return true; }; /** * Returns the current snapshot * @returns {Object} snapshot */ Monitor.prototype.getSnapshot = function() { return merge(Object.create(this._statistics), { timestamp: new Date() }); }; /** * Collects the soft stats * @private */ Monitor.prototype._collectStats = function(collectors) { var self = this; async.parallel(collectors.map(function(collector) { return collector.bind(null, self._source); }), function(err, results) { results.forEach(function(result) { self._statistics = merge(self._statistics, result); }); self.emit('update', self.getSnapshot()); }); }; /** * Collects the soft stats * @private */ Monitor.prototype._collectSoftStats = function() { this._collectStats(this._collectors.soft); }; /** * Collects the hard stats * @private */ Monitor.prototype._collectHardStats = function() { this._collectStats(this._collectors.hard); }; /** * Gets the list of currently known {@link Contact}s * @static * @param {Network} source - The network instance to use * @param {Function} callback */ Monitor.getConnectedPeers = function(source, callback) { var stats = { connected: 0 }; var buckets = source.router._buckets; for (var k in buckets) { stats.connected += buckets[k].getSize(); } callback(null, { peers: stats }); }; /** * Gets the amount of used space compared to amount shared * @static * @param {Network} source - The network instance to use * @param {Function} callback */ Monitor.getDiskUtilization = function(source, callback) { var stats = { free: source.storageManager._options.maxCapacity }; source.storageManager._storage.size(function(err, shardsize, contractsize) { if (err) { return callback(null, { disk: merge(stats, { used: 0, free: stats.free }) }); } callback(null, { disk: merge(stats, { used: shardsize + contractsize, free: stats.free - (shardsize + contractsize) }) }); }); }; /** * Gets the balance of SJCX/SJCT from a {@link FarmerInterface} * @static * @param {Network} source - The network instance to use * @param {Function} callback */ Monitor.getPaymentAddressBalances = function(source, callback) { var stats = { balances: { sjcx: 0, sjct: 0 } }; var address = source.keyPair.getAddress(); if (source._options.paymentAddress) { address = source._options.paymentAddress.trim(); } var url = 'https://counterpartychain.io/api/balances/' + address; request({ url: url, json: true }, function(err, res, body) { if (err || res.statusCode !== 200) { return callback(null, { payments: stats }); } if (body &amp;&amp; body.data) { for (var balance = 0; balance &lt; body.data.length; balance++) { stats.balances[body.data[balance].asset.toLowerCase()] = Number( body.data[balance].amount ); } } callback(null, { payments: stats }); }); }; /** * Gets the total contracts stored * @static * @param {Network} source - The network instance to use * @param {Function} callback */ Monitor.getContractsDetails = function(source, callback) { var stats = { total: 0 }; var stream = source.storageManager._storage.createReadStream(); stream.on('data', function(item) { stats.total += Object.keys(item.contracts).length; }); stream.on('end', function() { callback(null, { contracts: stats }); }); stream.on('error', function() { stream.removeAllListeners(); callback(null, { contracts: stats }); }); }; module.exports = Monitor; Ã— Search results Close "},"lib_contract_offer-manager.js.html":{"id":"lib_contract_offer-manager.js.html","title":"Source: lib/contract/offer-manager.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/contract/offer-manager.js 'use strict'; var OfferStream = require('./offer-stream'); var assert = require('assert'); /** * Simple management of a collection of {@link OfferStream}s that are keyable * by their associated {@link Contract}'s data hash * @constructor */ function OfferManager() { if (!(this instanceof OfferManager)) { return new OfferManager(); } this._offerStreams = {}; } /** * Returns the stream at the given key * @param {String} dataHash - The hash of the contract's data * @returns {OfferStream|null} */ OfferManager.prototype.getStream = function(dataHash) { return this._offerStreams[dataHash] || null; }; /** * Removes the stream at the given key * @param {String} dataHash - The hash of the contract's data */ OfferManager.prototype.removeStream = function(dataHash) { delete this._offerStreams[dataHash]; }; /** * Adds the offer stream to the manager * @param {OfferStream} offerStream - The {@link OfferStream} to manage */ OfferManager.prototype.addStream = function(offerStream) { assert(offerStream instanceof OfferStream, 'Invalid offer stream supplied'); var key = offerStream._contract.get('data_hash'); this._offerStreams[key] = offerStream; offerStream.on('end', this.removeStream.bind(this, key)); offerStream.on('error', this.removeStream.bind(this, key)); offerStream.on('destroy', this.removeStream.bind(this, key)); }; module.exports = OfferManager; Ã— Search results Close "},"lib_contract_offer-stream.js.html":{"id":"lib_contract_offer-stream.js.html","title":"Source: lib/contract/offer-stream.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/contract/offer-stream.js 'use strict'; var Contact = require('../network/contact'); var Contract = require('./index'); var ReadableStream = require('readable-stream'); var inherits = require('util').inherits; var assert = require('assert'); var merge = require('merge'); /** * Manages a stream of offers for a given storage contract publication * @constructor * @param {Contract} contract - Storage contract published to network * @param {Object} [options] * @param {Number} [options.maxOffers] - Maximum number of offers to process * @param {Array.&lt;String&gt;} [options.farmerBlacklist] - Reject offers from nodeID */ function OfferStream(contract, options) { if (!(this instanceof OfferStream)) { return new OfferStream(contract, options); } ReadableStream.call(this, { objectMode: true }); assert(contract instanceof Contract, 'Invalid contract supplied'); this.options = merge(Object.create(OfferStream.DEFAULTS), options); this._contract = contract; this._queue = []; this._offersQueued = 0; this._offersProccessed = 0; this._farmersDidOffer = []; this._isDestroyed = false; } inherits(OfferStream, ReadableStream); OfferStream.DEFAULTS = { maxOffers: 12, farmerBlacklist: [], }; /** * Triggered when an offer is received * @event OfferStream#data * @param {Object} data * @param {Contact} data.contact - The sending farmer for the offer * @param {Contract} data.contract - The received offer contract */ /** * Triggered when the maximum number of offers are received and processed * @event OfferStream#end */ /** * Triggered if an error occurs * @event OfferStream#error * @param {Error} error - The error object with message */ /** * Implements the underlying stream * @private */ OfferStream.prototype._read = function() { var self = this; if (this._offersProccessed === this.options.maxOffers) { return this.push(null); } function _push() { self._offersProccessed++; self.push(self._queue.shift()); } if (this._queue.length &gt; 0) { return setImmediate(_push); } this.once('_offerAddedToQueue', _push); }; /** * Adds the offer to the internal queue if there is room * @param {Contact} contact - The sending farmer for the offer * @param {Contract} contract - The received offer contract * @returns {Boolean} didAddOfferToQueue */ OfferStream.prototype.addOfferToQueue = function(contact, contract) { assert(contact instanceof Contact, 'Invalid contact supplied'); assert(contract instanceof Contract, 'Invalid contract supplied'); var isDestroyed = this._isDestroyed; var farmerSentOffer = this._farmersDidOffer.indexOf( contact.nodeID ) !== -1; var contractIncomplete = !contract.isComplete(); var maxReached = this._offersQueued === this.options.maxOffers; if (isDestroyed || farmerSentOffer || contractIncomplete || maxReached) { return false; } this._farmersDidOffer.push(contact.nodeID); this._queue.push({ contact: contact, contract: contract }); this._offersQueued++; this.emit('_offerAddedToQueue'); return true; }; /** * Tears down listeners and ends the stream */ OfferStream.prototype.destroy = function() { this._queue = []; this._isDestroyed = true; setImmediate(this.removeAllListeners.bind(this)); this.emit('destroy'); }; module.exports = OfferStream; Ã— Search results Close "},"lib_audit-tools_proof-stream.js.html":{"id":"lib_audit-tools_proof-stream.js.html","title":"Source: lib/audit-tools/proof-stream.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/audit-tools/proof-stream.js 'use strict'; var assert = require('assert'); var MerkleTree = require('mtree'); var utils = require('../utils'); var inherits = require('util').inherits; var stream = require('readable-stream'); var crypto = require('crypto'); /** * Provides interface for proving possession of a file for an * {@link AuditStream} * @constructor * @license LGPL-3.0 * @param {Array} merkleLeaves - Bottom leaves of the audit merkle tree * @param {String} hexChallenge - The challenge data in hex to prepend to shard */ function ProofStream(leaves, challenge) { if (!(this instanceof ProofStream)) { return new ProofStream(leaves, challenge); } assert(Array.isArray(leaves), 'Merkle leaves must be an array'); assert.ok(challenge, 'Invalid challenge supplied'); this._tree = new MerkleTree(this._generateLeaves(leaves), utils.rmd160sha256b); if (!Buffer.isBuffer(challenge)) { this._challenge = Buffer.from(challenge, 'hex'); } else { this._challenge = challenge; } this._hasher = crypto.createHash('sha256').update(this._challenge); this._proof = null; stream.Transform.call(this, { objectMode: true }); } inherits(ProofStream, stream.Transform); /** * Returns the generated proof structure * @return {Array} */ ProofStream.prototype.getProofResult = function() { assert(Array.isArray(this._proof), 'Proof generation is not complete'); return this._proof; }; /** * Handles writing the shard data to the proof stream * @private */ ProofStream.prototype._transform = function(chunk, encoding, next) { this._hasher.update(chunk, encoding); next(); }; /** * Generates the proof from the read data * @private */ ProofStream.prototype._flush = function(done) { try { this._generateProof(); } catch (err) { return done(err); } this.push(this.getProofResult()); done(); }; ProofStream.prototype._findMatchIndex = function(leaves, leaf) { var challengenum = -1; for (let i = 0; i &lt; leaves.length; i++) { if (Buffer.compare(leaves[i], leaf) === 0) { challengenum = i; break; } } return challengenum; } /** * Calculate audit response * @private * @param {String} challenge - Challenge string sent by auditor * @returns {Array} result - Challenge response */ ProofStream.prototype._generateProof = function() { var response = utils.rmd160b(this._hasher.digest()); var leaves = this._tree.level(this._tree.levels() - 1); const leaf = utils.rmd160sha256b(response); var challengenum = this._findMatchIndex(leaves, leaf); assert(challengenum !== -1, 'Failed to generate proof'); var branches = [response]; for (var i = (this._tree.levels() - 1); i &gt; 0; i--) { var level = this._tree.level(i); if (challengenum % 2 === 0) { branches = [branches, level[challengenum + 1]]; } else { branches = [level[challengenum - 1], branches]; } challengenum = Math.floor(challengenum / 2); } this._proof = branches; }; /** * Generates the bottom leaves of the tree to the next power of two * @private * @param {Array} leaves */ ProofStream.prototype._generateLeaves = function(leaves) { var numEmpty = utils.getNextPowerOfTwo(leaves.length) - leaves.length; var emptyLeaves = []; for (var i = 0; i &lt; numEmpty; i++) { emptyLeaves.push(utils.rmd160sha256b('')); } leaves = leaves.map((i) =&gt; Buffer.from(i, 'hex')) return leaves.concat(emptyLeaves); }; module.exports = ProofStream; Ã— Search results Close "},"lib_network_protocol.js.html":{"id":"lib_network_protocol.js.html","title":"Source: lib/network/protocol.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/protocol.js 'use strict'; var through = require('through'); var crypto = require('crypto'); var assert = require('assert'); var utils = require('../utils'); var ProofStream = require('../audit-tools/proof-stream'); var Contract = require('../contract'); var stream = require('readable-stream'); var kad = require('kad'); var async = require('async'); var Contact = require('./contact'); var constants = require('../constants'); var ExchangeReport = require('../exchange-report'); /** * Defines the Storj protocol methods and mounts on a {@link Network} instance * to handle Storj protocol messages * @constructor * @license AGPL-3.0 * @param {Object} options * @param {Network} options.network - Network instance to bind to */ function Protocol(opts) { if (!(this instanceof Protocol)) { return new Protocol(opts); } assert(typeof opts === 'object' , 'Invalid options supplied'); this._network = opts.network; this._logger = this._network._logger; } Protocol.RENEW_PROPS_ALLOWED = [ 'renter_id', 'renter_hd_key', 'renter_hd_index', 'renter_signature', 'store_begin', 'store_end' ]; /** * Handles OFFER messages * @param {Object} params * @param {Contact} params.contact - Sender contact information * @param {Contract} params.contract - Serialized contract data * @param {Protocol~handleOfferCallback} callback * @fires Network#unhandledOffer * @fires Network#unhandledOfferResolved */ Protocol.prototype.handleOffer = function(params, callback) { var self = this; var contract = null; try { contract = Contract.fromObject(params.contract); } catch (err) { return callback(new Error('Invalid contract format')); } self._logger.info( 'handling storage contract offer from %s hash %s', params.contact.nodeID, contract.get('data_hash') ); var key = contract.get('data_hash'); var offerStream = self._network.offerManager.getStream(key); this._verifyContract(contract, params.contact, function(err) { if (err) { return callback(err); } if (offerStream) { // NB: We are waiting on/accepting offers for this contract, // NB: so add it to the offer queue offerStream.addOfferToQueue(Contact(params.contact), contract); } else { // NB: We are not waiting on/accepting offers for this contract, // NB: so notify implementors self._network.emit( 'unhandledOfferResolved', Contact(params.contact), contract ); } callback(null, { contract: contract.toObject() }); }); }; /** * @callback Protocol~handleOfferCallback * @param {Error|null} err * @param {Object} result * @param {Contract} result.contract - Signed contract */ /** * Verifies that the contract is valid * @private */ Protocol.prototype._verifyContract = function(contract, contact, callback) { contract.sign('renter', this._network.keyPair.getPrivateKey()); if (!contract.isComplete()) { return callback(new Error('Contract is not complete')); } if (!contract.verify('farmer', contact.nodeID)) { return callback(new Error('Invalid signature from farmer')); } var offerStream = this._network.offerManager.getStream( contract.get('data_hash') ); if (!offerStream) { if (!this._network.listenerCount('unhandledOffer')) { return callback(new Error('Contract no longer open to offers')); } return this._network.emit('unhandledOffer', contact, contract, callback); } var blacklist = offerStream.options.farmerBlacklist; if (blacklist.indexOf(contact.nodeID) !== -1) { return callback(new Error('Contract no longer open to offers')); } callback(null); }; /** * @callback Protocol~unhandledOfferResolver * @param {Error} [error] - An error if the offer cannot be resolved */ /** * Handles AUDIT messages * @param {Object} params * @param {Contact} params.contact - Sender contact information * @param {Object[]} params.audits * @param {String} params.audits.data_hash - Shard data hash to audit * @param {String} params.audits.challenge - Challenge string for audit * @param {Protocol~handleAuditCallback} callback */ Protocol.prototype.handleAudit = function(params, callback) { var self = this; var limit = constants.MAX_CONCURRENT_AUDITS; if (!Array.isArray(params.audits)) { return callback(new Error('Invalid audit list supplied')); } this._logger.info( 'handling storage audit from %s', params.contact.nodeID ); async.mapLimit(params.audits, limit, function(audit, done) { self._proveShardExistence( audit.data_hash, audit.challenge, params.contact.nodeID, done ); }, function onComplete(err, proofs) { if (err) { return callback(err); } callback(null, { proofs: proofs }); }); }; /** * @callback Protocol~handleAuditCallback * @param {Error|null} err * @param {Object} result * @param {Array[]} result.proofs - Mapped list of proof responses */ /** * Performs a single audit proof generation * @private * @param {String} hash - The hash of the shard to prove * @param {String} challenge - The challenge input for proof generation * @param {String} nodeID - The nodeID of the auditor * @param {Function} callback - Called on completion of the proof generation */ Protocol.prototype._proveShardExistence = function(hash, chall, nid, cb) { if (!hash || !chall) { return cb(new Error('Invalid data hash or challenge provided')); } this._network.storageManager.load(hash, function(err, item) { if (err) { return cb(err); } if (item.shard instanceof stream.Writable) { return cb(new Error('Shard not found')); } var proof = new ProofStream(item.trees[nid], chall); proof.on('error', function(err) { proof.removeAllListeners('finish'); cb(err); }); proof.on('finish', function() { proof.removeAllListeners('error'); cb(null, proof.getProofResult()); }); item.shard.pipe(proof); }); }; /** * Handles ALLOC messages * @param {Object} params * @param {Protocol~handleConsignCallback} callback */ Protocol.prototype.handleAlloc = function(params, callback) { return callback(new Error('Not accepting contracts')); } /** * Handles CONSIGN messages * @param {Object} params * @param {Contact} params.contact - Sender contact information * @param {String} params.data_hash - Shard data hash (contract key) * @param {String[]} params.audit_tree - Bottom leaves of audit merkle tree * @param {Protocol~handleConsignCallback} callback */ Protocol.prototype.handleConsign = function(params, callback) { var self = this; var token = utils.generateToken(); self._logger.info( 'handling storage consignment request from %s hash %s', params.contact.nodeID, params.data_hash ); self._network.storageManager.load(params.data_hash, function(err, item) { if (err) { return callback(err); } var contract = item.getContract(params.contact); var t = Date.now(); if (!contract) { return callback(new Error('Consignment is not authorized')); } item.trees[contract.get('renter_id')] = params.audit_tree; try { assert( t &lt; contract.get('store_end') &amp;&amp; t + constants.CONSIGN_THRESHOLD &gt; contract.get('store_begin'), 'Consignment violates contract store time' ); } catch (err) { return callback(err); } self._network.storageManager.save(item, function(err) { if (err) { return callback(err); } self._logger.info( 'authorizing upload data channel for %s', params.contact.nodeID ); self._network.transport.shardServer.accept( token, params.data_hash, params.contact ); callback(null, { token: token }); }); }); }; /** * @callback Protocol~handleConsignCallback * @param {Error|null} err * @param {Object} result * @param {String} result.token - Data channel authorization token */ Protocol.prototype._sendExchangeReport = function(bridgeUrl, report) { let headers = {}; let body = report.toObject(); this._network.bridgeRequest( bridgeUrl,'POST', '/reports/exchanges', headers, body, (err) =&gt; { if (err) { this._logger.warn('Unable to send exchange report to bridge: %s, '+ 'reason: %s', bridgeUrl, err.message); } }); } /** * Handles MIRROR messages * @param {Object} params * @param {Contact} params.contact - Sender contact information * @param {String} params.data_hash - Shard hash to mirror * @param {String} params.token - Data channel authorization token * @param {Contact} params.farmer - The farmer to transfer data from * @param {Protocol~handleMirrorCallback} callback */ Protocol.prototype.handleMirror = function(params, callback) { /* eslint max-statements: [2, 16] */ const self = this; const {data_hash: hash, token} = params; self._logger.info( 'handling mirror request from %s hash %s', params.contact.nodeID, hash ); // eslint-disable-next-line max-statements self._network.storageManager.load(hash, function(err, item) { if (err) { return callback(err); } let contract = item.getContract(params.contact); // NB: Don't mirror data we are not contracted for if (!contract) { return callback(new Error('No contract found for shard')); } const bridgeExtendedKey = contract.get('renter_hd_key'); const bridge = self._network.bridges.get(bridgeExtendedKey); if (!bridge) { return callback(new Error('Unknown bridge')); } // NB: Don't mirror if we already have the shard if (typeof item.shard.write !== 'function') { return callback(null, {}); } self._logger.info( 'opening data transfer with %j to mirror %s', params.farmer, hash ); const hasher256 = crypto.createHash('sha256'); const report = new ExchangeReport({ reporterId: self._network.contact.nodeID, farmerId: params.farmer.nodeID }); const downloader = utils.createShardDownloader( new Contact(params.farmer), hash, token ); const hash256updater = through(function(data) { hasher256.update(data); this.queue(data); }); function _onFinish() { if (item.hash !== utils.rmd160(hasher256.digest())) { self._logger.warn('mirror read integrity check failed, destroying'); report.end(ExchangeReport.FAILURE, 'FAILED_INTEGRITY'); item.shard.destroy(utils.warnOnError(self._logger)); } else { self._logger.info('successfully mirrored shard hash %s', item.hash); report.end(ExchangeReport.SUCCESS, 'MIRROR_SUCCESS'); } self._sendExchangeReport(bridge.url, report); } report.begin(hash); downloader.on('error', function _onStreamError(err) { self._logger.error('failed to read from mirror node: %s', err.message); item.shard.destroy(utils.warnOnError(self._logger)); report.end(ExchangeReport.FAILURE, 'MIRROR_FAILED'); self._sendExchangeReport(bridge.url, report); }).pipe(hash256updater).pipe(item.shard).on('finish', _onFinish); callback(null, {}); }); }; /** * @callback Protocol~handleMirrorCallback * @param {Error|null} err * @param {Object} result - Empty acknowledgement */ /** * Handles RETRIEVE messages * @param {Object} params * @param {Contact} params.contact - Sender contact information * @param {String} params.data_hash - RMD160(SHA256(shard_data)) * @param {Protocol~handleRetrieveCallback} callback */ Protocol.prototype.handleRetrieve = function(params, callback) { var self = this; var hash = params.data_hash; var token = utils.generateToken(); if (!kad.utils.isValidKey(hash)) { return callback(new Error('Invalid data hash provided: ' + hash)); } self._logger.info( 'handling storage retrieve request from %s hash %s', params.contact.nodeID, hash ); self._network.storageManager.load(hash, function(err, item) { if (err) { return callback(err); } if (!item.getContract(params.contact)) { return callback(new Error('Retrieval is not authorized')); } if (typeof item.shard.write === 'function') { return callback(new Error('Shard data not found')); } // TODO: We will need to increment the download count to track payments self._logger.info( 'authorizing download data channel for %s', params.contact.nodeID ); self._network.transport.shardServer.accept( token, item.hash, params.contact ); callback(null, { token: token }); }); }; /** * @callback Protocol~handleRetrieveCallback * @param {Error|null} err * @param {Object} result * @param {String} result.token - Authorization token for data channel */ /** * Handles PROBE messages * @param {Object} params * @param {Contact} params.contact - Sender contact information * @param {Protocol~handleProbeCallback} callback */ Protocol.prototype.handleProbe = function(params, callback) { var message = new kad.Message({ method: 'PING', params: { contact: this._network.contact } }); this._logger.info('performing probe for %s', params.contact.nodeID); this._network.transport.send(params.contact, message, function(err) { if (err) { return callback(new Error('Probe failed, you are not addressable')); } callback(null, {}); }); }; /** * @callback Protocol~handleProbeCallback * @param {Error|null} err * @param {Object} result - Empty acknowledgement */ /** * Handles FIND_TUNNEL messages * @param {Object} params * @param {Contact} params.contact - Sender contact information * @param {Contact[]} params.relayers - List of contacts who have already * relayed the FIND_TUNNEL request * @param {Protocol~handleFindTunnelCallback} callback */ Protocol.prototype.handleFindTunnel = function(params, callback) { var tunServer = this._network.transport.tunnelServer; var numProxies = Object.keys(tunServer._proxies).length; var available = numProxies &lt; tunServer._opts.maxProxiesAllowed; var knownTunnelers = this._network._tunnelers.getContactList(); var tunnels = available ? [this._network.contact].concat(knownTunnelers) : knownTunnelers; this._logger.info('finding tunnels for %s', params.contact.nodeID); if (tunnels.length) { this._logger.info( 'sending %s tunnels to %s', tunnels.length, params.contact.nodeID ); return callback(null, { tunnels: tunnels }); } if (params.relayers.length &lt; constants.MAX_FIND_TUNNEL_RELAYS) { return this._askNeighborsForTunnels(params.relayers, callback); } callback(null, { tunnels: tunnels }); }; /** * @callback Protocol~handleFindTunnelCallback * @param {Error|null} err * @param {Object} result * @param {Contact[]} result.tunnels - List of known tunnelers */ /** * Sends a FIND_TUNNEL to our seed on behalf of requester * @private */ Protocol.prototype._askNeighborsForTunnels = function(relayers, callback) { var self = this; var nearestNeighbors = this._network.router.getNearestContacts( this._network.contact.nodeID, 3, this._network.contact.nodeID ).filter(function(contact) { return relayers.indexOf(contact.nodeID) === -1; }); this._logger.info('asking nearest neighbors for known tunnels'); function askNeighbor(neighbor, done) { self._network.transport.send(neighbor, kad.Message({ method: 'FIND_TUNNEL', params: { contact: self._network.contact, relayers: [self._network.contact].concat(relayers) } }), function(err, response) { if (err || !Array.isArray(response.result.tunnels)) { return done(null, false); } if (response.result.tunnels &amp;&amp; response.result.tunnels.length) { response.result.tunnels.forEach(function(tun) { if (self._network._tunnelers.getSize() &lt; kad.constants.K) { self._network._tunnelers.addContact(new Contact(tun)); } }); return done(null, true); } done(null, false); }); } async.detectSeries(nearestNeighbors, askNeighbor, function() { callback(null, { tunnels: self._network._tunnelers.getContactList() }); }); }; /** * Handles OPEN_TUNNEL messages * @param {Object} params * @param {Contact} params.contact - Sender contact information * @param {Protocol~handleOpenTunnelCallback} callback */ Protocol.prototype.handleOpenTunnel = function(params, callback) { var self = this; var tunnelServer = this._network.transport.tunnelServer; this._logger.info('opening gateway for %s', params.contact.nodeID); tunnelServer.addProxy(params.contact.nodeID, function(err, proxy) { if (err) { return callback(err); } if (!self._network.transport._requiresTraversal) { return callback(null, { proxyPort: proxy.getProxyPort() }); } self._network.transport.createPortMapping(proxy.getProxyPort(), (err) =&gt; { if (err) { return callback(err); } callback(null, { proxyPort: proxy.getProxyPort() }); }); }); }; /** * @callback Protocol~handleOpenTunnelCallback * @param {Error|null} err * @param {Object} result * @param {String} result.tunnel - WebSocket URI including auth token * @param {Object} result.alias * @param {String} result.alias.address - Gateway address on the tunneler * @param {Number} result.alias.port - Gateway port on the tunneler */ /** * Handles TRIGGER messages * @see https://github.com/Storj/sips/blob/master/sip-0003.md * @param {Object} params * @param {String} params.behavior - Trigger behavior name to process * @param {Object} params.contents - Trigger content payload * @param {Contact} params.contact - Sender contact information * @param {Protocol~handleTriggerCallback} callback */ Protocol.prototype.handleTrigger = function(params, callback) { this._network.triggers.process(params, callback); }; /** * @callback Protocol~handleTriggerCallback * @param {Error|null} err * @param {Object} result - Arbitrary key-value pairs */ /** * Handles RENEW messages * @see https://github.com/Storj/sips/blob/master/sip-0004.md * @param {Object} params * @param {Contact} params.contact - Sender contact information * @param {String} params.renter_id - Renter nodeID of the original contract * @param {String} params.renter_signature - Contract signature from original * node ID * @param {Object} params.contract - Updated contract data * @param {Protocol~handleRenewCallback} callback */ Protocol.prototype.handleRenew = function(params, callback) { var self = this; var updatedContract = null; var dataHash = null; try { assert.ok(params.renter_id, 'No original renter_id was supplied'); assert.ok(params.renter_signature, 'No original renter signature supplied'); updatedContract = Contract.fromObject(params.contract); dataHash = updatedContract.get('data_hash'); self._logger.info('handling contract renew request from %s hash %s', params.contact.nodeID, dataHash ); assert.ok( updatedContract.verifyExternal( params.renter_signature, params.renter_id ), 'Invalid original renter signature on updated contract' ); assert.ok( updatedContract.verify('renter', updatedContract.get('renter_id')), 'Invalid new renter signature on updated contract' ); } catch (err) { return callback(err); } this._network.storageManager.load(dataHash, function(err, item) { if (err) { return callback(err); } var originalContract = item.getContract(params.contact); if (!originalContract) { return callback(new Error('No contract found for renter_id')); } var changedProperties = Contract.diff(originalContract, updatedContract); // TODO: Come back and consider how to handle attacks on store time for (var i = 0; i &lt; changedProperties.length; i++) { if (Protocol.RENEW_PROPS_ALLOWED.indexOf(changedProperties[i]) === -1) { self._logger.error('Renew contract failed: %s cannot be changed', changedProperties[i]); return callback(new Error(changedProperties[i] + ' cannot be changed')); } } updatedContract.sign('farmer', self._network.keyPair.getPrivateKey()); item.removeContract(params.contact); item.addContract({ nodeID: updatedContract.get('renter_id'), hdKey: updatedContract.get('renter_hd_key'), hdIndex: updatedContract.get('renter_hd_index') }, updatedContract); self._network.storageManager.save(item, function(err) { if (err) { return callback(new Error('Failed to save updated contract')); } callback(null, { contract: updatedContract.toObject() }); }); }); }; /** * @callback Protocol~handleRenewCallback * @param {Error|null} err * @param {Object} result * @param {Object} result.contract - Signed updated contract */ /** * Returns bound references to the protocol handlers * @returns {Object} handlers */ Protocol.prototype.getRouteMap = function() { return { OFFER: this.handleOffer.bind(this), AUDIT: this.handleAudit.bind(this), CONSIGN: this.handleConsign.bind(this), MIRROR: this.handleMirror.bind(this), RETRIEVE: this.handleRetrieve.bind(this), PROBE: this.handleProbe.bind(this), FIND_TUNNEL: this.handleFindTunnel.bind(this), OPEN_TUNNEL: this.handleOpenTunnel.bind(this), TRIGGER: this.handleTrigger.bind(this), RENEW: this.handleRenew.bind(this), ALLOC: this.handleAlloc.bind(this) }; }; module.exports = Protocol; Ã— Search results Close "},"lib_storage_adapters_ram.js.html":{"id":"lib_storage_adapters_ram.js.html","title":"Source: lib/storage/adapters/ram.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/adapters/ram.js 'use strict'; var inherits = require('util').inherits; var stream = require('readable-stream'); var StorageAdapter = require('../adapter'); /** * Implements an in-memory storage adapter * @extends {StorageAdapter} * @constructor * @license AGPL-3.0 */ function RAMStorageAdapter() { if (!(this instanceof RAMStorageAdapter)) { return new RAMStorageAdapter(); } this._items = {}; this._shards = {}; } inherits(RAMStorageAdapter, StorageAdapter); /** * Implements the abstract {@link StorageAdapter#_get} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._get = function(key, callback) { var self = this; var result = this._items[key]; if (!result) { return callback(new Error('Shard data not found')); } if (this._shards[key]) { result.shard = this._decorateStreamWithDestroy(key, new stream.Readable({ read: function() { if (this._finished) { this.push(null); } else { this.push(self._shards[key]); this._finished = true; } } })); } else { result.shard = this._decorateStreamWithDestroy(key, new stream.Writable({ write: function(data, encoding, next) { self._shards[key] = data; next(); } })); } callback(null, result); }; /** * Implements the abstract {@link StorageAdapter#_peek} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._peek = function(key, callback) { if (!this._items[key]) { return callback(new Error('Shard data not found')); } callback(null, this._items[key]); }; /** * Implements the abstract {@link StorageAdapter#_put} * @private * @param {String} key * @param {StorageItem} item * @param {Function} callback */ RAMStorageAdapter.prototype._put = function(key, item, callback) { this._items[key] = item; callback(); }; /** * Implements the abstract {@link StorageAdapter#_flush} * @private * @param {Function} callback */ RAMStorageAdapter.prototype._flush = function(callback) { callback(); }; /** * Implements the abstract {@link StorageAdapter#_del} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._del = function(key, callback) { delete this._shards[key]; callback(); }; /** * Implements the abstract {@link StorageAdapter#_size} * @private * @param {String} [key] * @param {Function} callback */ /* istanbul ignore next */ RAMStorageAdapter.prototype._size = function(key, callback) { /* istanbul ignore if */ if (typeof key === 'function') { callback = key; } var shardBytes = 0; for (var _key in this._shards) { shardBytes += this._shards[_key].length; } callback( null, Buffer(JSON.stringify(this._items)).length + shardBytes ); }; /** * Implements the abstract {@link StorageAdapter#_keys} * @private * @returns {ReadableStream} */ RAMStorageAdapter.prototype._keys = function() { var keys = Object.keys(this._items); return new stream.Readable({ read: function() { this.push(keys.length ? keys.shift() : null); } }); }; /** * Decorates a stream with a destroy method to remove any data written * @private * @param {String} key * @param {Stream} stream */ RAMStorageAdapter.prototype._decorateStreamWithDestroy = function(key, stream) { var self = this; stream.destroy = function() { delete self._shards[key]; }; return stream; }; module.exports = RAMStorageAdapter; Ã— Search results Close "},"lib_network_renter.js.html":{"id":"lib_network_renter.js.html","title":"Source: lib/network/renter.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/renter.js 'use strict'; var merge = require('merge'); var assert = require('assert'); var Contract = require('../contract'); var Contact = require('./contact'); var AuditStream = require('../audit-tools/audit-stream'); var kad = require('kad'); var Network = require('./'); var inherits = require('util').inherits; var StorageItem = require('../storage/item'); var async = require('async'); var OfferStream = require('../contract/offer-stream'); /** * Creates and a new renter interface * @constructor * @license AGPL-3.0 * @extends {Network} * @param {Object} options * @param {String} [options.hdKey] - Extended key at 'group index' as per SIP32 * @param {Number} [options.hdIndex] - Derivation index for hdKey * @param {KeyPair}[options.keyPair] - Node's cryptographic identity * @param {StorageManager} options.storageManager - Storage manager backend * @param {Object} options.logger - Logger instance * @param {Array} options.seedList - List of seed URIs to join * @param {String} options.rpcAddress - Public node IP or hostname * @param {Number} options.rpcPort - Listening port for RPC * @param {Boolean} options.doNotTraverseNat - Skip NAT traversal strategies * @param {Number} options.maxTunnels - Max number of tunnels to provide * @param {Number} options.tunnelServerPort - Port for tunnel server to use * @param {Object} options.tunnelGatewayRange * @param {Number} options.tunnelGatewayRange.min - Min port for gateway bind * @param {Number} options.tunnelGatewayRange.max - Max port for gateway bind * @param {Object} options.rateLimiterOpts - Options for {@link RateLimiter} * @param {Object} [options.joinRetry] * @param {Number} [options.joinRetry.times] - Times to retry joining net * @param {Number} [options.joinRetry.interval] - MS to wait before retrying * @emits Network#ready * @property {KeyPair} keyPair * @property {StorageManager} storageManager * @property {kad.Node} node - The underlying DHT node * @property {TriggerManager} triggerManager * @property {Contact} contact * @property {Transport} transportAdapter * @property {kad.Router} router - The underlying DHT router * @property {DataChannelServer} dataChannelServer */ function RenterInterface(options) { if (!(this instanceof RenterInterface)) { return new RenterInterface(options); } Network.call(this, options); } inherits(RenterInterface, Network); /** * Publishes a contract directly to a specific contact and receive a * storage offer in the response. * @param {Contract} contact - The contact to publish the contract * @param {Contract} contract - The storage contract to publish */ RenterInterface.prototype.publishContract = function( contact, contract, callback) { assert(contact instanceof Contact, 'Invalid contact supplied'); assert(contract instanceof Contract, 'Invalid contract supplied'); const data = contract.toObject(); var message = new kad.Message({ method: 'ALLOC', params: { contract: data, contact: this.contact } }); this.transport.send(contact, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } callback(null, response); }); }; /** * Creates a readable stream of offers for the storage contract * @param {Contract} contract - The storage contract to publish * @param {Object} [offerStreamOptions] - Options passed to {@link OfferStream} * @returns {OfferStream} offerStream */ RenterInterface.prototype.getOfferStream = function(contract, options) { assert(contract instanceof Contract, 'Invalid contract supplied'); var hash = contract.get('data_hash'); var offerStream = new OfferStream(contract, options); var content = merge(contract.toObject(), { contact: this.contact }); this.offerManager.addStream(offerStream); this.publish(contract.getTopicString(), content, { key: hash }); return offerStream; }; /** * Issues an audit request to the given farmer for the data and returns the * {@link ProofStream#getProofResult} structure for verification. * @param {Contact} farmer - Farmer contact from which proof is needed * @param {StorageItem} item - The storage item on which to perform the audit * @param {RenterInterface~getStorageProofCallback} callback - Proof handler */ RenterInterface.prototype.getStorageProof = function(farmer, item, callback) { assert(farmer instanceof Contact, 'Invalid contact supplied'); assert(item instanceof StorageItem, 'Invalid storage item supplied'); if (!item.challenges[farmer.nodeID]) { return callback(new Error('Item has no contracts with supplied farmer')); } if (!item.challenges[farmer.nodeID].challenges.length) { return callback(new Error('There are no remaining challenges to send')); } var message = new kad.Message({ method: 'AUDIT', params: { audits: [ { data_hash: item.hash, challenge: item.challenges[farmer.nodeID].challenges.shift() } ], contact: this.contact } }); this.transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } if (!Array.isArray(response.result.proofs)) { return callback(new Error('Invalid proof returned')); } callback(null, response.result.proofs[0]); }); }; /** * This callback is called upon receipt of an audit proof from * {@link RenterInterface#getStorageProof} * @callback RenterInterface~getStorageProofCallback * @param {Error|null} err - If requesting the proof failed, an error object * @param {Array} proof - Result from {@link ProofStream#getProofResult} */ /** * Requests a consignment pointer from the given farmer for opening a * {@link DataChannelClient} for transferring the the data shard to the farmer * @param {Contact} farmer - The farmer contact object for requesting token * @param {Contract} contract - The storage contract for this consignment * @param {AuditStream} audit - The audit object for merkle leaves * @param {RenterInterface~getConsignmentPointerCallback} callback */ RenterInterface.prototype.getConsignmentPointer = function(f, c, a, callback) { var farmer = f; var contract = c; var audit = a; assert(farmer instanceof Contact, 'Invalid farmer contact supplied'); assert(contract instanceof Contract, 'Invalid contract supplied'); assert(audit instanceof AuditStream, 'Invalid audit object supplied'); var message = new kad.Message({ method: 'CONSIGN', params: { data_hash: contract.get('data_hash'), audit_tree: audit.getPublicRecord(), contact: this.contact } }); this.transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } callback(null, { farmer: f, hash: contract.get('data_hash'), token: response.result.token, operation: 'PUSH' }); }); }; /** * This callback is called upon receipt of a consignment token from * {@link RenterInterface#getConsignmentPointer} * @callback RenterInterface~getConsignmentPointerCallback * @param {Error|null} err - If requesting the token failed, an error object * @param {Object} pointer * @param {Contact} pointer.farmer * @param {String} pointer.hash * @param {String} pointer.token * @param {String} pointer.operation */ /** * Requests a retrieval token from the given farmer for opening a * {@link DataChannelClient} for transferring the data shard from the farmer * @param {Contact} farmer - The farmer contact object for requesting token * @param {Contract} contract - The storage contract for this consignment * @param {RenterInterface~getRetrievalPointerCallback} callback - Token handler */ RenterInterface.prototype.getRetrievalPointer = function(f, c, callback) { var farmer = f; var contract = c; assert(farmer instanceof Contact, 'Invalid farmer contact supplied'); assert(contract instanceof Contract, 'Invalid contract supplied'); var message = new kad.Message({ method: 'RETRIEVE', params: { data_hash: contract.get('data_hash'), contact: this.contact } }); this.transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } callback(null, { farmer: f, hash: contract.get('data_hash'), token: response.result.token, operation: 'PULL' }); }); }; /** * This callback is called upon receipt of a retrieval token from * {@link RenterInterface#getRetrieveToken} * @callback RenterInterface~getRetrievalPointerCallback * @param {Error|null} err - If requesting the token failed, an error object * @param {Object} pointer * @param {Contact} pointer.farmer * @param {String} pointer.hash * @param {String} pointer.token * @param {String} pointer.operation */ /** * Requests that the given destination farmers mirror the data from the sources * @param {Array.&lt;Object&gt;} sources - Pointers for each destination * @param {Array.&lt;Contact&gt;} destinations - The farmers to replicate to * @param {RenterInterface~getMirrorNodesCallback} callback - Results handler */ RenterInterface.prototype.getMirrorNodes = function(sources, dests, callback) { var self = this; assert(Array.isArray(sources), 'Invalid sources list supplied'); assert(Array.isArray(dests), 'Invalid destination list supplied'); assert( sources.length === dests.length, 'Sources and destinations must have equal length' ); dests.forEach(function(dest) { assert(dest instanceof Contact, 'Invalid destination supplied'); }); function _sendMirrorRequest(destination, next) { var source = sources.shift(); var message = new kad.Message({ method: 'MIRROR', params: { data_hash: source.hash, token: source.token, farmer: source.farmer, contact: self.contact } }); self.transport.send(destination, message, function(err, response) { if (err || !response || response.error) { return next(null, false); } next(null, true); }); } function _onMirrorRequestsComplete(err, results) { // Error is never passed in the filter, as the test is for an error // we can keep the error check here anyways, if the code changes. /* istanbul ignore next */ if (err) { return callback(err); } if (results.length === 0) { return callback(new Error('All mirror requests failed')); } callback(null, results); } async.filter(dests, _sendMirrorRequest, _onMirrorRequestsComplete); }; /** * This callback is called upon acknowledgement of a mirror request * @callback RenterInterface~getMirrorNodesCallback * @param {Error|null} err - If requesting all mirrors failed, an error object * @param {Array.&lt;Contact&gt;} results - The farmers who successfully mirrored */ module.exports = RenterInterface; Ã— Search results Close "},"lib_network_shard-server.js.html":{"id":"lib_network_shard-server.js.html","title":"Source: lib/network/shard-server.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/shard-server.js 'use strict'; const assert = require('assert'); const crypto = require('crypto'); const events = require('events'); const path = require('path'); const levelup = require('levelup'); const ExchangeReport = require('../exchange-report'); const StorageManager = require('../storage/manager'); const Contact = require('./contact'); const inherits = require('util').inherits; const utils = require('../utils'); /** * Creates a shard server for sending and receiving consigned file shards * @constructor * @license AGPL-3.0 * @param {Object} options * @param {String} options.nodeID - The farmer nodeID * @param {String} options.storagePath - Path to store tokens db * @param {StorageManager} options.storageManager - Storage manager backend * @param {kad.Logger} options.logger - Logger to use from {@link Network} * @param {Number} [options.tokenTtl=1800000] - Close after idle */ function ShardServer(options) { if (!(this instanceof ShardServer)) { return new ShardServer(options); } this._checkOptions(options); events.EventEmitter.call(this); this.activeTransfers = 0; this._nodeID = options.nodeID; // This needs to be set externally when farmer interface in constructed this.farmerInterface = null; this._manager = options.storageManager; this._log = options.logger; this._ttl = options.tokenTtl || ShardServer.TOKEN_EXPIRE; this._dbPath = path.join(options.storagePath, 'tokens.db'); this._db = levelup(this._dbPath, { maxOpenFiles: ShardServer.MAX_OPEN_FILES }); this._reapDeadTokensInterval = setInterval( this._reapDeadTokens.bind(this), ShardServer.REAPER_INTERVAL); } ShardServer.TOKEN_EXPIRE = 86400000; ShardServer.MAX_OPEN_FILES = 10; ShardServer.REAPER_INTERVAL = 60000; /** * Triggered when a shard has finished uploading to this instance * @event ShardServer#shardUploaded * @param {StorageItem} item - The item associated with the upload */ /** * Triggered when a shard has finished downloading from this instance * @event ShardServer#shardDownloaded * @param {StorageItem} item - The item associated with the download */ /** * Triggered when a error occurs * @event ShardServer#error * @param {Error} error - The error object */ inherits(ShardServer, events.EventEmitter); /** * Begin accepting data for the given file hash and token * @param {String} token - The authorization token created for transfer * @param {String} filehash - The shard hash to allow for the token * @param {Contact} contact - contact that negotiated the token * @param {Function} callback */ ShardServer.prototype.accept = function(token, filehash, contact, callback) { assert(typeof token === 'string', 'Invalid token supplied'); assert(typeof filehash === 'string', 'Invalid filehash supplied'); assert(contact, 'Contact parameter is expected'); if (!callback) { callback = (err) =&gt; { if (err) { this._log.error(err); } } } let expires = Date.now() + this._ttl; let data = JSON.stringify({ hash: filehash, contact: contact, expires: expires }); // Atomically create two records, one with the data // and another to search for tokens for when they expire var ops = [ { type: 'put', key: 'TK' + token, value: data }, { type: 'put', key: this._encodeExpiresKey(expires), value: token } ] this._db.batch(ops, callback); }; ShardServer.prototype._encodeExpiresKey = function(expires) { let e = Buffer.alloc(8, 0); e.writeDoubleBE(expires); return 'EX' + e.toString('hex'); } /** * Stop accepting data for the given token * @param {String} token - The authorization token created for transfer */ ShardServer.prototype.reject = function(token, callback) { assert(typeof token === 'string', 'Invalid token supplied'); if (!callback) { callback = (err) =&gt; { if (err) { this._log.error(err); } } } this._db.get('TK' + token, (err, data) =&gt; { if (err) { return callback(err); } let parsed = {}; try { parsed = JSON.parse(data); } catch (err) { return callback(new Error('Unable to parse token data')); } let ops = [ { type: 'del', key: 'TK' + token }, { type: 'del', key: this._encodeExpiresKey(parsed.expires) } ]; this._db.batch(ops, callback); }); }; /** * Checks the options supplied to constructor * @private */ ShardServer.prototype._checkOptions = function(options) { assert.ok(options, 'No options were supplied to constructor'); assert( options.storageManager instanceof StorageManager, 'Invalid manager supplied' ); assert.ok(options.logger, 'Invalid logger supplied'); assert.ok(options.nodeID, 'Invalid nodeID supplied'); }; /** * Validates the given token * @param {String} token * @param {String} hash */ ShardServer.prototype.isAuthorized = function(token, hash, callback) { if (!token) { return callback(new Error('You did not supply a token')); } if (!hash) { return callback(new Error('You did not supply the data hash')); } this._db.get('TK' + token, (err, data) =&gt; { if (err &amp;&amp; err.notFound) { return callback(new Error('The supplied token is not accepted')); } else if (err) { return callback(err); } let parsed = {}; try { parsed = JSON.parse(data); } catch (e) { return callback(new Error('Unable to parse token data')); } if (parsed.hash !== hash) { return callback(new Error('Token not valid for hash')); } if (parsed.expires &lt; Date.now()) { return callback(new Error('Token has expired')); } let contact = new Contact(parsed.contact); callback(null, contact); }); }; /** * Decrements the active transfer count on early socket close * @private */ ShardServer.prototype._handleEarlySocketClose = function() { this._log.warn('channel terminated early (possibly by client)'); this.activeTransfers--; }; /** * Decrements the active transfer count on request error * @private */ ShardServer.prototype._handleRequestError = function(err) { this._log.warn('channel encountered an error: %s', err.message); this.activeTransfers--; }; ShardServer.prototype._sendExchangeReport = function(bridgeUrl, report) { let headers = {}; let body = report.toObject(); this.farmerInterface.bridgeRequest( bridgeUrl,'POST', '/reports/exchanges', headers, body, (err) =&gt; { if (err) { this._log.warn('Unable to send exchange report to bridge: %s, '+ 'reason: %s', bridgeUrl, err.message); } }); } /** * Receives the data stream and writes it to storage * @param {http.IncomingMessage} req * @param {http.ServerResponse} res */ ShardServer.prototype.routeConsignment = function(req, res) { const self = this; const hasher = crypto.createHash('sha256'); const token = req.query.token; const hash = req.params.hash; this.isAuthorized(token, hash, (err, contact) =&gt; { if (err) { res.send(401, { result: err.message }); } let report = new ExchangeReport({ reporterId: this._nodeID, farmerId: this._nodeID }) report.begin(hash); // eslint-disable-next-line max-statements this._manager.load(hash, function(err, item) { if (err) { return res.send(404, { result: err.message }); } const contract = item.getContract(contact); if (!contract) { return res.send(500, { result: 'Unable to locate contract'}); } const bridgeExtendedKey = contract.get('renter_hd_key'); const bridge = self.farmerInterface.bridges.get(bridgeExtendedKey); if (!bridge) { return res.send(500, { result: 'Not connected to bridge'}); } const shardsize = contract.get('data_size'); // If the shard is not writable, it means we already have it, so let's // just respond with a success message if (typeof item.shard.write !== 'function') { report.end(ExchangeReport.SUCCESS, 'SHARD_EXISTS'); self._sendExchangeReport(bridge.url, report); return res.send(304, { result: 'Consignment completed' }); } let received = 0; self.activeTransfers++; req.on('error', self._handleRequestError.bind(self)); res.on('close', self._handleEarlySocketClose.bind(self)); req.on('data', function(chunk) { received += chunk.length; if (received &gt; shardsize) { report.end(ExchangeReport.FAILURE, 'FAILED_INTEGRITY'); self._sendExchangeReport(bridge.url, report); item.shard.destroy(utils.warnOnError(self._log)); self.activeTransfers--; return res.send(400, { result: 'Shard exceeds the amount defined in the contract' }); } hasher.update(chunk); item.shard.write(chunk); }); req.on('end', function() { /* eslint max-statements: [2, 15] */ var calculatedHash = utils.rmd160(hasher.digest()); self.activeTransfers--; if (calculatedHash !== hash) { report.end(ExchangeReport.FAILURE, 'FAILED_INTEGRITY'); self._sendExchangeReport(bridge.url, report); self._log.warn('calculated hash does not match the expected result'); item.shard.destroy(utils.warnOnError(self._log)); return res.send(400, { result: 'Calculated hash does not match the expected result' }); } self._log.debug('Shard upload completed hash %s', hash); item.shard.end(); report.end(ExchangeReport.SUCCESS, 'SHARD_UPLOADED'); self._sendExchangeReport(bridge.url, report); self.reject(req.query.token); res.send(200, { result: 'Consignment completed' }); self.emit('shardUploaded', item, contact); }); }); }); }; /** * Pumps the data through to the client * @param {http.IncomingMessage} req * @param {http.ServerResponse} res */ ShardServer.prototype.routeRetrieval = function(req, res) { const self = this; const token = req.query.token; const hash = req.params.hash; this.isAuthorized(token, hash, (err, contact) =&gt; { if (err) { return res.send(401, { result: err.message }); } let report = new ExchangeReport({ reporterId: this._nodeID, farmerId: this._nodeID }) // eslint-disable-next-line max-statements this._manager.load(hash, function(err, item) { if (err) { return res.send(404, { result: err.message }); } const contract = item.getContract(contact); if (!contract) { return res.send(500, { result: 'Unable to locate contract'}); } const bridgeExtendedKey = contract.get('renter_hd_key'); const bridge = self.farmerInterface.bridges.get(bridgeExtendedKey); if (!bridge) { return res.send(500, { result: 'Not connected to bridge'}); } function _handleReadFailure(err) { self.activeTransfers--; report.end(ExchangeReport.FAILURE, 'READ_FAILED'); self._sendExchangeReport(bridge.url, report); res.send(500, { result: err.message }); } function _handleTransferFinish() { self.activeTransfers--; self._log.debug('Shard download completed hash %s', item.hash); report.end(ExchangeReport.SUCCESS, 'SHARD_DOWNLOADED'); self._sendExchangeReport(bridge.url, report); self.emit('shardDownloaded', item, contact); self.reject(req.query.token); } self.activeTransfers++; req.on('error', self._handleRequestError.bind(self)); res.on('close', self._handleEarlySocketClose.bind(self)); res.header('content-type', 'application/octet-stream'); report.begin(hash); item.shard .on('error', _handleReadFailure) .on('end', _handleTransferFinish) .pipe(res); }); }); }; /** * Close token database * @param {Function} callback */ ShardServer.prototype.close = function(callback) { this._db.close(callback); } /** * Enumerates the authorized list and rejects expired * @private */ ShardServer.prototype._reapDeadTokens = function() { let ops = []; let stream = this._db.createReadStream({ lte: this._encodeExpiresKey(Date.now()), gte: this._encodeExpiresKey(0) }); stream.on('data', (data) =&gt; { ops.push({ type: 'del', key: 'TK' + data.value }); ops.push({ type: 'del', key: data.key }); }) stream.on('error', (err) =&gt; { this._log.error(err); }); stream.on('end', () =&gt; { this._db.batch(ops, (err) =&gt; { if (err) { this._log.error(err); } this.emit('reapedTokens', ops.length / 2); }); }); }; module.exports = ShardServer; Ã— Search results Close "},"lib_storage_item.js.html":{"id":"lib_storage_item.js.html","title":"Source: lib/storage/item.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/item.js 'use strict'; var assert = require('assert'); var Contract = require('../contract'); var merge = require('merge'); /** * Represents a storage item, including contracts, challenges, the shard itself * along with metadata describing download count, payments, etc * @constructor * @license AGPL-3.0 * @param {Object} data * @param {String|null} data.hash - Shard hash to use as storage key * @param {Stream|null} data.shard - Raw binary blob of shard * @param {Object} data.contracts - Dictionary of nodeID:{@link Contract} * @param {Object} data.trees - Dictionary of nodeID:merkleLeaves * @param {Object} data.challenges - Dictionary of nodeID:privateAuditData * @param {Object} data.meta - Dictionary of arbitrary nodeID:metadata */ function StorageItem(data) { if (!(this instanceof StorageItem)) { return new StorageItem(data); } data = merge({}, data); this.hash = null; this.fskey = null; this.shard = null; this.contracts = {}; this.contractsHDMap = {}; this.trees = data.trees || {}; this.challenges = data.challenges || {}; this.meta = data.meta || {}; this.modified = data.modified || Date.now(); this._init(data); } /** * Adds the trees and challenges to the item keyed by nodeID * @param {Contact} contact - The contact associated with the trees * @param {Audit|AuditStream} audit - The audit or challenge generator */ StorageItem.prototype.addAuditRecords = function(contact, audit) { this.trees[contact.nodeID] = audit.getPublicRecord(); this.challenges[contact.nodeID] = audit.getPrivateRecord(); return this; }; /** * Adds the contract data keyed by nodeID and hdKey * @param {Contact} contact - The contact associated with the trees * @param {Contract} contract - The storage contract instance */ StorageItem.prototype.addContract = function(contact, contract) { assert(contract instanceof Contract, 'Invalid contract supplied'); assert(contact &amp;&amp; contact.nodeID, 'contact.nodeID is expected'); this.contracts[contact.nodeID] = contract; var hdKey = contact.hdKey; if (hdKey) { this.contractsHDMap[hdKey] = contract; } return this; }; /** * Gets a contract data by a contact based on the hdKey or the nodeID * of the contact. It will return false if the contract is not found for the * contact, which will indicate that the contact is not authorized for * that specific contract. * @param {Contact} contact - The contact associated with the trees * @param {Contract} contract - The storage contract instance * @returns {Contract|Boolean} */ StorageItem.prototype.getContract = function(contact) { if (contact.hdKey) { return this.contractsHDMap[contact.hdKey] || false; } else { return this.contracts[contact.nodeID] || false; } }; /** * Deletes the contract for the given contact * @param {Contact} contact * @returns {Boolean} didRemoveContract */ StorageItem.prototype.removeContract = function(contact) { if (this.getContract(contact)) { if (contact.hdKey) { delete this.contractsHDMap[contact.hdKey]; } else { delete this.contracts[contact.nodeID]; } return true; } return false; }; /** * Adds the meta data keyed by nodeID * @param {Contact} contact - The contact associated with the trees * @param {Object} meta - Arbitrary metadata about the shard */ StorageItem.prototype.addMetaData = function(contact, meta) { this.meta[contact.nodeID] = meta; return this; }; /** * Updates the timestamp for the item */ StorageItem.prototype.updateTimestamp = function() { this.modified = Date.now(); return this; }; /** * Returns a plain object representation of the item */ StorageItem.prototype.toObject = function() { var contracts = {}; for (var c in this.contracts) { contracts[c] = this.contracts[c].toObject(); } return { hash: this.hash, fskey: this.fskey, shard: null, contracts: contracts, challenges: this.challenges, trees: this.trees, meta: this.meta, modified: this.modified }; }; /** * Initializes the item values with the given data * @private * @param {Object} data * @returns {StorageItem} */ StorageItem.prototype._init = function(data) { assert(typeof data === 'object', 'Invalid item data supplied'); this.shard = data.shard || null; this.hash = data.hash || null; this.fskey = data.fskey || null; for (var nodeID in data.contracts) { var contract = new Contract(data.contracts[nodeID]); this.addContract({ nodeID: nodeID, hdKey: contract.get('renter_hd_key') }, contract); } return this; }; module.exports = StorageItem; Ã— Search results Close "},"lib_storage_manager.js.html":{"id":"lib_storage_manager.js.html","title":"Source: lib/storage/manager.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/manager.js 'use strict'; var constants = require('../constants'); var assert = require('assert'); var StorageAdapter = require('./adapter'); var StorageItem = require('./item'); var merge = require('merge'); var EventEmitter = require('events').EventEmitter; var inherits = require('util').inherits; var Logger = require('kad-logger-json'); /** * Interface for managing contracts, shards, and audits * @constructor * @license AGPL-3.0 * @extends {EventEmitter} * @param {StorageAdapter} storage - Storage adapter to use * @param {Object} options * @param {Boolean} options.disableReaper - Don't perform periodic reaping of * stale contracts * @param {Object} [options.logger] - Logger to use for debugging * @param {Number} options.maxCapacity - Max number of bytes to allow in storage */ function StorageManager(storage, options) { if (!(this instanceof StorageManager)) { return new StorageManager(storage, options); } assert(storage instanceof StorageAdapter, 'Invalid storage adapter'); this._options = merge(Object.create(StorageManager.DEFAULTS), options); this._storage = storage; this._logger = this._options.logger || new Logger(0); this._initShardReaper(); } inherits(StorageManager, EventEmitter); StorageManager.DEFAULTS = { disableReaper: false, maxCapacity: Infinity }; /** * Loads the storage {@link Item} at the given key * @param {String} hash - Shard hash to load data for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageManager.prototype.load = function(hash, callback) { assert(typeof hash === 'string', 'Invalid key supplied'); assert(hash.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); this._storage.get(hash, function(err, item) { if (err) { return callback(err); } if (!(item instanceof StorageItem)) { return callback(new Error('Storage adapter provided invalid result')); } callback(null, item); }); }; /** * Saves the storage {@link StorageItem} at the given key * @param {StorageItem} item - The {@link StorageItem} to store * @param {Function} callback - Called on complete */ StorageManager.prototype.save = function(item, callback) { var self = this; assert(item instanceof StorageItem, 'Invalid storage item supplied'); assert(typeof callback === 'function', 'Callback function must be supplied'); self._storage.get(item.hash, function(err, existingItem) { self._storage.put( self._merge(existingItem, item), function(err) { if (err) { return callback(err); } callback(null); } ); }); }; /** * Merges two storage items together * @private */ StorageManager.prototype._merge = function(item1, item2) { return new StorageItem( merge.recursive( true, item1 ? ((item1 instanceof StorageItem) ? item1.toObject() : StorageItem(item1).toObject()) : {}, item2 ? ((item2 instanceof StorageItem) ? item2.toObject() : StorageItem(item2).toObject()) : {} ) ); }; /** * Opens the underlying storage adapter * @param {Function} callback - Called on complete */ StorageManager.prototype.open = function(callback) { this._storage._open(callback); }; /** * Closes the underlying storage adapter * @param {Function} callback - Called on complete */ StorageManager.prototype.close = function(callback) { this._storage._close(callback); }; /** * Enumerates all storage contracts and reaps stale data * @param {Function} callback - Called on complete */ StorageManager.prototype.clean = function(callback) { var self = this; var rstream = this._storage.createReadStream(); var timestamp = Date.now(); this._logger.info('starting shard reaper, checking for expired contracts'); rstream.on('data', function(item) { rstream.pause(); var total = Object.keys(item.contracts).length; var endedOrIncomplete = 0; for (var nodeID in item.contracts) { var ended = item.contracts[nodeID].get('store_end') &lt; timestamp; var incomplete = !item.contracts[nodeID].isComplete(); if (ended || incomplete) { endedOrIncomplete++; } } if (total === endedOrIncomplete) { self._logger.info('destroying shard/contract for %s', item.hash); self._storage.del(item.hash, function(/* err */) { rstream.resume(); }); } else { rstream.resume(); } }); rstream.on('end', function() { self._logger.info('flushing shards, some buckets will be inaccessible'); self._storage.flush(function(err) { /* istanbul ignore if */ if (err) { self._logger.warn('problem while flushing shards, %s', err.message); } self._logger.info('flushing shards finished'); callback(); }); }); }; /** * Initialize the shard reaper to check for stale contracts and reap shards * @private */ StorageManager.prototype._initShardReaper = function() { if (this._options.disableReaper) { return false; } setTimeout(this.clean.bind(this, this._initShardReaper.bind(this)), constants.CLEAN_INTERVAL); }; module.exports = StorageManager; Ã— Search results Close "},"lib_storage_migration.js.html":{"id":"lib_storage_migration.js.html","title":"Source: lib/storage/migration.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/migration.js 'use strict'; var assert = require('assert'); var StorageAdapter = require('./adapter'); var inherits = require('util').inherits; var EventEmitter = require('events').EventEmitter; var StorageItem = require('./item'); var WritableStream = require('readable-stream').Writable; /** * Migrates data stored with one {@link StorageAdapter} to another * @constructor * @license AGPL-3.0 * @param {StorageAdapter} source - The source adapter * @param {StorageAdapter} target - The migration destination */ function StorageMigration(source, target) { if (!(this instanceof StorageMigration)) { return new StorageMigration(source, target); } assert(source instanceof StorageAdapter, 'Invalid storage adapter supplied'); assert(target instanceof StorageAdapter, 'Invalid storage adapter supplied'); this.source = source; this.target = target; this.readyState = StorageMigration.STOPPED; this._isReady = false; EventEmitter.call(this); } inherits(StorageMigration, EventEmitter); StorageMigration.STOPPED = 0; StorageMigration.STARTED = 1; /** * Starts the migration process */ StorageMigration.prototype.start = function() { var self = this; assert( this.readyState === StorageMigration.STOPPED, 'Migration has already started' ); self.readyState = StorageMigration.STARTED; self._sourceStream = self.source.createReadStream(); self._targetStream = new WritableStream({ write: self._handleSourceObject.bind(self), objectMode: true }); self._targetStream.on('finish', self._handleSourceFinished.bind(self)); self._sourceStream.on('error', self._handleSourceError.bind(self)); self._targetStream.on('error', self._handleSourceError.bind(self)); return self._sourceStream.pipe(self._targetStream); }; /** * Stops the migration process */ StorageMigration.prototype.stop = function() { assert( this.readyState === StorageMigration.STARTED, 'Migration has already stopped' ); this._sourceStream.removeAllListeners(); this.readyState = StorageMigration.STOPPED; this._sourceStream = null; }; /** * Handles a data event from the source read stream and inserts it into the * the target adapter * @private * @param {StorageItem} sourceItem - Storage item from the source read stream */ StorageMigration.prototype._handleSourceObject = function(sourceItem, enc, cb) { var self = this; self.target.put(StorageItem(sourceItem), function(err) { if (err) { return cb(err); } self.target.get(sourceItem.hash, function(err, targetItem) { if (err) { return cb(err); } self.source.get(sourceItem.hash, function(err, fullSourceItem) { if (err) { return cb(err); } if (typeof fullSourceItem.shard.read === 'function') { return fullSourceItem.shard.pipe(targetItem.shard) .on('error', cb) .on('finish', cb); } cb(); }); }); }); }; /** * Handles the completion of the source stream read * @private */ StorageMigration.prototype._handleSourceFinished = function() { this.readyState = StorageMigration.STOPPED; this._sourceStream = null; this.emit('finish'); }; /** * Handles errors received from the underyling source stream * @private * @param {Error} error */ StorageMigration.prototype._handleSourceError = function(err) { this.readyState = StorageMigration.STOPPED; this._sourceStream = null; this.emit('error', err); }; module.exports = StorageMigration; Ã— Search results Close "},"lib_network_transport.js.html":{"id":"lib_network_transport.js.html","title":"Source: lib/network/transport.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/transport.js 'use strict'; const inherits = require('util').inherits; const kad = require('kad'); const portfinder = require('portfinder'); const natupnp = require('nat-upnp'); const ip = require('ip'); const merge = require('merge'); const utils = require('../utils'); const http = require('http'); const restify = require('restify'); const diglet = require('diglet'); const net = require('net'); const url = require('url'); const ShardServer = require('./shard-server'); /** * Custom HTTP transport adapter * @constructor * @license AGPL-3.0 * @param {kad.Contact} contact - Contact object to binding to port * @param {Object} options * @param {Logger} options.logger - Logger for diagnositcs * @param {Number} options.maxTunnels - Number of tunnels to provide to network * @param {Boolean} options.doNotTraverseNat - Do not try to punch out of NAT * @param {Object} options.tunnelGatewayRange * @param {Number} options.tunnelGatewayRange.min - Min port for gateway bind * @param {Number} options.tunnelGatewayRange.max - Max port for gateway bind * @param {Number} options.listenPort - Different port for the server to listen on (optional) * @param {StorageManager} options.storageManager */ function Transport(contact, options) { if (!(this instanceof Transport)) { return new Transport(contact, options); } this._opts = merge(Object.create(Transport.DEFAULTS), options); this._queuedResponses = {}; this._maxTunnels = this._opts.maxTunnels; this._doNotTraverseNat = this._opts.doNotTraverseNat; this._tunnelGatewayRange = this._opts.tunnelGatewayRange; this._server = restify.createServer({ name: 'storj', handleUpgrades: true }); kad.RPC.call(this, contact, options); this.on( 'MESSAGE_DROP', kad.transports.HTTP.prototype._handleDroppedMessage.bind(this) ); } Transport.DEFAULTS = { maxTunnels: 3, doNotTraverseNat: false, tunnelGatewayRange: { min: 0, max: 0 } }; /** * Triggered when the max connections limit is reached * @event Transport#connectionLimitReached */ inherits(Transport, kad.RPC); /** * Opens the transport, trying UPnP to become publicly addressable and falling * back to using a Tunnel * @private * @param {Function} callback */ Transport.prototype._open = function(callback) { const self = this; this.tunnelServer = new diglet.Server({ logger: this._log, proxyPortRange: this._opts.tunnelGatewayRange, proxyMaxConnections: 12, maxProxiesAllowed: this._opts.maxTunnels }); if (this._opts.storagePath) { this.shardServer = new ShardServer({ storagePath: this._opts.storagePath, storageManager: this._opts.storageManager, logger: this._log, nodeID: this._contact.nodeID }); } if (self._doNotTraverseNat) { self._isPublic = true; // used to determine tunneling self._publicIp = ip.isPublic(self._contact.address); // used for UI status self._checkIfReachable(function(reachable) { self._portOpen = reachable; }); self._requiresTraversal = false; /* istanbul ignore next */ self._log.warn( 'your address is %s and traversal strategies are disabled', self._publicIp ? 'public' : 'private' ); return self._bindServer(callback); } self._requiresTraversal = true; function _traverseNat() { self._log.warn( 'you are not publicly reachable, trying traversal strategies...' ); self._forwardPort(function(err, wanip, port) { self._isPublic = self._portOpen = !err; if (self._isPublic) { self._contact.port = port || self._contact.port; self._log.info('node bound and port mapped: %s', self._contact.port); } self._bindServer(callback); self._contact.address = wanip || self._contact.address; }); } self._bindServer(function() { self._checkIfReachable(function(isReachable) { if (isReachable) { self._isPublic = self._portOpen = true; return callback(null); } self._close(); _traverseNat(); }); }); }; /** * Sets up server routes * @private */ Transport.prototype._bindServer = function(callback) { const self = this; // Disable TCP Nagle algorithm self._server.on('connection', (sock) =&gt; sock.setNoDelay(true)); // Middleware self._server.use(self._routeTunnelProxies.bind(self)); self._server.use(restify.CORS()); self._server.opts(/.*/, self._handleOpts.bind(self)); // Routes self._server.post( '/', restify.bodyParser(), self._handleRPC.bind(self) ); if (this._opts.storagePath) { self._server.post( '/shards/:hash', restify.queryParser(), self.shardServer.routeConsignment.bind(self.shardServer) ); self._server.get( '/shards/:hash', restify.queryParser(), self.shardServer.routeRetrieval.bind(self.shardServer) ); } const port = self._opts.listenPort ? self._opts.listenPort : self._contact.port; self._server.listen(port, callback); }; /** * _handleOpts handles incomming OPTIONS requests. These requests are preflight * requests for Cross-Origin requests enforced by browser security. This * function essentially allows all methods and headers for any origin, allowing * any domain to make a request to a farmer. * @private */ Transport.prototype._handleOpts = function(req, res, next) { res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Methods', req.header('Access-Control-Request-Method')); res.header('Access-Control-Allow-Headers', req.header('Access-Control-Request-Headers')); res.send(200); return next(); }; /** * Handles incoming RPC messages * @private */ Transport.prototype._handleRPC = function(req, res) { const self = this; let message; try { message = new kad.Message(req.body); } catch (err) { res.send(400, new Error('Invalid RPC message')); self.receive(null); return; } if (kad.Message.isRequest(message)) { self._queuedResponses[message.id] = res; } self.receive(message.serialize(), {}); }; /** * Routes incoming requests to tunnels if any * @private */ Transport.prototype._routeTunnelProxies = function(req, res, next) { var self = this; var targetNodeId = req.header('x-storj-node-id'); var upgradeReq = res.claimUpgrade ? res.claimUpgrade() : null; if (!targetNodeId || targetNodeId === self._contact.nodeID) { return next(); } if (upgradeReq) { self.tunnelServer.routeWebSocketConnection( targetNodeId, req, upgradeReq.socket, () =&gt; null ); } else { self.tunnelServer.routeHttpRequest( targetNodeId, req, res, () =&gt; null ); } }; /** * Implement the message dispatcher for RPC * @private */ Transport.prototype._send = function(data, contact) { var self = this; var parsedMessage = JSON.parse(data.toString()); if (self._queuedResponses[parsedMessage.id]) { self._queuedResponses[parsedMessage.id].send(200, parsedMessage); delete self._queuedResponses[parsedMessage.id]; return; } if (!contact.valid()) { return self.receive(null); } var client = restify.createJsonClient({ version: '*', url: url.format({ hostname: contact.address, port: contact.port, protocol: 'http:' }), headers: { 'content-type': 'application/json', 'x-storj-node-id': contact.nodeID }, agent: new http.Agent({ keepAlive: true, keepAliveMsecs: 25000 }), // NB: Disable TCP Nagle algorithm - use `signRequest` options to // NB: manipulate the request object before sending signRequest: function(req) { /* istanbul ignore next */ req.setNoDelay(true); } }); client.post('/', parsedMessage, (err, req, res, data) =&gt; { if (err) { self._log.warn('error returned from remote host: %s', err.message); return self.receive(null); } let message; try { message = kad.Message(data); } catch (err) { return self.receive(null); } self.receive(message.serialize(), {}); }); }; /** * Closes the transport * @private */ Transport.prototype._close = function() { this._server.close(); }; /** * Checks if we are publicly reachable * @private * @param {Function} */ Transport.prototype._checkIfReachable = function(callback) { if (ip.isPrivate(this._contact.address)) { return callback(false); } var sock = net.connect({ host: this._contact.address, port: this._contact.port }); sock.once('error', () =&gt; { callback(false); sock.removeAllListeners(); sock.destroy(); }); sock.once('connect', () =&gt; { callback(true); sock.removeAllListeners(); sock.end(); }); }; /** * Creates a port mapping with UPnP * @param {Number} port - The port to forward * @param {Function} callback - Callback function */ Transport.prototype.createPortMapping = function(port, callback) { var self = this; var natupnpClient = natupnp.createClient(); natupnpClient.portMapping({ public: port, private: port, ttl: 0 }, function(err) { if (err) { self._log.warn('could not connect to NAT device via UPnP: %s', port); return callback(err); } natupnpClient.externalIp(function(err, wanip) { if (err) { self._log.warn('could not obtain public IP address'); return callback(err); } if (!net.isIP(wanip)) { self._log.warn('UPnP device has no valid IP address: %s', JSON.stringify(wanip)); return callback(new Error('UPnP device has no valid IP address')); } if (ip.isPrivate(wanip)) { self._log.warn('UPnP device has no public IP address: %s', wanip); return callback(new Error('UPnP device has no public IP address')); } self._log.info('successfully traversed NAT via UPnP: %s:%s', wanip, port); callback(null, wanip, port); }); }); }; /** * Resolve random port to use for opening a gateway * @private * @param {Number} port * @param {Function} callback */ Transport.prototype._getPort = function(callback) { var self = this; if (self._contact.port) { return callback(null, self._contact.port); } portfinder.basePort = Math.floor(Math.random() * (65535 - 1024) + 1024); portfinder.getPort(callback); }; /** * Forwards a port and resolves the public IP * @private * @param {Function} callback */ Transport.prototype._forwardPort = function(callback) { var self = this; self._getPort(function(err, port) { if (err) { self._log.warn('could not obtain port'); return callback(err); } self.createPortMapping(port, callback); }); }; /** * Sends the RPC message to the given contact * @param {Contact} contact * @param {kad.Message} message * @param {Function} callback */ Transport.prototype.send = function(contact, message, callback) { if (kad.Message.isResponse(message)) { return kad.RPC.prototype.send.apply(this, arguments); } if (!utils.isValidContact(contact, !!process.env.STORJ_ALLOW_LOOPBACK)) { return callback(new Error('Invalid or forbidden contact address')); } kad.RPC.prototype.send.apply(this, arguments); }; module.exports = Transport; Ã— Search results Close "},"lib_sips_0003_trigger-manager.js.html":{"id":"lib_sips_0003_trigger-manager.js.html","title":"Source: lib/sips/0003/trigger-manager.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/sips/0003/trigger-manager.js 'use strict'; var assert = require('assert'); /** * Implements behavior triggers as described in SIP-0003 * @constructor * @license AGPL-3.0 * @see https://github.com/storj/sips/blob/master/sip-0003.md */ function TriggerManager(options) { if (!(this instanceof TriggerManager)) { return new TriggerManager(options); } this._options = options; this._authorized = {}; this._behaviors = {}; } /** * Adds a trigger handler for the given nodeID and behavior * @param {String|Array} nodeID - The nodeID(s) to authorize for the trigger * (supports `*` wildcard) * @param {Object} behaviors - Behavior name to {TriggerManager~triggerHandler}s */ TriggerManager.prototype.add = function(nodeID, behaviors) { var self = this; if (Array.isArray(nodeID)) { return nodeID.forEach(function(nodeID) { self.add(nodeID, behaviors); }); } for (var behavior in behaviors) { assert( typeof behaviors[behavior] === 'function', 'Trigger handler must be a function' ); if (!this._authorized[behavior]) { this._authorized[behavior] = []; } if (this._authorized[behavior].indexOf(nodeID) === -1) { this._authorized[behavior].push(nodeID); } this._behaviors[nodeID + ':' + behavior] = behaviors[behavior]; } }; /** * Removes a trigger handler for the given nodeID and behavior * @param {String|Array} nodeID - The nodeID(s) to deauthorize for the trigger * @param {String|Array} behaviors - Behavior name to unregister */ TriggerManager.prototype.remove = function(nodeID, behavior) { var self = this; if (Array.isArray(nodeID)) { return nodeID.forEach(function(nodeID) { if (Array.isArray(behavior)) { return behavior.forEach(function(behavior) { self.remove(nodeID, behavior); }); } self.remove(nodeID, behavior); }); } if (this._authorized[behavior]) { var index = this._authorized[behavior].indexOf(nodeID); if (index !== -1) { this._authorized[behavior].splice(index, 1); } } delete this._behaviors[nodeID + ':' + behavior]; }; /** * Process a received trigger message * @param {Object} messageParams - The received message params * @param {TriggerManager~processCallback} callback - Result of trigger process */ TriggerManager.prototype.process = function(messageParams, callback) { var authorized = this._authorized[messageParams.behavior]; var allowAnySource = authorized ? authorized.indexOf('*') !== -1 : false; var sourceNodeId = allowAnySource || messageParams.contact.nodeID; if (!authorized) { return callback(new Error('No trigger handler defined for behavior')); } if (!allowAnySource &amp;&amp; authorized.indexOf(sourceNodeId) === -1) { return callback(new Error('Not authorized to process trigger')); } this._behaviors[sourceNodeId + ':' + messageParams.behavior]( messageParams, callback, this.remove.bind(this, sourceNodeId, messageParams.behavior) ); }; /** * Called when a trigger is received from authorized source * @callback TriggerManager~triggerHandler * @param {Object} messageParams - The RPC message parameters * @param {TriggerManager~replyToSender} replyToSender - Respond to the trigger * @param {TriggerManager~destroyTrigger} destroyTrigger - Unregisters trigger */ /** * Passed to the trigger handler for replying to the message * @callback TriggerManager~replyToSender * @param {Error|null} err - Optional error to respond with * @param {Object} params - Response parameters to return */ /** * Optionally called from trigger handler to unregister the trigger handler * @callback TriggerManager~destroyTrigger */ /** * Called upon the processing of a trigger message * @callback TriggerManager~processCallback * @param {Error|null} err - Optional error resulting from processing * @param {Object} params - Response parameters to send back */ module.exports = TriggerManager; Ã— Search results Close "},"lib_audit-tools_verification.js.html":{"id":"lib_audit-tools_verification.js.html","title":"Source: lib/audit-tools/verification.js","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/audit-tools/verification.js 'use strict'; var assert = require('assert'); var utils = require('../utils'); /** * Interface for verifying the result of an audit proof * @constructor * @license LGPL-3.0 * @param {Array} proof - The result of {@link ProofStream#getProofResult} */ function Verification(proof) { if (!(this instanceof Verification)) { return new Verification(proof); } assert(Array.isArray(proof), 'Proof must be an array'); this._proof = proof; } /** * Extracts the challenge response from the proof * @private * @param {Array} response - Challenge response received from farmer * @returns {String} leaf */ Verification.prototype._getChallengeResponse = function(tuple) { var data = tuple || this._proof; if (data.length === 1) { return utils.rmd160sha256b(data[0]); } if (Array.isArray(data[0])) { return this._getChallengeResponse(data[0]); } else { return this._getChallengeResponse(data[1]); } }; /** * Verifies the proof given the merkle root and tree depth * @param {String} merkleRoot - Merkle root * @param {Number} totalDepth - Depth of merkle tree * @returns {Array} result - Array with expected result and verified result */ Verification.prototype.verify = function(root, totaldepth) { function _collapse(proof, leaf, depth) { if (depth === 0) { assert(proof.length === 1, 'Invalid proof structure'); const proofhash = utils.rmd160sha256b(proof[0]); assert(Buffer.compare(proofhash, leaf) === 0, 'Invalid proof value'); return leaf; } var hashL, hashR; if (Array.isArray(proof[0])) { hashL = _collapse(proof[0], leaf, depth - 1); } else { hashL = proof[0]; } if (Array.isArray(proof[1])) { hashR = _collapse(proof[1], leaf, depth - 1); } else { hashR = proof[1]; } return utils.rmd160sha256b(Buffer.concat([hashL, hashR])); } return [ _collapse(this._proof, this._getChallengeResponse(), totaldepth - 1), root ]; }; module.exports = Verification; Ã— Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Modules Classes AuditStream Contact Contract EmbeddedStorageAdapter ExchangeReport FarmerInterface KeyPair Monitor Network OfferManager OfferStream ProofStream Protocol RAMStorageAdapter RenterInterface ShardServer StorageAdapter StorageItem StorageManager StorageMigration Transport TriggerManager Verification Events finish Triggered when the stream has ended Source: lib/audit-tools/audit-stream.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Inherited From: Network#event:unhandledOffer Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Inherited From: Network#event:unhandledOfferResolved Source: lib/network/index.js update Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description stats Object Source: lib/network/monitor.js connected Triggered when the node has entered the overlay network Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Source: lib/network/index.js error Triggered when an error occurs Source: lib/network/index.js ready Triggered when the transport's network interface is ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Source: lib/network/index.js data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/contract/offer-stream.js end Triggered when the maximum number of offers are received and processed Source: lib/contract/offer-stream.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/contract/offer-stream.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Inherited From: Network#event:unhandledOffer Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Inherited From: Network#event:unhandledOfferResolved Source: lib/network/index.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/network/shard-server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description item StorageItem The item associated with the download Source: lib/network/shard-server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description item StorageItem The item associated with the upload Source: lib/network/shard-server.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js ready Triggered when the adapter is ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Source: lib/storage/adapter.js connectionLimitReached Triggered when the max connections limit is reached Source: lib/network/transport.js Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Classes Classes AuditStream Contact Contract EmbeddedStorageAdapter ExchangeReport FarmerInterface KeyPair Monitor Network OfferManager OfferStream ProofStream Protocol RAMStorageAdapter RenterInterface ShardServer StorageAdapter StorageItem StorageManager StorageMigration Transport TriggerManager Verification Events finish Triggered when the stream has ended Source: lib/audit-tools/audit-stream.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Inherited From: Network#event:unhandledOffer Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Inherited From: Network#event:unhandledOfferResolved Source: lib/network/index.js update Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description stats Object Source: lib/network/monitor.js connected Triggered when the node has entered the overlay network Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Source: lib/network/index.js error Triggered when an error occurs Source: lib/network/index.js ready Triggered when the transport's network interface is ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Source: lib/network/index.js data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/contract/offer-stream.js end Triggered when the maximum number of offers are received and processed Source: lib/contract/offer-stream.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/contract/offer-stream.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Inherited From: Network#event:unhandledOffer Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Inherited From: Network#event:unhandledOfferResolved Source: lib/network/index.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/network/shard-server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description item StorageItem The item associated with the download Source: lib/network/shard-server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description item StorageItem The item associated with the upload Source: lib/network/shard-server.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js ready Triggered when the adapter is ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Source: lib/storage/adapter.js connectionLimitReached Triggered when the max connections limit is reached Source: lib/network/transport.js Ã— Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Tutorials Classes AuditStream Contact Contract EmbeddedStorageAdapter ExchangeReport FarmerInterface KeyPair Monitor Network OfferManager OfferStream ProofStream Protocol RAMStorageAdapter RenterInterface ShardServer StorageAdapter StorageItem StorageManager StorageMigration Transport TriggerManager Verification Events finish Triggered when the stream has ended Source: lib/audit-tools/audit-stream.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Inherited From: Network#event:unhandledOffer Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Inherited From: Network#event:unhandledOfferResolved Source: lib/network/index.js update Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description stats Object Source: lib/network/monitor.js connected Triggered when the node has entered the overlay network Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Source: lib/network/index.js error Triggered when an error occurs Source: lib/network/index.js ready Triggered when the transport's network interface is ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Source: lib/network/index.js data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/contract/offer-stream.js end Triggered when the maximum number of offers are received and processed Source: lib/contract/offer-stream.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/contract/offer-stream.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Inherited From: Network#event:unhandledOffer Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Inherited From: Network#event:unhandledOfferResolved Source: lib/network/index.js error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/network/shard-server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description item StorageItem The item associated with the download Source: lib/network/shard-server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description item StorageItem The item associated with the upload Source: lib/network/shard-server.js add Triggered when a new item is added Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js ready Triggered when the adapter is ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Source: lib/storage/adapter.js connectionLimitReached Triggered when the max connections limit is reached Source: lib/network/transport.js Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Implementation of the Storj protocol for Node.js. You must have Node.js v6.9.1, Python v2.x.x, and Git installed. Complete documentation can be found here. npm install storj-lib --saveNotices The BridgeClient methods storeFileInBucket and resolveFileFromPointers are deprecated, please see node-libstorj and libstorj for file transfer, as well as the client libraries at https://github.com/Storj/awesome-storj#client-libraries LicenseStorj Core - Implementation of the Storj protocol for Node.js Copyright (C) 2016 Storj Labs, Inc This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Certain parts of this program are licensed under the GNU Lesser General Public License as published by the Free Software Foundation. You can redistribute it and/or modify it under the terms either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program. If not, see http://www.gnu.org/licenses/. Ã— Search results Close "},"AuditStream.html":{"id":"AuditStream.html","title":"Class: AuditStream","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: AuditStream AuditStream new AuditStream(audits) Represents a streaming audit challenge generator Parameters: Name Type Description audits Number Total number of challenges to generate License: LGPL-3.0 Source: lib/audit-tools/audit-stream.js Fires: AuditStream#event:finish Methods &lt;static&gt; fromRecords(challenges, tree) Returns a new instance from the predefined challenges and tree Parameters: Name Type Description challenges Array The precomputed challenges tree Array The bottom leaves of the existing merkle tree Source: lib/audit-tools/audit-stream.js Returns: Type AuditStream getPrivateRecord() Returns the challenges, the tree depth, and merkle root Source: lib/audit-tools/audit-stream.js Returns: challenge - Private audit record with challenges Type Object getPublicRecord() Returns the bottom leaves of the merkle tree for sending to farmer Source: lib/audit-tools/audit-stream.js Returns: leaves - Bottom merkle leaves of audit tree Type Array Events finish Triggered when the stream has ended Source: lib/audit-tools/audit-stream.js Ã— Search results Close "},"Contact.html":{"id":"Contact.html","title":"Class: Contact","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Contact Contact new Contact(contact) Represents a Storj contact (or peer) Parameters: Name Type Description contact Object Properties Name Type Argument Description address String Hostname of IP address port Number RPC port number nodeID String 160 bit node ID (hex) hdKey String &lt;optional&gt; extended hd public key hdIndex String &lt;optional&gt; derivation index for node userAgent String &lt;optional&gt; User agent identifier protocol String Semver tag for compatibility License: LGPL-3.0 Source: lib/network/contact.js Methods &lt;static&gt; isValidUrl(uri) Indicates if URL is valid contact Parameters: Name Type Description uri String Source: lib/network/contact.js Returns: Type Boolean Ã— Search results Close "},"Contract.html":{"id":"Contract.html","title":"Class: Contract","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Contract Contract new Contract(contract, criteria) Represents a storage contract between a renter and a farmer Parameters: Name Type Description contract Object Properties Name Type Argument Description type String Unique identifier for the contract renter_hd_key String &lt;optional&gt; Node extended public key in base58 renter_hd_index Number &lt;optional&gt; Derivation index for signature renter_id String Node ID of the renter renter_signature String Renter's cryptographic signature farmer_id String Node ID of the farmer farmer_signature String Farmer's cryptographic signature data_size Number Number of bytes to store data_hash String RIPEMD-160 SHA-256 hash of the data store_begin Number UNIX timestamp to start contract store_end Number UNIX timestamp to end the contract audit_count Number Number of audits renter will perform payment_storage_price Number Total price for storage payment_download_price Number Price per download payment_destination String Bitcoin address to send funds criteria Object Properties Name Type Description size Number Criteria degree OPCODE duration Number Criteria degree OPCODE availability Number Criteria degree OPCODE speed Number Criteria degree OPCODE Version: 0 License: AGPL-3.0 Source: lib/contract/index.js Members &lt;static&gt; CRITERIA Defines some default criteria of a Contract Source: lib/contract/index.js &lt;static&gt; DEFAULTS Defines some default properties of a Contract Source: lib/contract/index.js &lt;static&gt; MATRIX Defines the criteria matrix for a Contract Source: lib/contract/index.js &lt;static&gt; Schema Defines the JSON Schema of a Contract Source: lib/contract/index.js Methods &lt;static&gt; compare(c1, c2) Compares two contracts against each other Parameters: Name Type Description c1 Contract Contract to compare c2 Contract Contract to compare Source: lib/contract/index.js Returns: Type Boolean &lt;static&gt; createTopic(criteria) Create a topical OPCODE byte sequence from the provided criteria Parameters: Name Type Description criteria Object Properties Name Type Description size Number Criteria degree OPCODE duration Number Criteria degree OPCODE availability Number Criteria degree OPCODE speed Number Criteria degree OPCODE Source: lib/contract/index.js Returns: Type Buffer &lt;static&gt; diff(c1, c2) Returns the property names between two contracts that differ Parameters: Name Type Description c1 Contract Contract to compare c2 contract Contract to compare Source: lib/contract/index.js Returns: changedProperties Type Array.&lt;String&gt; &lt;static&gt; fromBuffer(buffer) Creates a contract from a Buffer Parameters: Name Type Description buffer Buffer Raw binary blob of contract data Source: lib/contract/index.js Returns: Type Contract &lt;static&gt; fromJSON(json) Creates a contract from a JSON string Parameters: Name Type Description json String JSON encoded contract Source: lib/contract/index.js Returns: Type Contract &lt;static&gt; fromObject(object) Creates a contract from a plain object Parameters: Name Type Description object Object Dictionary of contract data Source: lib/contract/index.js Returns: Type Contract get(field_name) Returns the value for the given contract property Parameters: Name Type Description field_name String Contract property to get Source: lib/contract/index.js Returns: value Type String | Number | null getHash() Calculates the SHA-256 hash of the serialized contract Source: lib/contract/index.js Returns: Type Buffer getSigningData() Returns the string representation of the contract, minus the signature fields, sorted alphanumerically for signing and verifying Source: lib/contract/index.js Returns: Type String getTopicBuffer() Return OPCODE byte sequence for contract publication topic Source: lib/contract/index.js Returns: Type Buffer getTopicString() Return OPCODE byte sequence for contract publication topic as hex string Source: lib/contract/index.js Returns: Type String isComplete() Checks if the contract is complete Source: lib/contract/index.js Returns: completed Type Boolean set(field_name) Sets the contract property to the given value Parameters: Name Type Description field_name String Contract property to get Source: lib/contract/index.js Returns: value Type String | Number | null sign(actor, secret) Signs the contract as the given actor Parameters: Name Type Description actor String One of 'farmer' or 'renter' secret Buffer ECDSA private key Source: lib/contract/index.js Returns: signature Type String signExternal(secret) Signs the contract with the proved key and returns the signature Parameters: Name Type Description secret String ECDSA private key Source: lib/contract/index.js Returns: externalSignature Type String toBuffer() Converts the contract to Buffer Source: lib/contract/index.js Returns: Type Buffer toJSON() Converts the contract to JSON string Source: lib/contract/index.js Returns: Type String toObject() Converts the contract to a plain object Source: lib/contract/index.js Returns: Type Object update(fields) Applies the provided fields to the contract and validates it Parameters: Name Type Description fields Object Contract properties to update Source: lib/contract/index.js Returns: self Type Contract verify(actor, pubkeyhash) Verify the contract signature for the given actor Parameters: Name Type Description actor String One of 'farmer' or 'renter' pubkeyhash Buffer ECDSA nodeID Source: lib/contract/index.js Returns: isValidSignature Type Boolean verifyExternal(signature, pubkeyhash) Verify the provided signature for the contract Parameters: Name Type Description signature String The contract signature to verify pubkeyhash String ECDSA nodeID Source: lib/contract/index.js Returns: isValidSignature Type Boolean Ã— Search results Close "},"EmbeddedStorageAdapter.html":{"id":"EmbeddedStorageAdapter.html","title":"Class: EmbeddedStorageAdapter","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: EmbeddedStorageAdapter EmbeddedStorageAdapter new EmbeddedStorageAdapter(storageDirPath) Implements an LevelDB/KFS storage adapter interface Parameters: Name Type Description storageDirPath String Path to store the level db License: AGPL-3.0 Source: lib/storage/adapters/embedded.js Extends StorageAdapter Methods createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Inherited From: StorageAdapter#createReadStream Source: lib/storage/adapter.js Returns: Type ReadableStream del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Inherited From: StorageAdapter#del Source: lib/storage/adapter.js flush(callback) Calls the implemented StorageAdapter#_flush Parameters: Name Type Description callback function Called with error or null Inherited From: StorageAdapter#flush Source: lib/storage/adapter.js get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#get Source: lib/storage/adapter.js peek(key, callback) Calls the implemented StorageAdapter#_peek and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#peek Source: lib/storage/adapter.js put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Inherited From: StorageAdapter#put Source: lib/storage/adapter.js size( [key], callback) Calls the implemented StorageAdapter#_size Parameters: Name Type Argument Description key String &lt;optional&gt; Optional file key callback function Called with error or number of bytes stored Inherited From: StorageAdapter#size Source: lib/storage/adapter.js Events add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js Ã— Search results Close "},"ExchangeReport.html":{"id":"ExchangeReport.html","title":"Class: ExchangeReport","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: ExchangeReport ExchangeReport new ExchangeReport(options) Represents a report to a bridge regarding the result of a shard exchange Parameters: Name Type Description options Object Properties Name Type Argument Description reporterId String farmerId String &lt;optional&gt; clientId String &lt;optional&gt; Source: lib/exchange-report.js Methods begin(dataHash) Starts recording duration of exchange Parameters: Name Type Description dataHash String The shard hash as reference Source: lib/exchange-report.js end(resultCode, resultMessage) Ends the recording time a set result code and message Parameters: Name Type Description resultCode Number Exchange result code resultMessage String Exchange result message Source: lib/exchange-report.js toObject() Returns a plain report object Source: lib/exchange-report.js Returns: Type Object Ã— Search results Close "},"FarmerInterface.html":{"id":"FarmerInterface.html","title":"Class: FarmerInterface","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: FarmerInterface FarmerInterface new FarmerInterface(options) Creates and a new farmer interface Parameters: Name Type Description options Object Properties Name Type Argument Default Description paymentAddress String Optional payment address opcodeSubscriptions Array Contract opcodes to farm maxOfferConcurrency Number Max offers to have pending contractNegotiator FarmerInterface~negotiator keyPair KeyPair Node's cryptographic identity storageManager StorageManager Storage manager backend bridges String An array of bridges to connect and accept contracts logger Object Logger instance seedList Array List of seed URIs to join rpcAddress String Public node IP or hostname rpcPort Number Listening port for RPC doNotTraverseNat Boolean Skip NAT traversal strategies maxTunnels Number Max number of tunnels to provide tunnelServerPort Number Port for tunnel server to use tunnelGatewayRange Object Properties Name Type Description min Number Min port for gateway binding max Number Max port for gateway binding offerBackoffLimit Number &lt;optional&gt; 4 Do not send offers if more than N transfers are active joinRetry Object &lt;optional&gt; Properties Name Type Argument Description times Number &lt;optional&gt; Times to retry joining net interval Number &lt;optional&gt; MS to wait before retrying maxShardSize Number &lt;optional&gt; Max number of bytes to allow as contract shard size Properties: Name Type Description keyPair KeyPair storageManager StorageManager node kad.Node The underlying DHT node triggerManager TriggerManager contact Contact transportAdapter Transport router kad.Router The underlying DHT router dataChannelServer DataChannelServer License: AGPL-3.0 Source: lib/network/farmer.js Fires: Network#event:ready Extends Network Methods connect(uri, callback) Connects to the node at the given URI Parameters: Name Type Description uri String The storj protocol URI to connect callback function Called on connection or error Inherited From: Network#connect Source: lib/network/index.js connectBridges() Will connect to configured bridges to start receiving storage contracts from them. If the contact is already at the bridge it will update the contact details, otherwise it will add the contact to and begin the benchmarking phase. Source: lib/network/farmer.js getPaymentAddress() Returns the payment address supplied or the derived one from keypair Source: lib/network/farmer.js Returns: Type String handleAlloc(params, callback) Handles ALLOC messages Parameters: Name Type Description params Object callback Protocol~handleConsignCallback Source: lib/network/farmer.js join(callback) Wraps the super call to Network#join to listen for contract after successfully establishing a connection to the network Parameters: Name Type Description callback function Called on successful join Overrides: Network#join Source: lib/network/farmer.js leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Inherited From: Network#leave Source: lib/network/index.js noSpaceLeft() This will change the state of the farmer so that it will stop receiving messages to store data. Source: lib/network/farmer.js ping(neighbor, callback) Will ping a neighbor Parameters: Name Type Description neighbor String A contact callback function Called on connection or error Inherited From: Network#ping Source: lib/network/index.js publish(topic, contents, options) Publishes a topic with content to the network Parameters: Name Type Description topic String The serialized opcode topic contents Object Arbitrary publication contents options Object Options to pass to kad-quasar Inherited From: Network#publish Source: lib/network/index.js runSpaceCheck() Mark if there is space available for accepting offers Source: lib/network/farmer.js subscribe(topic, handler) Subscribes to a topic on the network Parameters: Name Type Description topic String The serialized opcode topic handler Object Function to handle received publications Inherited From: Network#subscribe Source: lib/network/index.js Type Definitions negotiator(contract) Called when a contract is found that meets subscription criteria and allows us to modify the contract terms if we desire and then uses the return value to determine if we should send the renter an offer Parameters: Name Type Description contract Contract The contract object to negotiate Source: lib/network/farmer.js Returns: Type Boolean Events connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Inherited From: Network#event:unhandledOffer Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Inherited From: Network#event:unhandledOfferResolved Source: lib/network/index.js Ã— Search results Close "},"KeyPair.html":{"id":"KeyPair.html","title":"Class: KeyPair","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: KeyPair KeyPair new KeyPair(privateKey) Represents a ECDSA key pair Parameters: Name Type Description privateKey String | Buffer | undefined WIF encoded ECDSA private key License: LGPL-3.0 Source: lib/crypto-tools/keypair.js Methods getAddress() Returns the bitcoin address version of the nodeID Source: lib/crypto-tools/keypair.js Returns: address - Base58 encoded address Type String getNodeID() Returns the NodeID derived from the public key Source: lib/crypto-tools/keypair.js Returns: nodeID - RIPEMD160 hash of public key Type String getPrivateKey() Returns the private key Source: lib/crypto-tools/keypair.js Returns: key Type String getPrivateKeyPadded() Returns the private key padded at 32 bytes Source: lib/crypto-tools/keypair.js Returns: key Type String getPublicKey() Returns the public key Source: lib/crypto-tools/keypair.js Returns: key Type String sign(message, options) Signs the supplied message with the private key Parameters: Name Type Description message String | Buffer The message to sign options Object Properties Name Type Argument Default Description compact Boolean &lt;optional&gt; true Compact signature format Source: lib/crypto-tools/keypair.js Returns: signature Type String Ã— Search results Close "},"module-storj.html":{"id":"module-storj.html","title":"Module: storj","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj License: (AGPL-3.0 AND LGPL-3.0) Source: index.js Members &lt;static&gt; AuditStream AuditStream Source: index.js &lt;static&gt; constants module:storj/constants Source: index.js &lt;static&gt; Contact Contact Source: index.js &lt;static&gt; Contract Contract Source: index.js &lt;static&gt; deps module:storj/deps Source: index.js &lt;static&gt; EmbeddedStorageAdapter EmbeddedStorageAdapter Source: index.js &lt;static&gt; Farmer Farmer Source: index.js &lt;static&gt; KeyPair KeyPair Source: index.js &lt;static&gt; Monitor Monitor Source: index.js &lt;static&gt; Network Network Source: index.js &lt;static&gt; OfferManager OfferManager Source: index.js &lt;static&gt; OfferStream OfferStream Source: index.js &lt;static&gt; ProofStream ProofStream Source: index.js &lt;static&gt; Protocol Protocol Source: index.js &lt;static&gt; RAMStorageAdapter RAMStorageAdapter Source: index.js &lt;static&gt; Renter Renter Source: index.js &lt;static&gt; ShardServer ShardServer Source: index.js &lt;static&gt; sips module:storj/sips Source: index.js &lt;static&gt; StorageAdapter StorageAdapter Source: index.js &lt;static&gt; StorageItem StorageItem Source: index.js &lt;static&gt; StorageManager StorageManager Source: index.js &lt;static&gt; StorageMigration StorageMigration Source: index.js &lt;static&gt; Transport Transport Source: index.js &lt;static&gt; utils module:storj/utils Source: index.js &lt;static&gt; Verification Verification Source: index.js &lt;static&gt; version module:storj/version Source: index.js Ã— Search results Close "},"module-storj_constants.html":{"id":"module-storj_constants.html","title":"Module: storj/constants","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/constants License: LGPL-3.0 Source: lib/constants.js Members &lt;inner, constant&gt; AUDIT_BYTES :Number Number of bytes for audit challenge Type: Number Source: lib/constants.js &lt;inner, constant&gt; CIPHER_ALG :String Cipher/Decipher algorithm Type: String Source: lib/constants.js &lt;inner, constant&gt; CLEAN_INTERVAL :Number Interval for reaping stale shards Type: Number Source: lib/constants.js &lt;inner, constant&gt; CONSIGN_THRESHOLD :Number Threshold for consign time Type: Number Source: lib/constants.js &lt;inner, constant&gt; HD_KEY_DERIVATION_PATH Source: lib/constants.js &lt;inner, constant&gt; MAX_CONCURRENT_AUDITS :Number Number of concurrent audits Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_CONCURRENT_OFFERS :Number Number of concurrent offers Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_FIND_TUNNEL_RELAYS Source: lib/constants.js &lt;inner, constant&gt; MAX_NODE_INDEX Source: lib/constants.js &lt;inner, constant&gt; NET_REENTRY :Number Max wait time before re-entering net Type: Number Source: lib/constants.js &lt;inner, constant&gt; NONCE_EXPIRE :Number Time to honor a signed message Type: Number Source: lib/constants.js &lt;inner, constant&gt; OFFER_TIMEOUT :Number Max wait time for storage offer Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_CONTRACT_PREFIX :Number Prefix opcode for contracts Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_HIGH :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_LOW :Number Opcode for low criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_MED :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_NULL :Number Opcode for null criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_TUNDCX_PREFIX :Number Opcode for tunnel datachannel Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_TUNNELER_PREFIX :Number Prefix opcode for tunneler Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_TUNRPC_PREFIX :Number Opcode for tunnel rpc message Type: Number Source: lib/constants.js &lt;inner, constant&gt; PREFIX :Number NodeID prefix (same as bitcoin) Type: Number Source: lib/constants.js &lt;inner, constant&gt; PUBLISH_TTL :Number Max time for publication relay Type: Number Source: lib/constants.js &lt;inner, constant&gt; ROUTER_CLEAN_INTERVAL :Number Drop bad contacts Type: Number Source: lib/constants.js &lt;inner, constant&gt; RPC_TIMEOUT :Number Max wait time for a RPC response Type: Number Source: lib/constants.js &lt;inner, constant&gt; TOKEN_EXPIRE :Number Reject datachannl token after time Type: Number Source: lib/constants.js &lt;inner, constant&gt; TUNNEL_ANNOUNCE_INTERVAL :Number Announce tunnel state Type: Number Source: lib/constants.js Ã— Search results Close "},"module-storj_deps.html":{"id":"module-storj_deps.html","title":"Module: storj/deps","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/deps Source: lib/deps.js Members &lt;static&gt; bitcore A modular node for Bitcoin and blockchain-based apps Source: lib/deps.js See: https://bitcore.io/ &lt;static&gt; kad Implementation of the Kademlia distributed hash table Source: lib/deps.js See: http://kadtools.github.io/ &lt;static&gt; kfs Kademlia inspired local file store based on LevelDB Source: lib/deps.js See: http://bookch.in/kfs Ã— Search results Close "},"module-storj_patches.html":{"id":"module-storj_patches.html","title":"Module: storj/patches","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/patches License: AGPL-3.0 Source: lib/patches.js Ã— Search results Close "},"module-storj_sips.html":{"id":"module-storj_sips.html","title":"Module: storj/sips","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/sips License: AGPL-3.0 Source: lib/sips/index.js Members &lt;static&gt; SIP0003 module:storj/sips/0003 Source: lib/sips/index.js Ã— Search results Close "},"module-storj_sips_0003.html":{"id":"module-storj_sips_0003.html","title":"Module: storj/sips/0003","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/sips/0003 Source: lib/sips/0003/index.js Members &lt;static&gt; TriggerManager TriggerManager Source: lib/sips/0003/index.js Ã— Search results Close "},"module-storj_utils.html":{"id":"module-storj_utils.html","title":"Module: storj/utils","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/utils License: LGPL-3.0 Source: lib/utils.js Methods &lt;static&gt; calculateBucketId(user, bucketName) Calculate bucket id from a given user id and bucket name Parameters: Name Type Description user String user id bucketName String bucket name Source: lib/utils.js &lt;static&gt; calculateFileId(bucket, fileName) Calculate file id from a given bucket id and file name Parameters: Name Type Description bucket String bucket id fileName String file name Source: lib/utils.js &lt;static&gt; calculateFileIdByName(user, bucketName, fileName) Calculate file id from a user id, bucket name, and file name Parameters: Name Type Description user String user id bucketName String bucket name fileName String file name Source: lib/utils.js &lt;static&gt; createComplexKeyFromSeed(seed64) Returns a HD key object using corrent key derivation path using the given seed Parameters: Name Type Description seed64 Buffer 64 byte seed for generating key Source: lib/utils.js See: https://github.com/Storj/complex Returns: Type HDKey &lt;static&gt; createEciesCipher(privateKey, publicKey) Creates an ECIES ciper object from a private and a public key Parameters: Name Type Description privateKey String The private key of the sender publicKey String The public key of the recipient Source: lib/utils.js Returns: Type Object &lt;static&gt; createShardDownloader(farmer, shardHash, transferToken) Returns a request object for downloading a shard from a farmer Parameters: Name Type Description farmer Contact Farmer contact object shardHash String The hash of the shard to upload transferToken String The authorized transfer token Source: lib/utils.js Returns: Type http.ClientRequest &lt;static&gt; createShardUploader(farmer, shardHash, transferToken) Returns a request object for uploading a shard to a farmer Parameters: Name Type Description farmer Contact Farmer contact object shardHash String The hash of the shard to upload transferToken String The authorized transfer token Source: lib/utils.js Returns: Type http.ClientRequest &lt;static&gt; createStreamTrimmer(trimFront, totalBytes) Returns a through stream that trims the output based on the given range Parameters: Name Type Description trimFront Number Number of bytes to trim off front of stream totalBytes Number The total length of the stream in bytes Source: lib/utils.js &lt;static&gt; ensureNtpClockIsSynchronized(callback) Determines if the system clock is syncronized with network Parameters: Name Type Description callback function Called with (err, delta) Source: lib/utils.js &lt;static&gt; existsSync(file) Check if file exists Parameters: Name Type Description file String Path to file Source: lib/utils.js Returns: Type Boolean &lt;static&gt; generateToken() Generates a unique token Source: lib/utils.js Returns: Type String &lt;static&gt; getContactURL(contact) Returns a stringified URL from the supplied contact object Parameters: Name Type Description contact Object Properties Name Type Description address String port Number nodeID String Source: lib/utils.js Returns: Type String &lt;static&gt; getNextPowerOfTwo(number) Returns the next power of two number Parameters: Name Type Description number Number Source: lib/utils.js Returns: Type Number &lt;static&gt; getNtpTimeDelta(callback) Returns the delta between system time and NTP time Parameters: Name Type Description callback function Called with (err, delta) Source: lib/utils.js &lt;static&gt; isCompatibleVersion(version) Returns whether or not the supplied semver tag is compatible Parameters: Name Type Description version String The semver tag from the contact Source: lib/utils.js Returns: compatible Type Boolean &lt;static&gt; isDirectory(dirPath) Check if a path is a directory Parameters: Name Type Description dirPath String Path to a directory Source: lib/utils.js Returns: Type Boolean &lt;static&gt; isHexaString(a) Determines if a value is hexadecimal string Parameters: Name Type Description a * The value to be tested Source: lib/utils.js Returns: Type Boolean &lt;static&gt; isValidContact(contact, loopback) Determines if the supplied contact is valid Parameters: Name Type Description contact Contact The contact information for a given peer loopback Boolean Allows contacts that are localhost Source: lib/utils.js Returns: Type Boolean &lt;static&gt; isValidHDNodeKey(hdKey) Checks if the supplied HD key is valid (base58 encoded) and proper length Parameters: Name Type Description hdKey String The HD key in base 58 encoding Source: lib/utils.js Returns: isValidHDKey Type Boolean &lt;static&gt; isValidNodeIndex(hdIndex) Checks if the input is a non-hardened HD key index Parameters: Name Type Description hdIndex Number The HD key index Source: lib/utils.js Returns: isValidHDKeyIndex Type Boolean &lt;static&gt; rmd160(input, encoding) Returns the RIPEMD-160 hash of the input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String &lt;static&gt; rmd160b(input, encoding) Returns the RIPEMD-160 hash of the input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type Buffer &lt;static&gt; rmd160sha256(input, encoding) Returns the RIPEMD-160 SHA-256 hash of this input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String &lt;static&gt; rmd160sha256b(input, encoding) Returns the RIPEMD-160 SHA-256 hash of this input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type Buffer &lt;static&gt; sha1(input, encoding) Returns the SHA-1 hash of the input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String &lt;static&gt; sha1whirlpool(input, encoding) Returns the SHA-1 WHIRLPOOL hash of this input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String &lt;static&gt; sha256(input, encoding) Returns the SHA-256 hash of the input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String &lt;static&gt; sha256b(input, encoding) Returns the SHA-256 hash of the input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type Buffer &lt;static&gt; sha512(input, encoding) Returns the SHA-512 hash of the input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String &lt;static&gt; simpleDecrypt(password, data) Decrypts the given data with the supplied password and base58 decodes it Parameters: Name Type Description password String The passphrase to use for decryption data String The string to decrypt Source: lib/utils.js Returns: Type String &lt;static&gt; simpleEncrypt(password, data) Encrypts the given data with the supplied password and base58 encodes it Parameters: Name Type Description password String The passphrase to use for encryption data String The string to encrypt Source: lib/utils.js Returns: Type String &lt;static&gt; tmpdir() Check for env STORJ_TEMP todetermine temp directory Source: lib/utils.js &lt;static&gt; warnOnError(logger) Helper for passing an error only logger callback Parameters: Name Type Description logger Logger Logger object Source: lib/utils.js Returns: Type function &lt;static&gt; whirlpool(input, encoding) Returns the WHIRLPOOL hash of the input Parameters: Name Type Description input String | Buffer Data to hash encoding String The encoding type of the data Source: lib/utils.js Returns: Type String Ã— Search results Close "},"module-storj_version.html":{"id":"module-storj_version.html","title":"Module: storj/version","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/version Source: lib/version.js Members &lt;inner, constant&gt; protocol :String The supported protocol version Type: String Source: lib/version.js &lt;inner, constant&gt; software :String The current software version Type: String Source: lib/version.js Ã— Search results Close "},"Monitor.html":{"id":"Monitor.html","title":"Class: Monitor","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Monitor Monitor new Monitor(network, options) Wraps a Network instance and provides events for gathering statistics about node operation Parameters: Name Type Description network Network The network interface to monitor options Object License: AGPL-3.0 Source: lib/network/monitor.js Methods &lt;static&gt; getConnectedPeers(source, callback) Gets the list of currently known Contacts Parameters: Name Type Description source Network The network instance to use callback function Source: lib/network/monitor.js &lt;static&gt; getContractsDetails(source, callback) Gets the total contracts stored Parameters: Name Type Description source Network The network instance to use callback function Source: lib/network/monitor.js &lt;static&gt; getDiskUtilization(source, callback) Gets the amount of used space compared to amount shared Parameters: Name Type Description source Network The network instance to use callback function Source: lib/network/monitor.js &lt;static&gt; getPaymentAddressBalances(source, callback) Gets the balance of SJCX/SJCT from a FarmerInterface Parameters: Name Type Description source Network The network instance to use callback function Source: lib/network/monitor.js getSnapshot() Returns the current snapshot Source: lib/network/monitor.js Returns: snapshot Type Object start() Starts the network monitor Source: lib/network/monitor.js Returns: Type Monitor stop() Stops the network monitor Source: lib/network/monitor.js Returns: Type Monitor Events update Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description stats Object Source: lib/network/monitor.js Ã— Search results Close "},"Network.html":{"id":"Network.html","title":"Class: Network","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Network Network new Network(options) Storj network interface Parameters: Name Type Description options Object Properties Name Type Argument Description hdKey String &lt;optional&gt; Extended SIP32 private key at 'group index' hdIndex Number &lt;optional&gt; Derivation index for hdKey keyPair KeyPair &lt;optional&gt; Node's cryptographic identity storageManager StorageManager Storage manager backend bridges String An array of bridges to connect logger Object Logger instance seedList Array List of seed URIs to join rpcAddress String Public node IP or hostname rpcPort Number Listening port for RPC listenPort Number Optional different listening port for RPC to bind to doNotTraverseNat Boolean Skip NAT traversal strategies maxTunnels Number Max number of tunnels to provide maxConnections Number Max concurrent connections tunnelGatewayRange Object Properties Name Type Description min Number Min port for gateway bind max Number Max port for gateway bind joinRetry Object &lt;optional&gt; Properties Name Type Argument Description times Number &lt;optional&gt; Times to retry joining net interval Number &lt;optional&gt; MS to wait before retrying Properties: Name Type Description keyPair KeyPair storageManager StorageManager node kad.Node The underlying DHT node triggerManager TriggerManager contact Contact transportAdapter Transport router kad.Router The underlying DHT router shardServer ShardServer offerManager OfferManager License: AGPL-3.0 Source: lib/network/index.js Fires: Network#event:ready Methods connect(uri, callback) Connects to the node at the given URI Parameters: Name Type Description uri String The storj protocol URI to connect callback function Called on connection or error Source: lib/network/index.js join(callback) Opens the connection to the network Parameters: Name Type Description callback function Called on successful network join Source: lib/network/index.js leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Source: lib/network/index.js ping(neighbor, callback) Will ping a neighbor Parameters: Name Type Description neighbor String A contact callback function Called on connection or error Source: lib/network/index.js publish(topic, contents, options) Publishes a topic with content to the network Parameters: Name Type Description topic String The serialized opcode topic contents Object Arbitrary publication contents options Object Options to pass to kad-quasar Source: lib/network/index.js subscribe(topic, handler) Subscribes to a topic on the network Parameters: Name Type Description topic String The serialized opcode topic handler Object Function to handle received publications Source: lib/network/index.js Events connected Triggered when the node has entered the overlay network Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Source: lib/network/index.js error Triggered when an error occurs Source: lib/network/index.js ready Triggered when the transport's network interface is ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Source: lib/network/index.js Ã— Search results Close "},"OfferManager.html":{"id":"OfferManager.html","title":"Class: OfferManager","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: OfferManager OfferManager new OfferManager() Simple management of a collection of OfferStreams that are keyable by their associated Contract's data hash Source: lib/contract/offer-manager.js Methods addStream(offerStream) Adds the offer stream to the manager Parameters: Name Type Description offerStream OfferStream The OfferStream to manage Source: lib/contract/offer-manager.js getStream(dataHash) Returns the stream at the given key Parameters: Name Type Description dataHash String The hash of the contract's data Source: lib/contract/offer-manager.js Returns: Type OfferStream | null removeStream(dataHash) Removes the stream at the given key Parameters: Name Type Description dataHash String The hash of the contract's data Source: lib/contract/offer-manager.js Ã— Search results Close "},"OfferStream.html":{"id":"OfferStream.html","title":"Class: OfferStream","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: OfferStream OfferStream new OfferStream(contract [, options]) Manages a stream of offers for a given storage contract publication Parameters: Name Type Argument Description contract Contract Storage contract published to network options Object &lt;optional&gt; Properties Name Type Argument Description maxOffers Number &lt;optional&gt; Maximum number of offers to process farmerBlacklist Array.&lt;String&gt; &lt;optional&gt; Reject offers from nodeID Source: lib/contract/offer-stream.js Methods addOfferToQueue(contact, contract) Adds the offer to the internal queue if there is room Parameters: Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/contract/offer-stream.js Returns: didAddOfferToQueue Type Boolean destroy() Tears down listeners and ends the stream Source: lib/contract/offer-stream.js Events data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/contract/offer-stream.js end Triggered when the maximum number of offers are received and processed Source: lib/contract/offer-stream.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/contract/offer-stream.js Ã— Search results Close "},"ProofStream.html":{"id":"ProofStream.html","title":"Class: ProofStream","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: ProofStream ProofStream new ProofStream(merkleLeaves, hexChallenge) Provides interface for proving possession of a file for an AuditStream Parameters: Name Type Description merkleLeaves Array Bottom leaves of the audit merkle tree hexChallenge String The challenge data in hex to prepend to shard License: LGPL-3.0 Source: lib/audit-tools/proof-stream.js Methods getProofResult() Returns the generated proof structure Source: lib/audit-tools/proof-stream.js Returns: Type Array Ã— Search results Close "},"Protocol.html":{"id":"Protocol.html","title":"Class: Protocol","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Protocol Protocol new Protocol(options) Defines the Storj protocol methods and mounts on a Network instance to handle Storj protocol messages Parameters: Name Type Description options Object Properties Name Type Description network Network Network instance to bind to License: AGPL-3.0 Source: lib/network/protocol.js Methods getRouteMap() Returns bound references to the protocol handlers Source: lib/network/protocol.js Returns: handlers Type Object handleAlloc(params, callback) Handles ALLOC messages Parameters: Name Type Description params Object callback Protocol~handleConsignCallback Source: lib/network/protocol.js handleAudit(params, callback) Handles AUDIT messages Parameters: Name Type Description params Object Properties Name Type Description contact Contact Sender contact information audits Array.&lt;Object&gt; Properties Name Type Description data_hash String Shard data hash to audit challenge String Challenge string for audit callback Protocol~handleAuditCallback Source: lib/network/protocol.js handleConsign(params, callback) Handles CONSIGN messages Parameters: Name Type Description params Object Properties Name Type Description contact Contact Sender contact information data_hash String Shard data hash (contract key) audit_tree Array.&lt;String&gt; Bottom leaves of audit merkle tree callback Protocol~handleConsignCallback Source: lib/network/protocol.js handleFindTunnel(params, callback) Handles FIND_TUNNEL messages Parameters: Name Type Description params Object Properties Name Type Description contact Contact Sender contact information relayers Array.&lt;Contact&gt; List of contacts who have already relayed the FIND_TUNNEL request callback Protocol~handleFindTunnelCallback Source: lib/network/protocol.js handleMirror(params, callback) Handles MIRROR messages Parameters: Name Type Description params Object Properties Name Type Description contact Contact Sender contact information data_hash String Shard hash to mirror token String Data channel authorization token farmer Contact The farmer to transfer data from callback Protocol~handleMirrorCallback Source: lib/network/protocol.js handleOffer(params, callback) Handles OFFER messages Parameters: Name Type Description params Object Properties Name Type Description contact Contact Sender contact information contract Contract Serialized contract data callback Protocol~handleOfferCallback Source: lib/network/protocol.js Fires: Network#event:unhandledOffer Network#event:unhandledOfferResolved handleOpenTunnel(params, callback) Handles OPEN_TUNNEL messages Parameters: Name Type Description params Object Properties Name Type Description contact Contact Sender contact information callback Protocol~handleOpenTunnelCallback Source: lib/network/protocol.js handleProbe(params, callback) Handles PROBE messages Parameters: Name Type Description params Object Properties Name Type Description contact Contact Sender contact information callback Protocol~handleProbeCallback Source: lib/network/protocol.js handleRenew(params, callback) Handles RENEW messages Parameters: Name Type Description params Object Properties Name Type Description contact Contact Sender contact information renter_id String Renter nodeID of the original contract renter_signature String Contract signature from original node ID contract Object Updated contract data callback Protocol~handleRenewCallback Source: lib/network/protocol.js See: https://github.com/Storj/sips/blob/master/sip-0004.md handleRetrieve(params, callback) Handles RETRIEVE messages Parameters: Name Type Description params Object Properties Name Type Description contact Contact Sender contact information data_hash String RMD160(SHA256(shard_data)) callback Protocol~handleRetrieveCallback Source: lib/network/protocol.js handleTrigger(params, callback) Handles TRIGGER messages Parameters: Name Type Description params Object Properties Name Type Description behavior String Trigger behavior name to process contents Object Trigger content payload contact Contact Sender contact information callback Protocol~handleTriggerCallback Source: lib/network/protocol.js See: https://github.com/Storj/sips/blob/master/sip-0003.md Type Definitions handleAuditCallback(err, result) Parameters: Name Type Description err Error | null result Object Properties Name Type Description proofs Array.&lt;Array&gt; Mapped list of proof responses Source: lib/network/protocol.js handleConsignCallback(err, result) Parameters: Name Type Description err Error | null result Object Properties Name Type Description token String Data channel authorization token Source: lib/network/protocol.js handleFindTunnelCallback(err, result) Parameters: Name Type Description err Error | null result Object Properties Name Type Description tunnels Array.&lt;Contact&gt; List of known tunnelers Source: lib/network/protocol.js handleMirrorCallback(err, result) Parameters: Name Type Description err Error | null result Object Empty acknowledgement Source: lib/network/protocol.js handleOfferCallback(err, result) Parameters: Name Type Description err Error | null result Object Properties Name Type Description contract Contract Signed contract Source: lib/network/protocol.js handleOpenTunnelCallback(err, result) Parameters: Name Type Description err Error | null result Object Properties Name Type Description tunnel String WebSocket URI including auth token alias Object Properties Name Type Description address String Gateway address on the tunneler port Number Gateway port on the tunneler Source: lib/network/protocol.js handleProbeCallback(err, result) Parameters: Name Type Description err Error | null result Object Empty acknowledgement Source: lib/network/protocol.js handleRenewCallback(err, result) Parameters: Name Type Description err Error | null result Object Properties Name Type Description contract Object Signed updated contract Source: lib/network/protocol.js handleRetrieveCallback(err, result) Parameters: Name Type Description err Error | null result Object Properties Name Type Description token String Authorization token for data channel Source: lib/network/protocol.js handleTriggerCallback(err, result) Parameters: Name Type Description err Error | null result Object Arbitrary key-value pairs Source: lib/network/protocol.js unhandledOfferResolver( [error]) Parameters: Name Type Argument Description error Error &lt;optional&gt; An error if the offer cannot be resolved Source: lib/network/protocol.js Ã— Search results Close "},"RAMStorageAdapter.html":{"id":"RAMStorageAdapter.html","title":"Class: RAMStorageAdapter","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: RAMStorageAdapter RAMStorageAdapter new RAMStorageAdapter() Implements an in-memory storage adapter License: AGPL-3.0 Source: lib/storage/adapters/ram.js Extends StorageAdapter Methods &lt;abstract&gt; _close(callback) Closes the storage adapter Parameters: Name Type Description callback function Called on complete Inherited From: StorageAdapter#_close Source: lib/storage/adapter.js &lt;abstract&gt; _open(callback) Opens the storage adapter Parameters: Name Type Description callback function Called on complete Inherited From: StorageAdapter#_open Source: lib/storage/adapter.js &lt;abstract&gt; _size(callback) Returns the number of bytes stored Parameters: Name Type Description callback function Called on complete Inherited From: StorageAdapter#_size Overrides: StorageAdapter#_size Source: lib/storage/adapter.js createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Inherited From: StorageAdapter#createReadStream Source: lib/storage/adapter.js Returns: Type ReadableStream del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Inherited From: StorageAdapter#del Source: lib/storage/adapter.js flush(callback) Calls the implemented StorageAdapter#_flush Parameters: Name Type Description callback function Called with error or null Inherited From: StorageAdapter#flush Source: lib/storage/adapter.js get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#get Source: lib/storage/adapter.js peek(key, callback) Calls the implemented StorageAdapter#_peek and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#peek Source: lib/storage/adapter.js put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Inherited From: StorageAdapter#put Source: lib/storage/adapter.js size( [key], callback) Calls the implemented StorageAdapter#_size Parameters: Name Type Argument Description key String &lt;optional&gt; Optional file key callback function Called with error or number of bytes stored Inherited From: StorageAdapter#size Source: lib/storage/adapter.js Events add Triggered when a new item is added Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:add Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Inherited From: StorageAdapter#event:delete Source: lib/storage/adapter.js ready Triggered when the adapter is ready Inherited From: StorageAdapter#event:ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Inherited From: StorageAdapter#event:update Source: lib/storage/adapter.js Ã— Search results Close "},"RenterInterface.html":{"id":"RenterInterface.html","title":"Class: RenterInterface","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: RenterInterface RenterInterface new RenterInterface(options) Creates and a new renter interface Parameters: Name Type Description options Object Properties Name Type Argument Description hdKey String &lt;optional&gt; Extended key at 'group index' as per SIP32 hdIndex Number &lt;optional&gt; Derivation index for hdKey keyPair KeyPair &lt;optional&gt; Node's cryptographic identity storageManager StorageManager Storage manager backend logger Object Logger instance seedList Array List of seed URIs to join rpcAddress String Public node IP or hostname rpcPort Number Listening port for RPC doNotTraverseNat Boolean Skip NAT traversal strategies maxTunnels Number Max number of tunnels to provide tunnelServerPort Number Port for tunnel server to use tunnelGatewayRange Object Properties Name Type Description min Number Min port for gateway bind max Number Max port for gateway bind rateLimiterOpts Object Options for RateLimiter joinRetry Object &lt;optional&gt; Properties Name Type Argument Description times Number &lt;optional&gt; Times to retry joining net interval Number &lt;optional&gt; MS to wait before retrying Properties: Name Type Description keyPair KeyPair storageManager StorageManager node kad.Node The underlying DHT node triggerManager TriggerManager contact Contact transportAdapter Transport router kad.Router The underlying DHT router dataChannelServer DataChannelServer License: AGPL-3.0 Source: lib/network/renter.js Fires: Network#event:ready Extends Network Methods connect(uri, callback) Connects to the node at the given URI Parameters: Name Type Description uri String The storj protocol URI to connect callback function Called on connection or error Inherited From: Network#connect Source: lib/network/index.js getConsignmentPointer(farmer, contract, audit, callback) Requests a consignment pointer from the given farmer for opening a DataChannelClient for transferring the the data shard to the farmer Parameters: Name Type Description farmer Contact The farmer contact object for requesting token contract Contract The storage contract for this consignment audit AuditStream The audit object for merkle leaves callback RenterInterface~getConsignmentPointerCallback Source: lib/network/renter.js getMirrorNodes(sources, destinations, callback) Requests that the given destination farmers mirror the data from the sources Parameters: Name Type Description sources Array.&lt;Object&gt; Pointers for each destination destinations Array.&lt;Contact&gt; The farmers to replicate to callback RenterInterface~getMirrorNodesCallback Results handler Source: lib/network/renter.js getOfferStream(contract [, offerStreamOptions]) Creates a readable stream of offers for the storage contract Parameters: Name Type Argument Description contract Contract The storage contract to publish offerStreamOptions Object &lt;optional&gt; Options passed to OfferStream Source: lib/network/renter.js Returns: offerStream Type OfferStream getRetrievalPointer(farmer, contract, callback) Requests a retrieval token from the given farmer for opening a DataChannelClient for transferring the data shard from the farmer Parameters: Name Type Description farmer Contact The farmer contact object for requesting token contract Contract The storage contract for this consignment callback RenterInterface~getRetrievalPointerCallback Token handler Source: lib/network/renter.js getStorageProof(farmer, item, callback) Issues an audit request to the given farmer for the data and returns the ProofStream#getProofResult structure for verification. Parameters: Name Type Description farmer Contact Farmer contact from which proof is needed item StorageItem The storage item on which to perform the audit callback RenterInterface~getStorageProofCallback Proof handler Source: lib/network/renter.js join(callback) Opens the connection to the network Parameters: Name Type Description callback function Called on successful network join Inherited From: Network#join Source: lib/network/index.js leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Inherited From: Network#leave Source: lib/network/index.js ping(neighbor, callback) Will ping a neighbor Parameters: Name Type Description neighbor String A contact callback function Called on connection or error Inherited From: Network#ping Source: lib/network/index.js publish(topic, contents, options) Publishes a topic with content to the network Parameters: Name Type Description topic String The serialized opcode topic contents Object Arbitrary publication contents options Object Options to pass to kad-quasar Inherited From: Network#publish Source: lib/network/index.js publishContract(contact, contract) Publishes a contract directly to a specific contact and receive a storage offer in the response. Parameters: Name Type Description contact Contract The contact to publish the contract contract Contract The storage contract to publish Source: lib/network/renter.js subscribe(topic, handler) Subscribes to a topic on the network Parameters: Name Type Description topic String The serialized opcode topic handler Object Function to handle received publications Inherited From: Network#subscribe Source: lib/network/index.js Type Definitions getConsignmentPointerCallback(err, pointer) This callback is called upon receipt of a consignment token from RenterInterface#getConsignmentPointer Parameters: Name Type Description err Error | null If requesting the token failed, an error object pointer Object Properties Name Type Description farmer Contact hash String token String operation String Source: lib/network/renter.js getMirrorNodesCallback(err, results) This callback is called upon acknowledgement of a mirror request Parameters: Name Type Description err Error | null If requesting all mirrors failed, an error object results Array.&lt;Contact&gt; The farmers who successfully mirrored Source: lib/network/renter.js getRetrievalPointerCallback(err, pointer) This callback is called upon receipt of a retrieval token from RenterInterface#getRetrieveToken Parameters: Name Type Description err Error | null If requesting the token failed, an error object pointer Object Properties Name Type Description farmer Contact hash String token String operation String Source: lib/network/renter.js getStorageProofCallback(err, proof) This callback is called upon receipt of an audit proof from RenterInterface#getStorageProof Parameters: Name Type Description err Error | null If requesting the proof failed, an error object proof Array Result from ProofStream#getProofResult Source: lib/network/renter.js Events connected Triggered when the node has entered the overlay network Inherited From: Network#event:connected Source: lib/network/index.js disconnected Triggered when the node has exited the overlay network Inherited From: Network#event:disconnected Source: lib/network/index.js error Triggered when an error occurs Inherited From: Network#event:error Source: lib/network/index.js ready Triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js unhandledOffer Triggered when a valid offer is received, but we are not waiting for one Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Protocol~unhandledOfferResolver Inherited From: Network#event:unhandledOffer Source: lib/network/index.js unhandledOfferResolved Triggered when an unhandled offer is handled by the Network#unhandledOffer listener by calling the event's supplied Network~unhandledOfferResolver Parameters: Name Type Description contact Contact The farmer contact the offer is from contract Contract The complete contract, signed by us and farmer Inherited From: Network#event:unhandledOfferResolved Source: lib/network/index.js Ã— Search results Close "},"ShardServer.html":{"id":"ShardServer.html","title":"Class: ShardServer","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: ShardServer ShardServer new ShardServer(options) Creates a shard server for sending and receiving consigned file shards Parameters: Name Type Description options Object Properties Name Type Argument Default Description nodeID String The farmer nodeID storagePath String Path to store tokens db storageManager StorageManager Storage manager backend logger kad.Logger Logger to use from Network tokenTtl Number &lt;optional&gt; 1800000 Close after idle License: AGPL-3.0 Source: lib/network/shard-server.js Methods accept(token, filehash, contact, callback) Begin accepting data for the given file hash and token Parameters: Name Type Description token String The authorization token created for transfer filehash String The shard hash to allow for the token contact Contact contact that negotiated the token callback function Source: lib/network/shard-server.js close(callback) Close token database Parameters: Name Type Description callback function Source: lib/network/shard-server.js isAuthorized(token, hash) Validates the given token Parameters: Name Type Description token String hash String Source: lib/network/shard-server.js reject(token) Stop accepting data for the given token Parameters: Name Type Description token String The authorization token created for transfer Source: lib/network/shard-server.js routeConsignment(req, res) Receives the data stream and writes it to storage Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse Source: lib/network/shard-server.js routeRetrieval(req, res) Pumps the data through to the client Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse Source: lib/network/shard-server.js Events error Triggered when a error occurs Parameters: Name Type Description error Error The error object Source: lib/network/shard-server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description item StorageItem The item associated with the download Source: lib/network/shard-server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description item StorageItem The item associated with the upload Source: lib/network/shard-server.js Ã— Search results Close "},"StorageAdapter.html":{"id":"StorageAdapter.html","title":"Class: StorageAdapter","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: StorageAdapter StorageAdapter new StorageAdapter() Abstract base class for storage adapter License: AGPL-3.0 Source: lib/storage/adapter.js Methods &lt;abstract&gt; _close(callback) Closes the storage adapter Parameters: Name Type Description callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _del(key, callback) Delete the shard data at the given key Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _flush(key, callback) Performs lookup and provides an StorageItem to the callback Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _get(key, callback) Performs lookup and provides an StorageItem to the callback Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _keys() Returns the hashes of all shards stored Source: lib/storage/adapter.js Returns: Type ReadableStream &lt;abstract&gt; _open(callback) Opens the storage adapter Parameters: Name Type Description callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _peek(key, callback) Performs lookup and provides an StorageItem to the callback but does not initialize any shard read/write stream Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _put(key, item, callback) Stores the StorageItem Parameters: Name Type Description key String Shard hash item Item Item to store callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _size(callback) Returns the number of bytes stored Parameters: Name Type Description callback function Called on complete Source: lib/storage/adapter.js createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Source: lib/storage/adapter.js Returns: Type ReadableStream del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Source: lib/storage/adapter.js flush(callback) Calls the implemented StorageAdapter#_flush Parameters: Name Type Description callback function Called with error or null Source: lib/storage/adapter.js get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Source: lib/storage/adapter.js peek(key, callback) Calls the implemented StorageAdapter#_peek and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Source: lib/storage/adapter.js put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Source: lib/storage/adapter.js size( [key], callback) Calls the implemented StorageAdapter#_size Parameters: Name Type Argument Description key String &lt;optional&gt; Optional file key callback function Called with error or number of bytes stored Source: lib/storage/adapter.js Events add Triggered when a new item is added Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js delete Triggered when an item is deleted Parameters: Name Type Description item StorageItem Source: lib/storage/adapter.js ready Triggered when the adapter is ready Source: lib/storage/adapter.js update Triggered when an existing item is updated Parameters: Name Type Description itemBeforeUpdate StorageItem itemAfterUpdate StorageItem Source: lib/storage/adapter.js Ã— Search results Close "},"StorageItem.html":{"id":"StorageItem.html","title":"Class: StorageItem","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: StorageItem StorageItem new StorageItem(data) Represents a storage item, including contracts, challenges, the shard itself along with metadata describing download count, payments, etc Parameters: Name Type Description data Object Properties Name Type Description hash String | null Shard hash to use as storage key shard Stream | null Raw binary blob of shard contracts Object Dictionary of nodeID:Contract trees Object Dictionary of nodeID:merkleLeaves challenges Object Dictionary of nodeID:privateAuditData meta Object Dictionary of arbitrary nodeID:metadata License: AGPL-3.0 Source: lib/storage/item.js Methods addAuditRecords(contact, audit) Adds the trees and challenges to the item keyed by nodeID Parameters: Name Type Description contact Contact The contact associated with the trees audit Audit | AuditStream The audit or challenge generator Source: lib/storage/item.js addContract(contact, contract) Adds the contract data keyed by nodeID and hdKey Parameters: Name Type Description contact Contact The contact associated with the trees contract Contract The storage contract instance Source: lib/storage/item.js addMetaData(contact, meta) Adds the meta data keyed by nodeID Parameters: Name Type Description contact Contact The contact associated with the trees meta Object Arbitrary metadata about the shard Source: lib/storage/item.js getContract(contact, contract) Gets a contract data by a contact based on the hdKey or the nodeID of the contact. It will return false if the contract is not found for the contact, which will indicate that the contact is not authorized for that specific contract. Parameters: Name Type Description contact Contact The contact associated with the trees contract Contract The storage contract instance Source: lib/storage/item.js Returns: Type Contract | Boolean removeContract(contact) Deletes the contract for the given contact Parameters: Name Type Description contact Contact Source: lib/storage/item.js Returns: didRemoveContract Type Boolean toObject() Returns a plain object representation of the item Source: lib/storage/item.js updateTimestamp() Updates the timestamp for the item Source: lib/storage/item.js Ã— Search results Close "},"StorageManager.html":{"id":"StorageManager.html","title":"Class: StorageManager","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: StorageManager StorageManager new StorageManager(storage, options) Interface for managing contracts, shards, and audits Parameters: Name Type Description storage StorageAdapter Storage adapter to use options Object Properties Name Type Argument Description disableReaper Boolean Don't perform periodic reaping of stale contracts logger Object &lt;optional&gt; Logger to use for debugging maxCapacity Number Max number of bytes to allow in storage License: AGPL-3.0 Source: lib/storage/manager.js Extends EventEmitter Methods clean(callback) Enumerates all storage contracts and reaps stale data Parameters: Name Type Description callback function Called on complete Source: lib/storage/manager.js close(callback) Closes the underlying storage adapter Parameters: Name Type Description callback function Called on complete Source: lib/storage/manager.js load(hash, callback) Loads the storage Item at the given key Parameters: Name Type Description hash String Shard hash to load data for callback function Called with error or StorageItem Source: lib/storage/manager.js open(callback) Opens the underlying storage adapter Parameters: Name Type Description callback function Called on complete Source: lib/storage/manager.js save(item, callback) Saves the storage StorageItem at the given key Parameters: Name Type Description item StorageItem The StorageItem to store callback function Called on complete Source: lib/storage/manager.js Ã— Search results Close "},"StorageMigration.html":{"id":"StorageMigration.html","title":"Class: StorageMigration","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: StorageMigration StorageMigration new StorageMigration(source, target) Migrates data stored with one StorageAdapter to another Parameters: Name Type Description source StorageAdapter The source adapter target StorageAdapter The migration destination License: AGPL-3.0 Source: lib/storage/migration.js Methods start() Starts the migration process Source: lib/storage/migration.js stop() Stops the migration process Source: lib/storage/migration.js Ã— Search results Close "},"Transport.html":{"id":"Transport.html","title":"Class: Transport","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Transport Transport new Transport(contact, options) Custom HTTP transport adapter Parameters: Name Type Description contact kad.Contact Contact object to binding to port options Object Properties Name Type Description logger Logger Logger for diagnositcs maxTunnels Number Number of tunnels to provide to network doNotTraverseNat Boolean Do not try to punch out of NAT tunnelGatewayRange Object Properties Name Type Description min Number Min port for gateway bind max Number Max port for gateway bind listenPort Number Different port for the server to listen on (optional) storageManager StorageManager License: AGPL-3.0 Source: lib/network/transport.js Methods createPortMapping(port, callback) Creates a port mapping with UPnP Parameters: Name Type Description port Number The port to forward callback function Callback function Source: lib/network/transport.js send(contact, message, callback) Sends the RPC message to the given contact Parameters: Name Type Description contact Contact message kad.Message callback function Source: lib/network/transport.js Events connectionLimitReached Triggered when the max connections limit is reached Source: lib/network/transport.js Ã— Search results Close "},"TriggerManager.html":{"id":"TriggerManager.html","title":"Class: TriggerManager","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TriggerManager TriggerManager new TriggerManager() Implements behavior triggers as described in SIP-0003 License: AGPL-3.0 Source: lib/sips/0003/trigger-manager.js See: https://github.com/storj/sips/blob/master/sip-0003.md Methods add(nodeID, behaviors) Adds a trigger handler for the given nodeID and behavior Parameters: Name Type Description nodeID String | Array The nodeID(s) to authorize for the trigger (supports `*` wildcard) behaviors Object Behavior name to {TriggerManager~triggerHandler}s Source: lib/sips/0003/trigger-manager.js process(messageParams, callback) Process a received trigger message Parameters: Name Type Description messageParams Object The received message params callback TriggerManager~processCallback Result of trigger process Source: lib/sips/0003/trigger-manager.js remove(nodeID, behaviors) Removes a trigger handler for the given nodeID and behavior Parameters: Name Type Description nodeID String | Array The nodeID(s) to deauthorize for the trigger behaviors String | Array Behavior name to unregister Source: lib/sips/0003/trigger-manager.js Type Definitions destroyTrigger() Optionally called from trigger handler to unregister the trigger handler Source: lib/sips/0003/trigger-manager.js processCallback(err, params) Called upon the processing of a trigger message Parameters: Name Type Description err Error | null Optional error resulting from processing params Object Response parameters to send back Source: lib/sips/0003/trigger-manager.js replyToSender(err, params) Passed to the trigger handler for replying to the message Parameters: Name Type Description err Error | null Optional error to respond with params Object Response parameters to return Source: lib/sips/0003/trigger-manager.js triggerHandler(messageParams, replyToSender, destroyTrigger) Called when a trigger is received from authorized source Parameters: Name Type Description messageParams Object The RPC message parameters replyToSender TriggerManager~replyToSender Respond to the trigger destroyTrigger TriggerManager~destroyTrigger Unregisters trigger Source: lib/sips/0003/trigger-manager.js Ã— Search results Close "},"Verification.html":{"id":"Verification.html","title":"Class: Verification","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Verification Verification new Verification(proof) Interface for verifying the result of an audit proof Parameters: Name Type Description proof Array The result of ProofStream#getProofResult License: LGPL-3.0 Source: lib/audit-tools/verification.js Methods verify(merkleRoot, totalDepth) Verifies the proof given the merkle root and tree depth Parameters: Name Type Description merkleRoot String Merkle root totalDepth Number Depth of merkle tree Source: lib/audit-tools/verification.js Returns: result - Array with expected result and verified result Type Array Ã— Search results Close "},"tutorial-command-line-interface.html":{"id":"tutorial-command-line-interface.html","title":"Tutorial: Using the Command Line Tools","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Using the Command Line Tools This package comes equipped with a command line interface for performing a number of useful operations on the Storj network. The CLI program is generally focused on interacting with a remote Bridge service and makes use of the library's BridgeClient class to do so. In addition to interacting with a bridge node, the tool also exposes some general purpose utilities. To use the CLI, follow the instructions in the README to install the module globally or if you are working from within the git repository, you can use: npm linkCommunicating with a BridgeOnce you have access to the storj command, register and authenticate with the bridge: &gt; $ storj register [...] &gt; Enter your email address &gt; gordon@storj.io [...] &gt; Enter your password &gt; ************* [info] Registered! Check your email to activate your account.Follow the activation link you receive via email and come back to the CLI to pair with your account: &gt; $ storj login [...] &gt; Enter your email address &gt; gordon@storj.io [...] &gt; Enter your password &gt; ************* [info] This device has been successfully paired.Now you can create buckets, transfer files, and manage your bridge account. Audits, Proofs, and VerificationsThe CLI also includes some utility commands for generating file possession audits, proving possession, and verifying proofs. You can generate a challenge set and merkle tree for a file easily: &gt; $ storj prepare-audits 2 CONTRIBUTING.md [info] Generating challenges and merkle tree... [info] [info] Merkle Root [info] ----------- [info] 9c8c37935f58d46e3301efe4f44724b8785a81a5 [info] [info] Challenges [info] ---------- [info] c8573773616e072230d40131e7ce8537d384825e337e5903ff7367ddea798c52 [info] 7c4d4f57f40d5c95f962e7cd72347e4077e1885aaffd8c1ccbbd02c8d7c48dce [info] [info] Merkle Leaves [info] ------------- [info] aaf42766d87a37e6dffbae7172fd0073006bf5f3 [info] ccee086dbc8a16b93b79912cb37f3b037bbf8269A farmer can use parts of this data to prove possession of a file shard: &gt; $ storj prove-file aaf42766d87a37e6dffbae7172fd0073006bf5f3,ccee086dbc8a16b93b79912cb37f3b037bbf8269 c8573773616e072230d40131e7ce8537d384825e337e5903ff7367ddea798c52 CONTRIBUTING.md [info] Generating proof of possession... [info] [info] Challenge Response [info] ------------------ [info] [[&quot;153a0d4b1d228043992fec585cadb51974b053f7&quot;],&quot;ccee086dbc8a16b93b79912cb37f3b037bbf8269&quot;]The result of this operation can be used by the original renter to verify the the proof and confirm that the farmer still has possession of the file: &gt; $ storj verify-proof 9c8c37935f58d46e3301efe4f44724b8785a81a5 2 '[[&quot;153a0d4b1d228043992fec585cadb51974b053f7&quot;],&quot;ccee086dbc8a16b93b79912cb37f3b037bbf8269&quot;]' [info] [info] Expected: 9c8c37935f58d46e3301efe4f44724b8785a81a5 [info] Actual: 9c8c37935f58d46e3301efe4f44724b8785a81a5 [info] [info] The proof response is validFor more detailed usage information of the command line interface, run storj --help. Temporary FilesOn Windows temporary files are stored: C:\\Users\\&lt;user&gt;\\AppData\\Local\\Temp Ã— Search results Close "},"tutorial-contract-topics.html":{"id":"tutorial-contract-topics.html","title":"Tutorial: Publishing Storage Contracts","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Publishing Storage Contracts Nodes solicit storage contracts with the network by publishing information about their storage requirements as outlined in Protocol Specification. Storj implements a distributed publish/subscribe system based on an algorithm called Quasar. Quasar works by allowing nodes to advertise topics of interest to their neighbors and keeping a record of these topics in their neighborhood by storing them in an attenuated bloom filter. Each node has a view of the topics in which their neighbors are interested up to 3 hops away. By the nature of this design, the network forms gravity wells wherein messages of interest are efficiently relayed to nodes that are subscribed to the topic without flooding the network. This approach works well when there is a diverse number of topics. The Storj protocol leverages this by defining a matrix of criteria and descriptors in the form of opcodes representing the degree of which the criteria must be met. CriteriaAt the time of writing, there are 4 criteria column in the topic matrix: Size Duration Availability Speed SizeRefers to the size of the data to be stored. DurationRefers to the length of time for which the data should be stored. AvailabilityRefers to the relative uptime of required by the contract for retrieval of the stored data. SpeedRefers to the throughput desired for retrieval of the stored data. DescriptorsAt the time of writing, there are 3 descriptor opcodes representing low, medium, and high degrees of the criteria. Low: 0x01 Medium: 0x02 High: 0x03 The ranges represented by these descriptors are advisory and may change based on network performance and improvements to hardware over time. ------------------------------------------------------------------------------- | Descriptor | Size | Duration | Availability | Speed | |-----------------|-------------|------------|--------------|-----------------| | Low (`0x01`) | 0mb - 8mb | 0d - 30d | 0% - 50% | 0mbps - 6mbps | |-----------------|-------------|------------|--------------|-----------------| | Medium (`0x02`) | 8mb - 16mb | 30d - 90d | 50% - 80% | 6mbps - 12mbps | |-----------------|-------------|------------|--------------|-----------------| | High (`0x03`) | 16mb - 32mb | 90d - 270d | 80% - 99% | 12mbps - 32mbps | -------------------------------------------------------------------------------Topic FormatWhen publishing or subscribing to a given topic representing the degrees of these criteria, nodes must serialize the opcodes as the hex representation of the bytes in proper sequence. This sequence is defined as: prefix|size|duration|availability|speedThe first byte, &quot;prefix&quot;, is the static identifier for a contract publication. Contracts are not the only type of publication shared in the network, so the prefix acts as a namespace for a type of publication topic. The prefix for a contract publication is: 0x0f. To illustrate by example, we can determine the proper topic by analyzing the use case for a given file shard. For instance, if we want to store an asset that is displayed on a web page we can infer the following: The file is small The file may change often, so we should only store it for medium duration The file needs to always be available The file should be transferred quickly Using the matrix, we can determine the proper opcode sequence: [0x0f, 0x01, 0x02, 0x03, 0x03]Serialized as hex, our topic string becomes: 0f01020303Another example, by contrast, is data backup. Data backup is quite different than the previous example: The file is large (perhaps part of a hard drive backup) The file will not change and should be stored long term The file will not be accessed often, if ever The file does not need to be transferred at high speed Using the matrix, we can determine the proper opcode sequence: [0x0f, 0x03, 0x03, 0x01, 0x01]Serialized as hex, our topic string becomes: 0f03030101The resulting hex string from the serialized opcode byte sequence should be used as the topic parameter of a PUBLISH RPC as defined in the Protocol Specification. Nodes that are subscribed to the topic will receive the proposed storage contract and may begin contract negotiation with you directly. Ã— Search results Close "},"tutorial-data-transfer.html":{"id":"tutorial-data-transfer.html","title":"Tutorial: Transferring File Shards","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Transferring File Shards Transfering file shards to farmers is a simple process. After a successful CONSIGN or RETRIEVE RPC yields a token, the renter may construct an HTTP request to the farmer, to push or pull the data. Uploading ShardsTo upload a shard to a given farmer, construct an HTTP request: Method: POST Path: /shards/{hash}?token={token} Headers: content-type: application/octet-stream x-storj-node-id: {farmer node id} Then simply write the encrypted shard to the request. Farmers will respond with appropriate status codes and messages to indicate the result. Downloading ShardsTo download a shard from a given farmer, construct an HTTP request: Method: GET Path: /shards/{hash}?token={token} Headers: content-type: application/octet-stream x-storj-node-id: {farmer node id} You will receive the shard as a response of type application/octet-stream if you are authorized. Ã— Search results Close "},"tutorial-environment-variables.html":{"id":"tutorial-environment-variables.html","title":"Tutorial: Environment Variables","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Environment Variables Below is a list of environment variables that can be used to alter the behavior of the core library and associated tooling. STORJ_NETWORKThis value will be postfixed to your announced protocol version in the network. A value of testnet would advertise to the network you are running 0.7.0-testnet, which will isolate you to other nodes running the same exact version. See Running a Test Network for more information. STORJ_ALLOW_LOOPBACKBy default, the Network class will drop and ignore message from nodes who identify themeselves as a loopback interface like localhost, 127.0.0.1, etc. This is a security precaution to prevent others from causing you to send messages to yourself as well as prevent invalid contacts in your routing table. To disable this feature (primarily for local testing), set this variable to 1. STORJ_BRIDGEThis variable will change the default URI for the BridgeClient class. The default value is https://api.storj.io. If you run your own bridge, testing one locally, or otherwise would like to default to a different host, set this variable. This works well with the CLI (see Using the Command Line Tools) when testing against other bridges. STORJ_KEYPASSThis variable will set the --keypass used to unlock the keyring. Setting your password will make it so other users can't grep it with ps -a. STORJ_TEMPThis variable will set the folder to which the encrypted file will be placed when uploading a file. Shards will also be placed in this folder during upload. Ã— Search results Close "},"tutorial-file-encryption.html":{"id":"tutorial-file-encryption.html","title":"Tutorial: File Encryption Standards","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections File Encryption Standards This document serves to provide a detailed account of how files are encrypted by default by Storj Core to promote interoperability between different implementations of clients. Sharding and Encryption SchemeBefore data is stored in the network, the Storj Core library automatically handles file encryption, sharding, and key management for you. In order of operations: Complete file is encrypted with a unique key and initialization vector File is demultiplexed (or &quot;sharded&quot;) into individual chunks Each shard is offered to the network and transferred Key and IV are encrypted with a passphrase and stored locally Key and Initialization Vector GenerationFiles are encrypted using AES-256-CTR. Use of CTR allows for random read-access to known indices. File keys are generated via one of two methods: Local PBKDF2 key derivation (default) Passphrase-based deterministic key derivation (recommended) PBKDF2 Key DerivationBy default, the key for each file is the result of a standard key derivation function, PBKDF2. PBKDF2 generates a key from a password and a salt. These two values are randomly generated bytes: Password: 512 random bytes Salt: 32 random bytes The key length of the PBKDF2 is 512 bytes, should use 25000 iterations, and use SHA-512 as the digest. To create the cipher/decipher and initialization vector, derive the SHA-256 hash of the resulting PBKDF2 for the cipher/decipher key and use the first 16 bytes of the original salt as the iv. The DataCipherKeyIv class represents these values, and provides methods for their generation. The KeyRing class stores the original password and salt locally in an encrypted JSON document keyed by the ObjectId returned from Storj Bridge for the file object. The cleartext JSON document has two properties: pass and salt. { &quot;pass&quot;: &quot;c7c311ee213d10baefd620a004d76485190d82...&quot;, &quot;salt&quot;: &quot;6d33490c999e9d613ccf4b146446763df15de2...&quot; }This JSON string is encrypted with AES-256-CBC using a user-defined passphrase, and encoded as Base58. Each of those encrypted JSON documents is stored in a directory called key.ring/, where the file name is the ObjectId returned from Storj Bridge for the file object. Portable Key Ring FormatBecause the keys in the key ring are generated and stored locally, files encrypted with these keys cannot be accessed by other machines without first duplicating the key files onto that machine. To mitigate this, Storj Core can create a simple portable key ring archive. A KeyRing created by Storj Core can be exported into a portable format, which is simply a gzipped tape archive (.tar.gz or .tgz). Importing this archive simply entails: Decompress and unpack the archive Decrypt each JSON document using the original passphrase Encrypt each document with the passphrase of the target keyring Move the files into the target keyring, optionally overwriting conflicts Passphrase-based Key DerivationRather than relying on locally-generated keys, it is recommended that the user generate a high-entropy passphrase, and generate keys from it via a deterministic key derivation process. Using this method, the user may grant access to all encrypted files by simply transferring the passphrase. Storj Core offers tools for this based on Bitcoin's BIP39 Mnemonic passphrases. KeyRing provides tools for generating a mnemonic passphrase and writing it to disk. If a mnemonic is found, Storj Core will prefer passphrase-based key derivation to PBKDF2 derivation. Storj clients should create a file key as follows: Prepend the passphrase to the Bucket ID Calculate the sha512 hash of the resulting string Take the first 64 bits of the resulting hash to make the Bucket Key Prepend the Bucket Key to the File ID Calculate the sha512 hash of the resulting string Take the first 64 bits of the resulting hash to make the File Key As any client with access to the passphrase can easily generate file keys on demand, this provides additional portability of files between machines and applications. It is strongly recommended that users write down the passphrase, and keep it in a secure place. Public Bucket Key StoragePublic Buckets are a feature of Bridge, not a feature of Storj. When a Public Bucket is created, the Bucket Key is stored with Bridge. It is then provided to clients requesting PUSH or PULL tokens from that bucket. References DataCipherKeyIv DeterministicKeyIV EncryptStream DecryptStream KeyRing Ã— Search results Close "},"tutorial-private-testnet.html":{"id":"tutorial-private-testnet.html","title":"Tutorial: Running a Test Network","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Running a Test Network Setting up a private or partitioned version of the Storj network is very simple. The Storj protocol requires the inclusion of a protocol property nested inside the contact data included in every RPC message. See Protocol Specification for more information on the RPC message format. Protocol Identifier FormatNodes on the Storj network identify the version of the protocol they are running with the use of a semantic version tag. When a node is trying to determine whether or not another node is compatible with her version of the protocol, she checks the following: Is the MAJOR version the same? Is the MAJOR version 0? Is the MINOR version the same? If both nodes are running the same MAJOR version and that version is not 0, then the nodes are compatible. If the MAJOR version is 0, then the nodes are compatible only if the MINOR version is the same. For example: 0.5.1 is compatible with 0.5.3 0.5.1 is not compatible with 0.6.0 1.5.1 is compatible with 1.13.0 2.1.0 is not compatible with 1.13.0 Special IdentifiersThe semantic versions specification also allows for special identifiers by postfixing the version with a hyphen followed by some identifier. This is where the network partitioning magic happens. Let's say, for example, I work for &quot;Widgets Ltd&quot; and I want to deploy a Storj network within the Widgets Ltd private network. Every workstation would run a modified version of storj/farmer or maybe my own custom interface built atop storj/core. I would simply change my Storj-based software to use the version 1.5.0-widgetsltd. The Storj protocol sees this identifies as a strict match and therefore any nodes running this version of the software will only communicate with nodes running the exact protocol identifier. Changing the VersionChanging the version in storj/core is easy as pie. In your code, simply import the module and change the identifier like so: // Import core library var storj = require('storj'); // Modify protocol version storj.version.protocol = '1.5.0-widgetsltd'; // Get on with your stuff...If you are running &quot;vanilla&quot; Storj software, you can change the protocol version by setting the STORJ_NETWORK environment variable. This will add a postfix to the protocol version, which will partition the network to nodes that are running that exact version: STORJ_NETWORK=testnet storjshare --datadir /path/to/shardsThis concept applies broadly to deploying a custom Storj network for any purpose. This could be used for a public testnet (x.x.x-testnet) or for the private network example above. Ã— Search results Close "},"tutorial-protocol-spec.html":{"id":"tutorial-protocol-spec.html","title":"Tutorial: Protocol Specification","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Protocol Specification Nodes communicate with each other using JSON-RPC 2.0 over HTTPS. This requires farmers (nodes who are contracted by renter to store data) to be publicly addressable and enables access to content from web browsers, mobile phones, and any other devices that speak HTTP (hint: everything). This document outlines the specification for the RPC interface by defining the message structure, required methods, and expected response formats that are needed for a Storj protocol compliant implementation. Note that there may be other aspects of the protocol that are implemented as SIPs (Storj Improvement Proposals). See the end of this document for a list of implemented SIPs. Request FormatRequests are formed according to the JSON-RPC 2.0 specification and are issued via HTTP POST. The Storj protocol requires the use of named parameters - positional parameters are not supported. Example: { &quot;method&quot;: &quot;PING&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;89cc3ddb4209c6e7e301c10c0257adf4fd85f253&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;3045022100de2e162d017a1e9d0ebfe2a94df3fc847b68281a9882...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The receiving node for this request would then respond with the result, which in the case of a PING message, is simply an acknowledgement that includes the recipient's contact information and required signature and nonce: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }In the event that an error occurs, an error property must be added to the response. You still need to include your contact data in the result property of the response: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;OH GOD THERE'S SO MUCH BLOOD&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Joining the NetworkTo join the Storj network, one must only know the contact information for a single &quot;seed&quot; node. A node's contact information is defined as the following three properties: address - hostname, domain, or IP port - port number on which the node is listening nodeID - hash of the node's public key (see below) protocol - version of the protocol implementation This information can be expressed as a URI in the following format: storj://10.0.0.2:1337/89cc3ddb4209c6e7e301c10c0257adf4fd85f253In addition to knowing this information about the seed, you also will need to know this information about yourself, so that it can be provided to the nodes with which you are communicating. Your &quot;contact card&quot; must be provided as the contact parameter in every message sent (both requests and responses). This is because messages must be signed with your private key and your nodeID is used by recipients to verify two things: That you own the private key corresponding to your claimed nodeID That the message was in fact sent by you and not an attacker In the Storj network, nodes are identified by the hash of the public portion of an ECDSA key pair. Key pairs are generated using curve SECP256K1 and a node's nodeID is the &quot;pubkeyhash&quot;, defined as: RIPEMD160(SHA256(public_key))This pubkeyhash, combined with a message and signature is enough data to reconstruct the complete public key and is used in the Storj network to sign and verify messages. This ensures that nodes are unable to assume the identity of another node by claiming it has the same nodeID. Special Headersx-storj-node-idEvery request sent should include this header. It's value should equal the expected Node ID of the destination. This allows nodes who are tunneling other nodes to determine who the message is intended for. PROBEBefore a node can join the network, it must determine whether or not it is reachable (or publicly addressable). This can be determined by sending a PROBE request to a known seed. { &quot;method&quot;: &quot;PROBE&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The PROBE RPC message triggers the recipient to attempt to reach the supplied Contact directly by sending a PING RPC message. If the target Contact reponds to the PING, then the PROBE should yield a success response, which is indicated by simply responding to the RPC message with only the required parameters and no error property. { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }If the PING message triggered by the PROBE fails, then the recipient of the PROBE RPC must respond with an error indicating to the sender that she is not addressable. { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;PROBE FAILED&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }If the PROBE fails, you cannot successfully join the overlay and need to establish a tunnel through a node that is addressable on the network. FIND_TUNNELFinding a node that is willing to tunnel your connection to the overlay begins with a FIND_TUNNEL RPC message sent to a known seed. Nodes on the network maintain a record of known nodes that are willing to tunnel, by subscribing to &quot;tunnel announcements&quot; over the publish/subscribe system. For more information on how nodes announce willingness to tunnel, see the documentation for Tunnelling Connections. { &quot;method&quot;: &quot;FIND_TUNNEL&quot;, &quot;params&quot;: { &quot;relayers&quot;: [], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When a node receives a FIND_TUNNEL message, it should respond with ALPHA (3) contacts that are close the the sender's nodeID who have previously published their willingness to tunnel. If the recipient herself is willing to tunnel the connection, she may include herself in the response even if her nodeID is not closer to the sender's nodeID than her known tunnels. { &quot;result&quot;: { &quot;tunnels&quot;: [ { &quot;address&quot;: &quot;10.0.0.4&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, { &quot;address&quot;: &quot;10.0.0.5&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, { &quot;address&quot;: &quot;10.0.0.6&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The result of a FIND_TUNNEL message looks almost identical to the result of a FIND_NODE message, with the exception being the name of the result key is tunnels instead of nodes. Now that the original sender possesses the contact information for some known tunnels, she should keep them in her record so that she can later respond to other's FIND_TUNNEL requests appropriately. Before the node can join the overlay (after determining it is not publicly addressable), it needs to establish a connection tunnel through one of the Contacts received from the FIND_TUNNEL request. OPEN_TUNNELEstablishing a tunnel is initiated by sending an OPEN_TUNNEL RPC message to a node who has indicated their willingness to tunnel. Only the minimum required parameters need to be sent. In the future, the protocol may be enhanced to include additional information in the OPEN_TUNNEL RPC for negotiating payment channels or other conditions. { &quot;method&quot;: &quot;OPEN_TUNNEL&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;1.0.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The recipient of the OPEN_TUNNEL message must determine whether or not she can satisfy the request. This decision may be based upon an arbitrary limit set by the node regarding how many concurrent tunnels she wishes to open, available bandwidth, etc. If the node is capable of establishing the tunnel, she must do so, assigning a dedicated address or port to receive messages and data channel requests (see data-channels). Once the tunnel's dedicated entry point has been established, she responds to the sender of the OPEN_TUNNEL request with a proxyPort to which the client may connect to receive messages. { &quot;result&quot;: { &quot;proxyPort&quot;: 12000, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;1.0.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }This response indicates that a proxy has been established and the original sender can receive messages from the overlay by opening a TCP connection to the proxyPort and contact address in the reply. In addition, the sender must update it's Contact information to mirror the remote tunneler's address and port. If the recipient of the OPEN_TUNNEL message is not able to establish a tunnel for the sender, then she may respond with an error so that the sender can attempt to open a tunnel with other known contact. { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;Failed to establish tunnel, multiplexer full&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Once your node has determined that it is publicly addressable on the network or has successfully established a tunnel, it can join the overlay network by issuing a FIND_NODE request sent to one or more known seeds. The request must include a key, contact (you), along with a signature and nonce. FIND_NODEWhen issuing a FIND_NODE request, you provide a key that represents the nodeID of the contact of which you would like to know their neighbors. When joining the network, this value is your own nodeID. { &quot;method&quot;: &quot;FIND_NODE&quot;, &quot;params&quot;: { &quot;key&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When a node receives a FIND_NODE RPC message, it must perform a lookup in it's routing table and respond with a nodes array containing the known contacts that are &quot;closest&quot; to the provided key. This is based on the XOR metric as the Storj network uses a Kademlia-based overlay. In addition, if the receiving node is not already aware of the requesting node, it may add the requester to it's own routing table to later inform other requesters. { &quot;result&quot;: { &quot;nodes&quot;: [ { &quot;address&quot;: &quot;10.0.0.4&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, { &quot;address&quot;: &quot;10.0.0.5&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, { &quot;address&quot;: &quot;10.0.0.6&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of the FIND_NODE response, the node attempting to join the network may iteratively send the same FIND_NODE request to contacts that have been newly added to the routing table to build out a wider view of the network. Once the joining node is satisfied with the size of the routing table (or there are no more nodes to discover), this is considered a successful join. Soliciting StorageOnce a node has a sufficiently complete routing table and view of the network, it's time to buddy up with it's neighbors to cooperate in the sharing and relay of publications. A &quot;publication&quot; is essentially a request for storage. When a node in the network wishes to store some data, it notifies it's closest neighbors who, if interested, will respond to negotiate a storage contract. If the neighbors are not offering storage or do not wish to fulfill the terms of the storage contract, they must check to see if any of their neighbors are and forward the publication to them. If no known neighbors are interested, then the publication is sent to a random node in that neighbor's routing table and the process repeats until an interested node fulfills the contract. SUBSCRIBEIn order to know what publications in which your neighbors are interested, we select the 3 nodes in our routing table that are identified by a nodeID that is closest to ours and we issue a SUBSCRIBE message to each of them: { &quot;method&quot;: &quot;SUBSCRIBE&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }To properly handle a SUBSCRIBE message, the recipient must respond with an attenuated bloom filter, with a size 160 bits and a depth of 3. This data structure represents 3 sets of topics to which the recipient's neighbors are subscribed 3 &quot;hops&quot; away. { &quot;result&quot;: { &quot;filters&quot;: [ &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When the original requesting node receives this response, it must update it's local attenuated bloom filter to reflect this response, starting at it's filter at index 1 (since index 0 is reserved for topic to which the node itself is interested). UPDATEAfter the requester updates it's local view of it's neighbor's publication subscriptions, it must in turn update it's neighbors with it's own publication subscriptions by providing it's own attenuated bloom filter: { &quot;method&quot;: &quot;UPDATE&quot;, &quot;params&quot;: { &quot;filters&quot;: [ &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }This method is essentially the &quot;push&quot; version of the SUBSCRIBE message, where instead of providing subscription information as a response, we provide it as a request. Whenever a node subscribes to a new publication topic, it should initiate another SUBSCRIBE/UPDATE loop with it's neighbors to ensure that it may cooperate in publication relay effectively. PUBLISHOnce a node has a view of the publications to which it's neighbors are subscribed, it is capable of issuing a PUBLISH message containing a topic and some content. This message is sent to the node's nearest neighbors, who then relay it to their neighbors based upon their own view of nearby subscriptions. The topic property and the corresponding contents data is arbitrary, but this mechanism is used for publishing &quot;asks&quot; for storage contracts. In this case, the topic is equal to the Contract type and the contents is equal to the proposed contract itself. See Publishing Storage Contracts for more information on how to choose a valid contract type for your storage needs. { &quot;method&quot;: &quot;PUBLISH&quot;, &quot;params&quot;: { &quot;uuid&quot;: &quot;7f0c40a2-e465-4f3e-b617-3d53460e34f7&quot;, &quot;topic&quot;: &quot;0f02010303&quot;, &quot;contents&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: null, &quot;farmer_id&quot;: null, &quot;farmer_signature&quot;: null, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: null }, &quot;publishers&quot;: [ &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; ], &quot;ttl&quot;: 1455228597837, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of a PUBLISH message, a node must first check to make sure it has not already received the publication. This is done by caching the uuid of received publications. If the node has already seen the publication, it should respond with an error message indicating such. The node should also make sure that the publication has not expired by checking that the ttl is a positive integer. If the node has not previously seen the publication and the message has not expired, then it must check to see if the publication topic is of interest to itself by testing it's attenuated bloom filter at index 0 for the topic. If the node is interested in the publication, it may take action accordingly. In the case of storage contract, the node may begin communicating directly with the original publisher to finalize the contract. Regardless of whether or not the node is interested in the publication, it should acknowledge receipt of the publication to the forwarder: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Then, it must append negative information to the publication message by adding it's own nodeID to the publishers property as well as decrementing the ttl. Once the message has been updated with the negative information, the node must check it's attenuated bloom filter to see if any of it's neighbors are also interested and, if so, forward the message along to them. If no neighbors are interested, the node must select a random contact from the routing table and forward the message to that contact. Negotiating Storage ContractsWhen a node receives a contract proposal in the form of a PUBLISH message and that proposal meets the recipient's criteria, it can send an OFFER message to the original publisher. OFFERThe offer message must contain the original contract, supplemented with the information that is required of the offering node, which at minimum must include farmer_id, farmer_signature, and payment_destination. The *_signature property value should be the hex-encoded signature of the JSON string representation of the contract, minus both signature fields and with keys sorted alphanumerically. In addition to these fields, the offering node (or &quot;farmer&quot;) may modify the other fields in the contract to their liking if they wish to counter the original offer: { &quot;method&quot;: &quot;OFFER&quot;, &quot;params&quot;: { &quot;contract&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: null, &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The receiving node must check the offer and determine whether or not the modified contract terms are satisfactory. If so, it may finalize the contract by adding it's signature to the renter_signature field: { &quot;result&quot;: { &quot;contract&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: &quot;304402202ccc152ee81fbff7e802c290cabea0c62384bb12...&quot;, &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Alternatively, the receiving node may counter the offer by modifying any of the fields and returning those in the response. The farmer must check the contract against it's signature to determine if the terms of the contract have been changed. This counter offer loop can continue until one party abandons the offer loop or until both parties have signed the same contract. Once a contract has been finalized, each node should store a copy locally that can be keyed by the data_hash. Executing a Storage ContractOnce a storage contract has been signed by both parties, the renter may execute the terms of the contract by issuing a CONSIGN message to the farmer. The purpose of this message is to deliver the data referenced by the contract for the farmer to store. CONSIGNThe consign message must contain the hex-encoded data_shard itself, the contract_hash, as well as an audit_tree that contains the bottom leaves of the audit strategy's merkle tree (see Auditing a Storage Contract below). { &quot;method&quot;: &quot;CONSIGN&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;audit_tree&quot;: [ &quot;40a98e19c298631cba19d6c19691360ce08ccf36&quot;, &quot;02f0d971096305e797da9165cd50d4d1bb19590b&quot;, &quot;a44ad75d8aa118cdd73df77ae2543d3e87f94576&quot;, &quot;d84e8bfac28a98df418d0c3029f77a4d9f338e9e&quot;, &quot;7408bb5b0a9eefa56f3234fc83d2423f76c4b857&quot;, &quot;d1b71886c910d34b31cee9e23316abded9ef3fe0&quot;, &quot;0ac89686a12e26aaf952180c0fec5373224c4c1e&quot;, &quot;98c304116e7eb89839ff6c96202eb4c3cbdaf8e0&quot;, &quot;c7937b8a1be9da426e076eff70c5b4edf8a66270&quot;, &quot;c6c2c5cdafb99e4d62185d42e59522d15c33d676&quot;, &quot;1f87ca29e75944aa36e676b3ddf27e49a8ca4fe2&quot;, &quot;8585e356a517535b8a36ec9222b955c5b61a5227&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of a CONSIGN message, the farmer must lookup the reference contract by the supplied data_hash and verify that the renter is authorized to store the data and that the number of items in the audit_tree is equal to the next power of 2 of the audit_count supplied in the original contract. Once verified, the farmer must respond with a generated token that the renter or another authorized party can use to open a data channel with the farmer (via websocket) to deliver the data as a binary stream. For more information on the Data Channel specification see the tutorial for data-channels. In addition, the farmer should verify that the current UNIX time is greater than or equal to the agreed upon store_begin and less than the agreed upon store_end. If everything checks out, the farmer must store the consigned data in such a way that it may later be retrieved by it's hash. Once the farmer has done this, it must acknowledge the renter to confirm: { &quot;result&quot;: { &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Using Mirrors for RedundancyIn most cases it is desirable for the renter to store multiple copies of the shard across a number of farmers in the event that one of the contracted farmers leaves the network, loses the data, or otherwise breaches the terms of the storage contract. This can be accomplished by simply performing an iterative PUBLISH - OFFER - CONSIGN loop for the desired level of redundancy, followed by the establishment of a data channel as described in data-channels. However, this method can introduce a significant amount of latency for completing a full upload that increases linearly with the number of redundant shards. Additionally, the amount of bandwidth consumed by the renter increases in the same way as the renter will have to upload the data for each redundant shard. MIRRORIn these scenarios, renters can offload the burden of storing multiple copies of a shard to the farmers by issuing a MIRROR RPC in lieu of establishing a data channel. A MIRROR RPC instructs a contracted farmer to retrieve the data already uploaded to another farmer by providing them with a retrieval token authorized by another farmer (this is performed by issuing a RETRIEVE RPC message - see Downloading Consigned Data later in this document). This allows the renter to incur the bandwidth and latency once and instead pay the recently contracted farmer to transfer the data to another farmer for redundancy. To initiate this process, instead of opening a data channel, issue a MIRROR RPC message to the farmer after contract negotiation is complete: { &quot;method&quot;: &quot;MIRROR&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;token&quot;: &quot;ce898e520cede42fd847ba5176b6d6b6ea47481f&quot;, &quot;farmer&quot;: { &quot;address&quot;: &quot;remote.farmer.host&quot;, &quot;port&quot;: 4000, &quot;nodeID&quot;: &quot;e77e46ceb7f8dbf2904eff254a479f90a4f8ddbd&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; } Note that you should wait until data is successfully consigned to the first farmer before sending a MIRROR RPC for replication. Once the mirroring farmer receives the request, it should open a data channel to the original farmer and pass along the supplied token and data hash in the initial authorization frame. Once the mirroring farmer begins receiving data it must respond to the renter's request with a simple acknowledgement to indicate that the mirror operation was successfully initiated. { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; } Note that data transfer may fail after the original acknowledgement. It is important to regularly issue AUDIT messages to farmers storing your data. If a mirror farmer later fails an audit, the renter should negotiate a new contract and attempt to create a new mirror to retain the expected level of redundancy. Auditing a Storage ContractBefore a renter issues a CONSIGN RPC, it must pre-calculate a series of &quot;challenges&quot;, the number of which must equal the audit_count defined in the negotiated contract. A challenge is simply 32 random bytes encoded as hex. The generated challenges must not be shared until the renter wishes to issue an AUDIT request. When issuing a CONSIGN request, the renter must include an audit_tree which contains the bottom leaves of a merkle tree. Each of the bottom leaves of the tree must be equal to the double RIPEMD160(SHA256(challenge + shard)) encoded as hex. In order to ensure that the resulting merkle tree is properly &quot;balanced&quot;, the number of bottom leaves must be equal to the next power of 2 of the audit count. To ensure this, the additional leaves can simply be the double RIPEMD160(SHA256('')) (the same hash function for an audit, but applied to an empty buffer). AUDITTo audit a farmer is to request proof that it is still honoring the terms of the storage contract without the need to have them supply the entire data_shard. To do this, the renter must supply the farmer with one of the secret pre-calculated challenges: { &quot;method&quot;: &quot;AUDIT&quot;, &quot;params&quot;: { &quot;audits&quot;: [ { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;challenge&quot;: &quot;6290bb9e1766bf3fc00eea3bb14146925611026d453e1aa95c32973f8baa5c98&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of an AUDIT request, the farmer must lookup the data_shard by the supplied data_hash, then calculate the single RIPEMD160(SHA256(challenge + shard)). The result of this operation should hash again to match one of the items supplied in the audit_tree property of the original CONSIGN request. In addition to supplying this single-hashed value as proof that the farmer is still honoring the terms of the contract, the farmer must also provide the uncles required to rebuild the merkle tree. This proof response is specified as a series of nested JSON arrays: { &quot;result&quot;: { &quot;proofs&quot;: [ [[[ [[&quot;6a2f02144c461e178dc4496c263313e64d7a56ab&quot; ],&quot;efb0dfa48813e3289ba8d16e9e23cf1efa1a99fd&quot; ],&quot;dfb8877b84e7a7496a4b08b2aef6ffd02ccbfccc&quot; ],&quot;82c60f546bcaaabeb908c911b1fadb816e039409&quot; ],&quot;5e265b0256cd471c6af22bd66b59ed9242067654&quot;] ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }For clarification, given a simple merkle tree: +-- Hash_0 (Root) | +-- Hash_1 | | +-- Hash_3 | | +-- Hash_4 | +-- Hash_2 | | +-- Hash_5 | | +-- Hash_6 = RIPEMD160(SHA256(RIPEMD160(SHA256(challenge + shard))))The resulting format of a proof for an audit matching Hash_6 would appear as: [Hash_1, [Hash_5, [RIPEMD160(SHA256(challenge + shard))]]]And, the resulting format of a proof for an audit matching Hash_3 would appear as: [[[RIPEMD160(SHA256(challenge + shard))], Hash_5], Hash_2]Upon receipt of the farmer's proof, the renter must verify that the proof is valid by using it to rebuild the merkle tree. See Verification#verify for an implementation example. If the proof is verified successfully, then the renter is expected to issue a payment to the payment_destination defined in the original contract. The amount of the payment should be equal to: (payment_storage_price / audit_count) + (payment_download_price * downloads_since_last_audit)If the verification fails then the contract is null and no payment is required. Conversely, if the verification succeeds and the renter does not issue the payment in a timely manner, then the contract is also null and the farmer may decide to cease storage of the data. RETRIEVEWhen a renter wishes to retrieve data that is stored under contract, it can issue a RETRIEVE RPC message that includes the data_hash to the farmer storing the data: { &quot;method&quot;: &quot;RETRIEVE&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }After the recipient of the RETRIEVE message verifies the sender's signature it must lookup the storage contract by the supplied data_hash and verify that the sender is the party with which the contract was negotiated. If all tests pass, then the farmer must respond with a generated token to allow the renter to open a data channel (via websocket) to retrieve the data as a binary stream. After the data shard is delivered successfully, the farmer must increment it's record of the downloads_since_last_audit (which must be reset after the next audit). For more information on the Data Channel specification see the tutorial for data-channels. { &quot;result&quot;: { &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.8.1&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }In addition, the renter must check the integrity of the returned data_shard by calculating the hash and checking it against the expected data_hash. If the test fails, then this effectively a failed audit and the contract is null. Implemented SIPs SIP0003 Remote Notifications and Triggers SIP0004 Contract Transfers and Renewals SIP0032 Hierarchically Deterministic Node IDs Ã— Search results Close "},"tutorial-renting-data.html":{"id":"tutorial-renting-data.html","title":"Tutorial: Renting Data to the Network","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Renting Data to the Network This tutorial covers the process for using StorjCORE to rent data to farmers on the network programmatically using a number of tools included in the library. This walkthrough should also serve as an overview for a number of the tools included in the library and how they work together. BootstrappingBefore we can join the network, we need to set up a few required components: KeyPair - for representing our identity on the network StorageAdapter - for persisting our contracts and shard metadata StorageManager - for managing our persistence layer Start by importing the storj module and instantiating these objects: var storj = require('storj'); var keypair = new storj.KeyPair(); var persistence = new storj.EmbeddedStorageAdapter('/path/to/datadir'); var manager = new storj.StorageManager(persistence);Now that we have a way of identifying ourselves to the network and keeping a record of our contracts, we can use the RenterInterface to join the network. var renter = new storj.RenterInterface({ keyPair: keypair, storageManager: manager, rpcAddress: 'ip.or.hostname', rpcPort: 1337 }); renter.join(function(err) { if (err) { return console.error('Failed to join the network'); } // CONTINUED IN NEXT EXAMPLE... });File PreparationNow that we have a connection to the network, we are ready to store some data. Before we can actually store the data, we need to get some information about the shards we need to store. We need to know: The hash of each shard that will be stored The size of each shard that will be stored The length of time we wish to store the data The number of audits we intend to issue over the life of the contract To get this information we need to process the file using a few more of the core components: FileDemuxer - for breaking the file into shards DataCipherKeyIv - for generating encryption key EncryptStream - for encrypting the shards Contract - for constructing the terms of the storage We will start by demultiplexing the file into several shard streams. Let's break our file into 6 shards. We will start by creating a FileDemuxer: var demuxer = new storj.FileDemuxer('/path/to/file');Now that we have prepared to shard a file, we need to set up event listeners on the demuxer for whenever a new shard stream is available. Once a shard stream is available, we need to encrypt it and calculate it's hash and size so we can create an appropriate Contract to offer the network. In addition we will write the encrypted shard to temporary storage so we don't have to process the file again when we are ready to transfer the data: var tmpdir = require('os').tmpdir(); var crypto = require('crypto'); var path = require('path'); demuxer.on('shard', function(shardStream) { var tmpName = path.join(tmpdir, crypto.randomBytes(6).toString('hex')); var tmpFile = fs.createWriteStream(tmpName); var key = new storj.DataCipherKeyIv('password', 'salt'); var encrypter = new storj.EncryptStream(key); var hasher = crypto.createHash('sha256'); var size = 0; encrypter.on('data', function(bytes) { hasher.update(bytes); size += bytes.length; }); tmpFile.on('finish', function() { // CONTINUED IN NEXT EXAMPLE... }); shardStream.pipe(encrypter).pipe(tmpFile); });Contract NegotiationWhen each shard is finished being encrypted and we know it's size and hash, it is time to create a Contract and offer it to the network. The example below is continued from inside the tmpFile.on('finish', callback) in the example above: var hash = utils.rmd160sha256(hasher.digest()); var contract = new storj.Contract({ renter_id: keypair.getNodeID(), data_size: size, data_hash: hash, store_begin: Date.now(), store_end: Date.now() + 604800000, // 7 days from now audit_count: 12 }); renter.getStorageOffer(contract, function(err, farmer, contract) { // CONTINUED IN NEXT EXAMPLE... });Now we have created a Contract for the shard and we are waiting for an offer from a farmer on the network. When we receive one, the callback supplied to RenterInterface#getStorageOffer above will trigger and we can proceed to transfer the shard to the farmer, but first we need to tell the farmer we are ready to transfer the shard to them and include the audit information they will need in the future. We will be using: AuditStream - for generating audit challenges and merkle tree StorageItem - for storing our private record of challenges Let's continue by reading the encrypted shard temporary file we just created and generating the challenges and merkle tree and saving a copy of the contract and associated challenges: var item = new storj.StorageItem({ hash: hash }); var auditGenerator = new storj.AuditStream(12); var encryptedShard = fs.createReadStream(tmpName); auditGenerator.on('finish', function() { item.addContract(farmer, contract); item.addAuditRecords(farmer, auditGenerator); manager.save(item, function(err) { if (err) { return console.error(err); } // CONTINUED IN NEXT EXAMPLE... }); }); encryptedShard.pipe(auditGenerator);Transferring ShardsNow that we have stored a copy of our contract and challenges, it's time to authorize a &quot;data channel&quot; (as described in data-channels) and transfer the shard to the farmer. renter.getConsignToken(farmer, contract, auditGenerator, function(err, token) { if (err) { return console.error(err); } var upload = storj.utils.createShardUploader(farmer, hash, token); var encryptedShard = fs.createReadStream(tmpName); encryptedShard.pipe(upload).on('end', () =&gt; { // CONTINUED IN THE NEXT EXAMPLE }); });Remember that these operations for contract negotiation and shard transfer are taking place for each shard in the original file. You'll want to keep track of shards and their associated contracts by grouping references to them logically as the file that they compose. This is the responsibility of implementing clients. If you do not wish to manage this yourself, consider running a Bridge or using the Storj API. Replicating Shards for RedundancyOnce we have successfully consigned our data to a farmer, we can ensure that in the event that farmer disappears, our data can be recovered from elsewhere. We use mirrors to accomplish this. Mirroring is a method for passively replicating our data, meaning that instead of uploading it again, we instruct a new farmer to retrieve it from the location we already stored it. We are also going to use the async module for managing flow control. First we'll need to negotiate a few more contracts, then authorize some retrieval tokens (outlined later in this document), and finally request some mirrors. var redundancy = 3; var mirrors = []; function _getMirroringContract(n, next) { renter.getStorageOffer(contract, function(err, mirror, contract) { renter.getRetrieveToken(farmer, contract, function(err, token) { if (err) { return next(err); } mirrors.push(mirror); next(null, { farmer: farmer, hash: hash, token: token }); }); }); } async.timesSeries(redundancy, _getMirroringContract, function(err, sources) { if (err) { return console.error(err); } renter.getMirrorNodes(sources, mirrors, function(err, completed) { if (err) { return console.error('Failed to replicate to all mirrors'); } console.info('Replicated to %s mirrors', completed.length); }); });Auditing Farmer StorageNow that we have successfully consigned a shard, we will want to be sure that the farmer is being honest about storing it. We can verify this by requesting a proof using the challenges we generated previously. We will be using: Verification - for validating the farmer's challenge response var merkleRoot = auditGenerator.getPrivateRecord().root; var treeDepth = auditGenerator.getPrivateRecord().depth; renter.getStorageProof(farmer, item, function(err, proof) { if (err) { return console.error(err); } var verification = new storj.Verification(proof); var verifyResult = verification.verify(merkleRoot, treeDepth); if (verifyResult[0] !== verifyResult[1]) { return console.error('The proof is not valid'); } manager.save(item, function(err) { if (err) { return console.error(err); } // CONTINUED IN NEXT EXAMPLE }); });Retrieving ShardsNow that we have verified that the farmer is storing the shard, we know that we can later retrieve it when needed. The process for doing this is very similar to the process for storing the shard, only this time we'll be asking for a retrieval token and we will be receiving data over the data channel instead of sending. We'll also be using: DecryptStream - for decrypting the shard stream renter.getRetrieveToken(farmer, contract, function(err, token) { if (err) { return console.error(err); } var download = utils.createShardDownloader(farmer, hash, token); var decrypter = new storj.DecryptStream(keypair); var fileDestination = fs.createWriteStream('/path/to/download/shard'); download.pipe(decrypter).pipe(fileDestination); fileDestination.on('finish', function() { console.info('Successfully downloaded shard!'); }); });This concludes the tutorial. To dive deeper, follow the reference links throughout this walkthrough and read the documentation on each of the classes used here. Ã— Search results Close "},"tutorial-tunnel-connections.html":{"id":"tutorial-tunnel-connections.html","title":"Tutorial: Tunnelling Connections","body":" Storj Core Modules storjstorj/constantsstorj/depsstorj/patchesstorj/sipsstorj/sips/0003storj/utilsstorj/version Classes AuditStreamContactContractEmbeddedStorageAdapterExchangeReportFarmerInterfaceKeyPairMonitorNetworkOfferManagerOfferStreamProofStreamProtocolRAMStorageAdapterRenterInterfaceShardServerStorageAdapterStorageItemStorageManagerStorageMigrationTransportTriggerManagerVerification Events AuditStream#event:finishEmbeddedStorageAdapter#event:addEmbeddedStorageAdapter#event:deleteEmbeddedStorageAdapter#event:readyEmbeddedStorageAdapter#event:updateFarmerInterface#event:connectedFarmerInterface#event:disconnectedFarmerInterface#event:errorFarmerInterface#event:readyFarmerInterface#event:unhandledOfferFarmerInterface#event:unhandledOfferResolvedMonitor#event:updateNetwork#event:connectedNetwork#event:disconnectedNetwork#event:errorNetwork#event:readyNetwork#event:unhandledOfferNetwork#event:unhandledOfferResolvedOfferStream#event:dataOfferStream#event:endOfferStream#event:errorRAMStorageAdapter#event:addRAMStorageAdapter#event:deleteRAMStorageAdapter#event:readyRAMStorageAdapter#event:updateRenterInterface#event:connectedRenterInterface#event:disconnectedRenterInterface#event:errorRenterInterface#event:readyRenterInterface#event:unhandledOfferRenterInterface#event:unhandledOfferResolvedShardServer#event:errorShardServer#event:shardDownloadedShardServer#event:shardUploadedStorageAdapter#event:addStorageAdapter#event:deleteStorageAdapter#event:readyStorageAdapter#event:updateTransport#event:connectionLimitReached Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesFile Encryption StandardsRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Tunnelling Connections One of the most daunting problems to tackle when designing a stable and reliable distributed network is the traversal of various constraints such as NAT and firewalls. In some cases, software can use various strategies to &quot;punch out&quot; of these constraints and become publicly addressable on the Internet. The StorjCORE library makes use of these strategies, but when they fail we must devise more complex tactics for ensuring that network participants are reachable by their peers. The Storj protocol defines a series of RPC messages that can be exchanged in order to establish a &quot;tunnel&quot;. See the Protocol Specification for more detail on these RPC messages and their purposes. A tunnel is, in essence, a proxy that allows a client that is not exposed to the Internet to be addressable as if it were. This works by a private node opening a long-lived connection to a public node who establishes a dedicated means for accepting messages on behalf of the private node and &quot;pipes&quot; any data received via those means directly back to the private node over the previously established connection. Once a tunnel has been established, the private node can begin identifying herself to the network using her tunnel's address, instead of her own. Private nodes do not need to use the tunnel to contact other nodes on the network, but rather only to be contacted. Announcing WillingnessWhen a node joins the network and is publicly addressable, it has the ability to announce to the network that it is willing and capable of tunneling connections on behalf on nodes who are private or unable to punch out to become addressable on the Internet. The process of doing this uses the same publish/subscribe system described in the Publishing Storage Contracts specification which enables nodes to maintain a view of subscriptions in their neighborhood of the network as described in the Protocol Specification. The difference between a contract publication and a tunnel announcement is in the opcode used for the topic and in the contents of the publication. Tunnel announcement publications use the opcode prefix 0x0e followed by a single criteria degree opcode to indicate their willingness to tunnel (0x00 to indicate &quot;I am no longer tunneling&quot; and 0x01 to indicate &quot;I am ready to tunnel&quot;). Whenever the condition changes, such as a node's maximum number of tunnels is reached or when a tunnel becomes available, it should issue a PUBLISH RPC message to it's nearest neighbors. { &quot;method&quot;: &quot;PUBLISH&quot;, &quot;params&quot;: { &quot;uuid&quot;: &quot;7f0c40a2-e465-4f3e-b617-3d53460e34f7&quot;, &quot;topic&quot;: &quot;0e01&quot;, &quot;contents&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337 }, &quot;publishers&quot;: [ &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; ], &quot;ttl&quot;: 1455228597837, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Public nodes should subscribe to these topics so that they can maintain an up-to-date list of nodes who are capable and willing to tunnel connections, so they can respond accurately to FIND_TUNNEL messages from private nodes. Establishing a TunnelAfter a private node has discovered some willing tunnels using the FIND_TUNNEL RPC message defined in the Protocol Specification, it can now begin the handshake to establish the tunnel. This begins by sending the OPEN_TUNNEL RPC message to the desired tunneler node. The recipient of OPEN_TUNNEL will check: Do I have enough remaining tunnels? (based on arbitrary limit set by node) Am I already tunneling for this nodeID? Has a payment channel been opened? (future spec) If the tunneling node has enough tunnels, is not already tunneling the node, and (in a future spec) if a payment channel has been opened for bandwidth, then the tunneling node opens a new dedicated TCP socket on an available port that will be used by the requester to send/receive HTTP messages. { &quot;result&quot;: { &quot;proxyPort&quot;: 12000, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Now the private node can open a TCP connect to the proxyPort provided and messages sent to the tunneler that specify your node ID in the x-storj-node-id header will be written to the connected socket. From there, you may pipe this socket directly to your locally running node. Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
