<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_datachannel_server.js.html":{"id":"lib_datachannel_server.js.html","title":"Source: lib/datachannel/server.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/datachannel/server.js 'use strict'; var ws = require('ws'); var PassThrough = require('stream').PassThrough; var assert = require('assert'); var Transport = require('../network/transport'); var Manager = require('../manager'); var events = require('events'); var inherits = require('util').inherits; var ms = require('ms'); var crypto = require('crypto'); var utils = require('../utils'); /** * Creates a data channel server for sending and receiving consigned file shards * @constructor * @param {Object} options * @param {Transport} options.transport - Transport adapter from {@link Network} * @param {Manager} options.manager - The Manager from {@link Network} * @param {kad.Logger} options.logger - Logger to use from {@link Network} * @param {Number} options.ttl - Close after idle for this length of time */ function DataChannelServer(options) { if (!(this instanceof DataChannelServer)) { return new DataChannelServer(options); } assert.ok(options, 'No options were supplied to constructor'); assert(options.transport instanceof Transport, 'Invalid transport adapter'); assert(options.manager instanceof Manager, 'Invalid manager supplied'); assert.ok(options.logger, 'Invalid logger supplied'); events.EventEmitter.call(this); this._transport = options.transport; this._manager = options.manager; this._log = options.logger; this._ttl = options.ttl || ms('2m'); this._server = new ws.Server({ server: this._transport._server }); this._allowed = {}; this._server.on('connection', this._handleConnection.bind(this)); this._server.on('error', this._handleError.bind(this)); } inherits(DataChannelServer, events.EventEmitter); /** * Begin accepting data for the given file hash and token * @param {String} token - The authorization token created for transfer * @param {String} filehash - The shard hash to allow for the token */ DataChannelServer.prototype.accept = function(token, filehash) { assert(typeof token === 'string', 'Invalid token supplied'); assert(typeof filehash === 'string', 'Invalid filehash supplied'); this._allowed[token] = { hash: filehash, client: null }; }; /** * Stop accepting data for the given token * @param {String} token - The authorization token created for transfer */ DataChannelServer.prototype.reject = function(token) { assert(typeof token === 'string', 'Invalid token supplied'); if (this._allowed[token]) { if (this._allowed[token].client) { this._allowed[token].client.close(); } delete this._allowed[token]; } }; /** * Closes the data channel and disconnects all clients */ DataChannelServer.prototype.close = function() { return this._server.close(); }; /** * Handles incoming connections * @private * @param {Socket} socket - The connected socket object */ DataChannelServer.prototype._handleConnection = function(socket) { var self = this; var token, hash, operation; this._log.info('data channel connection opened'); this.emit('connection', socket); socket.on('error', function(err) { self._log.error('data channel connection error: %s', err.message); socket.send(JSON.stringify({ code: 500, message: err.message })); }); socket.on('message', function(data/*, flags */) { if (self._allowed[token] &amp;&amp; self._allowed[token].client !== null) { return; } try { data = JSON.parse(data); } catch (err) { return socket.send(JSON.stringify({ code: 400, message: 'Failed to parse message' })).terminate(); } token = data.token; hash = data.hash; operation = data.operation; try { assert.ok(token, 'You did not supply a token'); assert.ok(self._allowed[token], 'The supplied token is not accepted'); assert.ok(hash, 'You did not supply the data hash'); assert(self._allowed[token].client === null, 'Channel is already active'); assert(self._allowed[token].hash === hash, 'Token not valid for hash'); } catch (err) { return socket.send(JSON.stringify({ code: 400, message: err.message })).terminate(); } self._allowed[token].client = socket; switch (operation) { case 'PUSH': return self._handleConsignStream(socket, token); case 'PULL': return self._handleRetrieveStream(socket, token); default: return self._handleUnknownStream(socket, token); } }); }; /** * Receives the data stream and writes it to storage * @private * @param {stream.Readable} socket - The connected socket * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleConsignStream = function(socket, token) { var self = this; var hasher = crypto.createHash('sha256'); var hash = this._allowed[token].hash; var passthrough = new PassThrough(); var received = 0; passthrough.pause(); socket.on('message', function(data) { received += data.length; passthrough.write(data); }); this._manager.load(hash, function(err, item) { if (err) { socket.send(JSON.stringify({ code: 500, message: err.message })); return self.reject(token); } var contract = Object.keys(item.contracts)[0]; var shardsize = item.contracts[contract].get('data_size'); socket.resume(); // If the shard is not writable, it means we already have it, so let's // just respond with a success message if (typeof item.shard.write !== 'function') { socket.send(JSON.stringify({ code: 200, message: 'Consignment completed successfully' })); return self.reject(token); } passthrough.on('data', function(chunk) { hasher.update(chunk); item.shard.write(chunk); if (received &gt;= shardsize) { passthrough.end(); } }).resume(); passthrough.on('end', function() { if (utils.rmd160(hasher.digest('hex')) !== hash) { socket.send(JSON.stringify({ code: 400, message: 'Calculated hash does not match the expected result' })); return self.reject(token); } item.shard.end(); socket.send(JSON.stringify({ code: 200, message: 'Consignment completed successfully' })); self.reject(token); }); }); }; /** * Pumps the data through to the client * @private * @param {stream.Readable} socket - The incoming data stream * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleRetrieveStream = function(socket, token) { var self = this; var hash = this._allowed[token].hash; this._manager.load(hash, function(err, item) { if (err) { socket.send(JSON.stringify({ code: 500, message: err.message })); return self.reject(token); } var filestream = item.shard; filestream.on('data', function(data) { filestream.pause(); socket.send(data, { binary: true }, function() { filestream.resume(); }); }); filestream.on('end', function() { self.reject(token); }); }); }; /** * Closes the stream if it cannot be handled * @private * @param {stream.Readable} stream - The incoming data stream * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleUnknownStream = function(stream, token) { var client = this._allowed[token].client; client.send({ code: 400, message: 'Failed to handle the defined operation' }); this.reject(token); }; /** * Handles binary server errors * @private * @param {Error} err - The error object */ DataChannelServer.prototype._handleError = function(err) { this._log.error('data channel server encountered an error: %s', err.message); this.emit('error', err); }; module.exports = DataChannelServer; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: index.js /** * @module storj */ 'use strict'; module.exports.version = require('./lib/version'); /** {@link Network} */ module.exports.Network = require('./lib/network'); /** {@link Transport} */ module.exports.Transport = require('./lib/network/transport'); /** {@link Contact} */ module.exports.Contact = require('./lib/network/contact'); /** {@link DataChannelClient} */ module.exports.DataChannelClient = require('./lib/datachannel/client'); /** {@link DataChannelServer} */ module.exports.DataChannelServer = require('./lib/datachannel/server'); /** {@link Protocol} */ module.exports.Protocol = require('./lib/network/protocol'); /** {@link Contract} */ module.exports.Contract = require('./lib/contract'); /** {@link Audit} */ module.exports.Audit = require('./lib/audit'); /** {@link Proof} */ module.exports.Proof = require('./lib/proof'); /** {@link Verification} */ module.exports.Verification = require('./lib/verification'); /** {@link Manager} */ module.exports.Manager = require('./lib/manager'); /** {@link StorageAdapter} */ module.exports.StorageAdapter = require('./lib/storage/adapter'); /** {@link FSStorageAdapter} */ module.exports.FSStorageAdapter = require('./lib/storage/adapters/fs'); /** {@link RAMStorageAdapter} */ module.exports.RAMStorageAdapter = require('./lib/storage/adapters/ram'); /** {@link StorageItem} */ module.exports.StorageItem = require('./lib/storage/item'); /** {@link KeyPair} */ module.exports.KeyPair = require('./lib/keypair'); /** {@link constants} */ module.exports.constants = require('./lib/constants'); /** {@link utils} */ module.exports.utils = require('./lib/utils'); × Search results Close "},"lib_audit.js.html":{"id":"lib_audit.js.html","title":"Source: lib/audit.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/audit.js 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var constants = require('./constants'); var MerkleTree = require('mtree'); var merge = require('merge'); var utils = require('./utils'); /** * Represents an auditing interface using a precomputed merkle tree * @constructor * @param {Object} options * @param {Number} options.audits - Total number of challenges to generate * @param {Buffer} options.shard - Data to create audit challenges for */ function Audit(options) { if (!(this instanceof Audit)) { return new Audit(options); } options = merge(Object.create(Audit.DEFAULTS), options); assert(Buffer.isBuffer(options.shard), 'Invalid shard supplied'); assert( options.audits &gt; 0 &amp;&amp; (options.audits % 2 === 0), 'Must supply an even audits value greater than 0' ); this._shard = options.shard; this._audits = options.audits; this._challenges = []; this._tree = this._generateTree(); } Audit.DEFAULTS = { audits: 12, shard: new Buffer([]), }; /** * Returns the bottom leaves of the merkle tree for sending to farmer * @returns {Array} leaves - Bottom merkle leaves of audit tree */ Audit.prototype.getPublicRecord = function() { return this._tree.level(this._tree.levels() - 1); }; /** * Returns the challenges, the tree depth, and merkle root * @returns {Object} challenge - Private audit record with challenges */ Audit.prototype.getPrivateRecord = function() { return { root: this._tree.root(), depth: this._tree.levels(), challenges: this._challenges }; }; /** * Generate the audit merkle tree from a series of challenges * @private * @returns {Audit} self */ Audit.prototype._generateTree = function() { var iterations = 0; var inputs = []; while (iterations &lt; this._audits) { var challenge = this._generateChallenge(); var input = this._createResponseInput(challenge); this._challenges.push(challenge); inputs.push(input); iterations++; } while (iterations &lt; utils.getNextPowerOfTwo(this._audits)) { inputs.push(utils.rmd160sha256('')); iterations++; } return new MerkleTree(inputs, utils.rmd160sha256); }; /** * Generate a random challenge buffer * @private * @returns {String} Hex encoded random bytes */ Audit.prototype._generateChallenge = function() { return crypto.randomBytes(constants.AUDIT_BYTES).toString('hex'); }; /** * Create a challenge response input to merkle tree * @private * @param {Array} response * @returns {Buffer} input - Concatenated challenge+shard_hash */ Audit.prototype._createResponseInput = function(challenge) { return utils.rmd160sha256(utils.rmd160sha256( challenge + this._shard.toString('hex') )); }; module.exports = Audit; × Search results Close "},"lib_constants.js.html":{"id":"lib_constants.js.html","title":"Source: lib/constants.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/constants.js /** * @module storj/constants */ 'use strict'; module.exports = { /** @constant {Number} PREFIX - NodeID prefix (same as bitcoin) */ PREFIX: 0x00, /** @constant {Number} NONCE_EXPIRE - Time to honor a signed message */ NONCE_EXPIRE: 10000, /** @constant {Number} AUDIT_BYTES - Number of bytes for audit challenge */ AUDIT_BYTES: 32, /** @constant {Number} CLEAN_INTERVAL - Interval for reaping stale shards */ CLEAN_INTERVAL: 3600000, /** @constant {Number} OPCODE_DEG_LOW - Opcode for low criteria degree */ OPCODE_DEG_LOW: 0x01, /** @constant {Number} OPCODE_DEG_MED - Opcode for medium criteria degree */ OPCODE_DEG_MED: 0x02, /** @constant {Number} OPCODE_DEG_HIGH - Opcode for medium criteria degree */ OPCODE_DEG_HIGH: 0x03 }; × Search results Close "},"lib_contract_index.js.html":{"id":"lib_contract_index.js.html","title":"Source: lib/contract/index.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/contract/index.js 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var merge = require('merge'); var JSONSchema = require('jsen'); var stringify = require('json-stable-stringify'); var bitcore = require('bitcore-lib'); var constants = require('../constants'); var Message = require('bitcore-message'); var ms = require('ms'); /** * Represents a storage contract between a renter and a farmer * @constructor * @version 0 * @param {Object} contract * @param {String} contract.type - Unique identifier for the contract * @param {String} contract.renter_id - Node ID of the renter * @param {String} contract.renter_signature - Renter's cryptographic signature * @param {String} contract.farmer_id - Node ID of the farmer * @param {String} contract.farmer_signature - Farmer's cryptographic signature * @param {Number} contract.data_size - Number of bytes to store * @param {String} contract.data_hash - RIPEMD-160 SHA-256 hash of the data * @param {Number} contract.store_begin - UNIX timestamp to start contract * @param {Number} contract.store_end - UNIX timestamp to end the contract * @param {Number} contract.audit_count - Number of audits renter will perform * @param {Number} contract.payment_storage_price - Total price for storage * @param {Number} contract.payment_download_price - Price per download * @param {String} contract.payment_destination - Bitcoin address to send funds * @param {Object} criteria * @param {Number} criteria.size - Criteria degree OPCODE * @param {Number} criteria.duration - Criteria degree OPCODE * @param {Number} criteria.availability - Criteria degree OPCODE * @param {Number} criteria.speed - Criteria degree OPCODE */ function Contract(contract, criteria) { if (!(this instanceof Contract)) { return new Contract(contract, criteria); } this._properties = merge(Object.create(Contract.DEFAULTS), contract); this._validator = Contract.createValidator(); this._criteria = this._inferCriteria(criteria); this._clean(); assert.ok(this._validate(), 'Invalid contract specification was supplied'); } /** * Defines the JSON Schema of a {@link Contract} * @static */ Contract.Schema = require('./schema.json'); /** * Defines some default properties of a {@link Contract} * @static */ Contract.DEFAULTS = { version: 0, renter_id: null, renter_signature: null, farmer_id: null, farmer_signature: null, data_size: 1234, data_hash: null, store_begin: 2000000000, store_end: 3000000000, audit_count: 10, payment_storage_price: 0, payment_download_price: 0, payment_destination: null }; /** * Defines some default criteria of a {@link Contract} * @static */ Contract.CRITERIA = { size: constants.OPCODE_DEG_MED, duration: constants.OPCODE_DEG_MED, availability: constants.OPCODE_DEG_MED, speed: constants.OPCODE_DEG_MED }; /** * Defines the criteria matrix for a {@link Contract} * @static */ Contract.MATRIX = { size: function(size) { if (size &gt; 0 &amp;&amp; size &lt;= (8 * 1024 * 1024)) { return constants.OPCODE_DEG_LOW; } if (size &gt; (8 * 1024) &amp;&amp; size &lt;= (16 * 1024 * 1024)) { return constants.OPCODE_DEG_MED; } if (size &gt; (16 * 1024) &amp;&amp; size &lt;= (32 * 1024 * 1024)) { return constants.OPCODE_DEG_HIGH; } }, duration: function(duration) { if (duration &gt; 0 &amp;&amp; duration &lt;= ms('30d')) { return constants.OPCODE_DEG_LOW; } if (duration &gt; ms('30d') &amp;&amp; duration &lt;= ms('90d')) { return constants.OPCODE_DEG_MED; } if (duration &gt; ms('90d') &amp;&amp; duration &lt;= ms('320d')) { return constants.OPCODE_DEG_HIGH; } }, availability: function(availability) { if (availability &gt;= 0.5 &amp;&amp; availability &lt;= 0.7) { return constants.OPCODE_DEG_LOW; } if (availability &gt; 0.7 &amp;&amp; availability &lt;= 0.9) { return constants.OPCODE_DEG_MED; } if (availability &gt; 0.9) { return constants.OPCODE_DEG_HIGH; } }, speed: function(speed) { if (speed &gt; 0 &amp;&amp; speed &lt;= 6) { return constants.OPCODE_DEG_LOW; } if (speed &gt; 6 &amp;&amp; speed &lt;= 12) { return constants.OPCODE_DEG_MED; } if (speed &gt; 12 &amp;&amp; speed &lt;= 32) { return constants.OPCODE_DEG_HIGH; } } }; /** * Removes all properties not in the schema from contract * @private * @param {Object} criteria - Criteria degree opcodes * @returns {Object} */ Contract.prototype._inferCriteria = function(criteria) { var opcodes = Object.create(Contract.CRITERIA); opcodes.size = Contract.MATRIX.size(this.get('data_size')); opcodes.duration = Contract.MATRIX.duration( this.get('store_end') - this.get('store_begin') ); // NB: Do not try to infer availability or speed, should be explicit return merge(opcodes, criteria); }; /** * Removes all properties not in the schema from contract * @private * @returns {Contract} self */ Contract.prototype._clean = function() { var keys = Object.keys(Contract.Schema.properties); for (var field in this._properties) { if (keys.indexOf(field) === -1) { delete this._properties[field]; } } return this; }; /** * Validates the contract specification * @private * @returns {Boolean} validity */ Contract.prototype._validate = function() { return this._validator(this._properties); }; /** * Checks if the contract is complete * @private * @returns {Boolean} completed */ Contract.prototype._complete = function() { for (var prop in this._properties) { if (this._properties[prop] === null) { return false; } } return true; }; /** * Returns the string representation of the contract, minus the signature * fields, sorted alphanumerically for signing and verifying * @private * @returns {String} */ Contract.prototype._getSigningData = function() { var sorted = this.toObject(); delete sorted.renter_signature; delete sorted.farmer_signature; return stringify(sorted); }; /** * Signs the contract as the given actor * @param {String} actor - One of 'farmer' or 'renter' * @param {Buffer} secret - ECDSA private key * @returns {String} signature */ Contract.prototype.sign = function(actor, secret) { var property = actor + '_signature'; var message = Message(this._getSigningData()); var signature = message.sign(bitcore.PrivateKey.fromString(secret)); return this.set(property, signature); }; /** * Verify the contract signature for the given actor * @param {String} actor - One of 'farmer' or 'renter' * @param {Buffer} pubkeyhash - ECDSA nodeID * @returns {Boolean} validity */ Contract.prototype.verify = function(actor, pubkeyhash) { var property = actor + '_signature'; var message = Message(this._getSigningData()); var address = bitcore.Address.fromPublicKeyHash(Buffer(pubkeyhash, 'hex')); return message.verify(address, this.get(property)); }; /** * Applies the provided fields to the contract and validates it * @param {Object} fields - Contract properties to update * @returns {Contract} self */ Contract.prototype.update = function(fields) { for (var prop in fields) { this.set(prop, fields[prop]); } return this; }; /** * Returns the value for the given contract property * @param {String} field_name - Contract property to get * @returns {String|Number|null} value */ Contract.prototype.get = function(field_name) { return this._properties[field_name]; }; /** * Sets the contract property to the given value * @param {String} field_name - Contract property to get * @returns {String|Number|null} value */ Contract.prototype.set = function(field_name, field_value) { this._properties[field_name] = field_value; this._clean(); assert.ok(this._validate(), 'Invalid contract property supplied'); return this._properties[field_name]; }; /** * Calculates the SHA-256 hash of the serialized contract * @returns {Buffer} */ Contract.prototype.getHash = function() { return crypto.createHash('sha256').update(this.toBuffer()).digest(); }; /** * Return OPCODE byte sequence for contract publication topic * @returns {Buffer} */ Contract.prototype.getTopicBuffer = function() { return Contract.createTopic(this._criteria); }; /** * Return OPCODE byte sequence for contract publication topic as hex string * @returns {String} */ Contract.prototype.getTopicString = function() { return this.getTopicBuffer().toString('hex'); }; /** * Converts the contract to a plain object * @returns {Object} */ Contract.prototype.toObject = function() { return JSON.parse(this.toJSON()); }; /** * Converts the contract to JSON string * @returns {String} */ Contract.prototype.toJSON = function() { return stringify(this._properties); }; /** * Converts the contract to Buffer * @returns {Buffer} */ Contract.prototype.toBuffer = function() { return new Buffer(this.toJSON(), 'utf8'); }; /** * Creates a contract from a plain object * @param {Object} object - Dictionary of contract data * @returns {Contract} */ Contract.fromObject = function(object) { return new Contract(object); }; /** * Creates a contract from a JSON string * @param {String} json - JSON encoded contract * @returns {Contract} */ Contract.fromJSON = function(json) { return new Contract(JSON.parse(json)); }; /** * Creates a contract from a Buffer * @param {Buffer} buffer - Raw binary blob of contract data * @returns {Contract} */ Contract.fromBuffer = function(buffer) { return new Contract(JSON.parse(buffer.toString('utf8'))); }; /** * Creates a validator function for data against the schema * @returns {Function} validator */ Contract.createValidator = function() { return JSONSchema(Contract.Schema); }; /** * Create a topical OPCODE byte sequence from the provided criteria * @param {Object} criteria * @param {Number} criteria.size - Criteria degree OPCODE * @param {Number} criteria.duration - Criteria degree OPCODE * @param {Number} criteria.availability - Criteria degree OPCODE * @param {Number} criteria.speed - Criteria degree OPCODE * @returns {Buffer} */ Contract.createTopic = function(criteria) { criteria = merge(Object.create(Contract.CRITERIA), criteria); return new Buffer([ criteria.size, criteria.duration, criteria.availability, criteria.speed ]); }; /** * Compares two contracts against each other * @param {Contract} c1 - Contract to compare * @param {Contract} c2 - Contract to compare * @returns {Boolean} */ Contract.compare = function(c1, c2) { var contract1 = c1.toObject(); var contract2 = c2.toObject(); var ignored = [ 'renter_id', 'renter_signature', 'farmer_id', 'farmer_signature', 'payment_destination' ]; ignored.forEach(function(prop) { delete contract1[prop]; delete contract2[prop]; }); return JSON.stringify(contract1) === JSON.stringify(contract2); }; module.exports = Contract; × Search results Close "},"lib_datachannel_client.js.html":{"id":"lib_datachannel_client.js.html","title":"Source: lib/datachannel/client.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/datachannel/client.js 'use strict'; var WebSocketClient = require('ws'); var stream = require('stream'); var assert = require('assert'); var events = require('events'); var inherits = require('util').inherits; var url = require('url'); var utils = require('../utils'); /** * Creates a data channel client for sending and receiving consigned file shards * @constructor * @param {Object} contact * @param {String} contact.address - The address of the target farmer * @param {Number} contact.port - The port of the target farmer */ function DataChannelClient(contact) { if (!(this instanceof DataChannelClient)) { return new DataChannelClient(contact); } assert.ok(contact, 'No contact was supplied to constructor'); assert(typeof contact.address === 'string', 'Invalid contact address'); assert(typeof contact.port === 'number', 'Invalid contact port'); events.EventEmitter.call(this); this._contact = contact; this._client = new WebSocketClient(DataChannelClient.getChannelURL(contact)); this._client.on('open', this._handleChannelOpen.bind(this)); this._client.on('error', this._handleChannelError.bind(this)); } inherits(DataChannelClient, events.EventEmitter); /** * Creates a Readable Stream for the token and hash that receives the data * @param {String} token - The RETRIEVE token supplied by the farmer * @param {String} hash - The hash of the data to retrieve * @returns {stream.Readable} */ DataChannelClient.prototype.retrieve = function(token, hash) { var pstream = new stream.PassThrough(); this._client.on('message', function(data) { if (!Buffer.isBuffer(data)) { try { data = JSON.parse(data); } catch (err) { return pstream.emit('error', err); } if (data.code &amp;&amp; data.code !== 200) { pstream.emit('error', new Error(data.message)); } } pstream.write(data); }); this._client.on('close', function() { pstream.end(); }); this._client.send(JSON.stringify({ token: token, hash: hash, operation: 'PULL' })); return pstream; }; /** * Creates a Writable Stream for the token and hash that stores the data * @param {String} token - The CONSIGN token supplied by the farmer * @param {Buffer} data - The data to store */ DataChannelClient.prototype.consign = function(token, data, callback) { var self = this; var hash = utils.rmd160sha256(data); self._client.on('message', function(data) { if (data.code &amp;&amp; data.code !== 200) { callback(new Error(data.message)); } else { callback(null, hash); } this.close(); }); this._client.send(JSON.stringify({ token: token, hash: hash, operation: 'PUSH' }), function() { self._client.send(data, { binary: true }); }); }; /** * Handles the open event from the underlying client * @private */ DataChannelClient.prototype._handleChannelOpen = function() { this.emit('open'); }; /** * Handles the open event from the underlying client * @private */ DataChannelClient.prototype._handleChannelError = function(err) { this.emit('error', err); }; /** * Returns the URI of the contact's data channel * @static * @param {Object} contact */ DataChannelClient.getChannelURL = function(contact) { return url.format({ protocol: 'ws', slashes: true, hostname: contact.address, port: contact.port }); }; module.exports = DataChannelClient; × Search results Close "},"lib_keypair.js.html":{"id":"lib_keypair.js.html","title":"Source: lib/keypair.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/keypair.js 'use strict'; var bitcore = require('bitcore-lib'); var ECIES = require('bitcore-ecies'); /** * Represents a ECDSA key pair * @constructor * @param {String|Buffer} privkey - WIF encoded ECDSA private key */ function KeyPair(privkey) { if (!(this instanceof KeyPair)) { return new KeyPair(privkey); } if (privkey) { this._privkey = bitcore.PrivateKey.fromString(privkey); } else { this._privkey = bitcore.PrivateKey.fromRandom(); } this._pubkey = this._privkey.toPublicKey(); this._cipher = ECIES().privateKey(this._privkey).publicKey(this._pubkey); } /** * Returns the private key * @returns {String} key */ KeyPair.prototype.getPrivateKey = function() { return this._privkey.toString(); }; /** * Returns the public key * @returns {String} key */ KeyPair.prototype.getPublicKey = function() { return this._pubkey.toString(); }; /** * Returns the NodeID derived from the public key * @returns {String} nodeID - RIPEMD160 hash of public key */ KeyPair.prototype.getNodeID = function() { return bitcore.crypto.Hash.sha256ripemd160( this._pubkey.toBuffer() ).toString('hex'); }; /** * Returns the bitcoin address version of the nodeID * @returns {String} address - Base58 encoded address */ KeyPair.prototype.getAddress = function() { return bitcore.Address.fromPublicKeyHash( new Buffer(this.getNodeID(), 'hex') ).toString(); }; /** * Encrypts the data * @param {Buffer|String} data * @returns {Buffer} */ KeyPair.prototype.encrypt = function(data) { return this._cipher.encrypt(data); }; /** * Decrypts the data * @param {Buffer|String} data * @returns {Buffer} */ KeyPair.prototype.decrypt = function(data) { return this._cipher.decrypt(data); }; module.exports = KeyPair; × Search results Close "},"lib_manager.js.html":{"id":"lib_manager.js.html","title":"Source: lib/manager.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/manager.js 'use strict'; var assert = require('assert'); var StorageAdapter = require('./storage/adapter'); var StorageItem = require('./storage/item'); /** * Interface for managing contracts, shards, and audits * @constructor * @param {StorageAdapter} storage - Storage adapter to use */ function Manager(storage) { if (!(this instanceof Manager)) { return new Manager(storage); } assert(storage instanceof StorageAdapter, 'Invalid storage adapter'); this._storage = storage; } /** * Loads the storage {@link Item} at the given key * @param {String} hash - Shard hash to load data for * @param {Function} callback - Called with error or {@link StorageItem} */ Manager.prototype.load = function(hash, callback) { assert(typeof hash === 'string', 'Invalid key supplied'); assert(hash.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); this._storage.get(hash, function(err, item) { if (err) { return callback(err); } if (!(item instanceof StorageItem)) { return callback(new Error('Storage adapter provided invalid result')); } callback(null, item); }); }; /** * Saves the storage {@link StorageItem} at the given key * @param {StorageItem} item - The {@link StorageItem} to store * @param {Function} callback - Called on complete */ Manager.prototype.save = function(item, callback) { assert(item instanceof StorageItem, 'Invalid storage item supplied'); assert(typeof callback === 'function', 'Callback function must be supplied'); this._storage.put(item, callback); }; /** * Enumerates all storage contracts and reaps stale data * @param {Function} callback - Called on complete */ Manager.prototype.clean = function(callback) { var self = this; var rstream = this._storage.createReadStream(); rstream.on('data', function(item) { rstream.pause(); var total = Object.keys(item.contracts).length; var ended = 0; for (var nodeID in item.contracts) { if (item.contracts[nodeID].get('store_end') &lt; Date.now()) { ended++; } } if (total === ended) { self._storage.del(item.hash, function(/* err */) { rstream.resume(); }); } else { rstream.resume(); } }); rstream.on('end', callback); }; module.exports = Manager; × Search results Close "},"lib_network_contact.js.html":{"id":"lib_network_contact.js.html","title":"Source: lib/network/contact.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/network/contact.js 'use strict'; var kad = require('kad'); var inherits = require('util').inherits; var protocol = require('../..').version; /** * Represents a Storj contact (or peer) * @constructor * @param {Object} options */ function Contact(options) { if (!(this instanceof Contact)) { return new Contact(options); } this.protocol = options.protocol || protocol; kad.contacts.AddressPortContact.call(this, options); } inherits(Contact, kad.contacts.AddressPortContact); module.exports = Contact; × Search results Close "},"lib_network_index.js.html":{"id":"lib_network_index.js.html","title":"Source: lib/network/index.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/network/index.js 'use strict'; var path = require('path'); var url = require('url'); var assert = require('assert'); var merge = require('merge'); var async = require('async'); var kad = require('kad'); var ms = require('ms'); var bitcore = require('bitcore-lib'); var constants = require('../constants'); var Message = require('bitcore-message'); var Quasar = require('kad-quasar').Protocol; var utils = require('../utils'); var KeyPair = require('../keypair'); var Manager = require('../manager'); var StorageItem = require('../storage/item'); var Protocol = require('./protocol'); var Contract = require('../contract'); var Contact = require('./contact'); var Audit = require('../audit'); var Verification = require('../verification'); var Transport = require('./transport'); var DataChannelServer = require('../datachannel/server'); var DataChannelClient = require('../datachannel/client'); /** * Storj network interface * @constructor * @param {Object} options * @param {KeyPair} options.keypair - Node's cryptographic identity * @param {Manager} options.manager - Persistence management interface * @param {Number} options.loglevel - Verbosity level 0 - 4 * @param {Object} options.logger - Optional logger override * @param {Array} options.seeds - List of seed URIs to join * @param {String} options.datadir - Directory path to store data * @param {Object} options.contact * @param {String} options.contact.address - Public node IP or hostname * @param {Number} options.contact.port - Listening port for RPC * @param {Array} options.farmer - List of topic strings to subscribe * @param {Boolean} options.noforward - Flag for skipping traversal strategies */ function Network(options) { if (!(this instanceof Network)) { return new Network(options); } var self = this; assert(options.keypair instanceof KeyPair, 'Invalid keypair supplied'); assert(options.manager instanceof Manager, 'Invalid manager supplied'); this._pendingContracts = {}; this._keypair = options.keypair; this._manager = options.manager; this._options = merge(Object.create(Network.DEFAULTS), options); this._logger = options.logger || new kad.Logger(options.loglevel, 'STORJ'); this._contact = new Contact( merge(this._options.contact, { nodeID: this._keypair.getNodeID() }) ); this._transport = new Transport(this._contact, { logger: this._logger, cors: true, // TODO: make this configurable allow farmers to tunnel for others tunnelhost: 'http://tunnel.metadisk.org', noforward: this._options.noforward }); this._transport.after('open', function() { self._channel = new DataChannelServer({ transport: self._transport, manager: self._manager, logger: self._logger }); }); this._router = new kad.Router({ transport: this._transport, logger: this._logger }); this._pubsub = new Quasar(this._router, { logger: this._logger }); if (this._options.datadir) { this._storage = new kad.storage.FS( path.join(this._options.datadir, 'items') ); } else { this._storage = new kad.storage.MemStore(); } this._pubkeys = {}; this._open = false; this._initShardReaper(); } Network.DEFAULTS = { loglevel: 3, seeds: [], datadir: null, contact: { address: '127.0.0.1', port: 4000, }, farmer: [], noforward: false }; /** * Opens the connection to the network * @param {Function} callback - Called on successful network join */ Network.prototype.join = function(callback) { var self = this; var seeds = this._options.seeds.map(this._createContact); var protocol = new Protocol({ network: this }); assert(!this._open, 'Network interface already open'); this._transport.on('error', this._handleTransportError.bind(this)); this._transport.before('serialize', this._signMessage.bind(this)); this._transport.before('receive', this._verifyMessage.bind(this)); this._transport.before('receive', kad.hooks.protocol(protocol.handlers())); this._node = new kad.Node({ transport: this._transport, router: this._router, storage: this._storage, logger: this._logger }); this._open = true; async.each(seeds, function(contact, next) { self._node.connect(contact, function(err) { if (!err) { self._addPingInterval(contact, ms('5m')); } }); next(); }, function() { if (self._options.farmer.length) { self._farm(); } callback(null, self); }); }; /** * Disconnects from the network * @param {Function} callback - Called when successful disconnect */ Network.prototype.leave = function(callback) { this._removePingInterval(); this._node.disconnect(callback); }; /** * Look up the storage contract by the hash to find the node who has * the shard. Look up the appropriate challenge and send it to the node * for verification. If successful, invalidate the challenge and pass, * otherwise, invalidate the contract. * @param {String} hash - RIPEMD-160 SHA-256 hash of the file to audit * @param {Function} callback - Called with validity information */ Network.prototype.audit = function(hash, callback) { var self = this; self._manager.load(hash, function(err, item) { if (err) { return callback(err); } // TODO: Be smarter about which contract holder we choose if there is more // TODO: than a single farmer holding our shard. // TODO: Also, if one farmer fails to respond, we should try another var farmerID = Object.keys(item.contracts)[0]; self._router.findNode(farmerID, function(err, nodes) { if (err) { return callback(err); } var farmer = nodes.filter(function(node) { return node.nodeID === farmerID; })[0]; if (!farmer) { return callback(new Error('Could not find the farmer')); } var audit = item.challenges[farmer.nodeID]; var message = new kad.Message({ method: 'AUDIT', params: { data_hash: hash, challenge: audit.challenges[0], contact: self._contact } }); self._transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } if (!response.result.proof) { return callback(new Error('Invalid proof returned')); } var verification = new Verification(response.result.proof); callback(null, verification.verify(audit.root, audit.depth)); }); }); }); }; /** * Look up the storage contract by the hash to find the node who has * the shard, then execute a RETRIEVE RPC to the node and return the * data as a buffer. * @param {String} hash - RIPEMD-160 SHA-256 hash of the file to retrieve * @param {Function} callback - Called with an error or the file buffer */ Network.prototype.retrieve = function(hash, callback) { var self = this; self._manager.load(hash, function(err, item) { if (err) { return callback(err); } // TODO: Be smarter about which contract holder we choose if there is more // TODO: than a single farmer holding our shard. var farmerID = Object.keys(item.contracts)[0]; self._router.findNode(farmerID, function(err, nodes) { if (err) { return callback(err); } var farmer = nodes.filter(function(node) { return node.nodeID === farmerID; })[0]; if (!farmer) { return callback(new Error('Could not find the farmer')); } var message = new kad.Message({ method: 'RETRIEVE', params: { data_hash: hash, contact: self._contact } }); self._transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } var token = response.result.token; var channel = new DataChannelClient(response.result.contact); channel.on('open', function() { callback(null, channel.retrieve(token, hash)); }); }); }); }); }; /** * Create a contract from the data and options supplied and publish it * on the network. Keep track of the pending contract until it becomes * fulfilled by an OFFER, then issue a CONSIGN RPC to the offerer and * callback when the data is stored. * @param {Buffer} data - Raw binary blob to store * @param {String} duration - String representation of time for `ms` like &quot;2w&quot; * @param {Function} callback - Called on successful store */ Network.prototype.store = function(data, duration, callback) { assert(Buffer.isBuffer(data), 'Invalid data supplied'); assert(typeof duration === 'string', 'Invalid duration supplied'); assert(typeof callback === 'function', 'Callback is not a function'); var self = this; var shardHash = utils.rmd160sha256(data); var contract = new Contract({ renter_id: this._keypair.getNodeID(), data_size: data.length, data_hash: shardHash, store_begin: Date.now(), store_end: Date.now() + ms(duration), audit_count: 12 // TODO: Make this configurable }, { // TODO: Make criteria configurable }); var audit = new Audit({ audits: 12, shard: data }); // Store a reference to this contract as a function to issue a CONSIGN this._pendingContracts[shardHash] = function(farmer) { var message = new kad.Message({ method: 'CONSIGN', params: { data_hash: contract.get('data_hash'), audit_tree: audit.getPublicRecord(), contact: self._contact } }); self._transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } var token = response.result.token; var channel = new DataChannelClient(response.result.contact); channel.on('open', function() { channel.consign(token, data, function(err, hash) { if (err) { return callback(err); } self._manager.load(shardHash, function(err, item) { if (err) { item = new StorageItem({ hash: shardHash }); } item.trees[farmer.nodeID] = audit.getPublicRecord(); item.challenges[farmer.nodeID] = audit.getPrivateRecord(); item.meta[farmer.nodeID] = {}; self._manager.save(item, function(err) { if (err) { return callback(err); } callback(null, hash); }); }); }); }); }); }; self._publish(contract); }; /** * Subscribes to all storage contracts and issues offers, for now this just * accepts the initial offer and signs it * @private */ Network.prototype._farm = function() { var self = this; var topics = self._options.farmer; topics.forEach(function(topic) { self._subscribe(topic, self._negotiateContract.bind(self)); }); }; /** * Handles a received contract and negotiates storage * @private * @param {Contract} contract */ Network.prototype._negotiateContract = function(contract) { var self = this; // TODO: Refactor all of this. contract.set('farmer_id', self._keypair.getNodeID()); contract.set('payment_destination', self._keypair.getAddress()); contract.sign('farmer', self._keypair.getPrivateKey()); var final; var item = new StorageItem({ hash: contract.get('data_hash') }); var renterId = contract.get('renter_id'); item.contracts[renterId] = contract.toObject(); item.meta[renterId] = {}; self._manager.save(item, function(err) { if (err) { return self._logger.error(err.message); } self._router.findNode(renterId, function(err, nodes) { if (err) { return self._logger.error(err.message); } var renter = nodes.filter(function(node) { return node.nodeID === renterId; })[0]; if (!renter) { return self._logger.error('Could not locate renter for offer'); } var message = new kad.Message({ method: 'OFFER', params: { contract: contract.toObject(), contact: self._contact } }); self._transport.send(renter, message, function(err, response) { if (err) { return self._logger.error(err.message); } if (response.error || !response.result.contract) { return self._logger.error( response.error ? response.error.message : 'Renter refused to sign' ); } try { final = Contract.fromObject(response.result.contract); } catch (err) { return self._logger.error('Renter responded with invalid contract'); } if (!final.verify('renter', contract.get('renter_id'))) { return self._logger.error('Renter signature is invalid'); } self._manager.load(contract.get('data_hash'), function(err, item) { if (err) { item = new StorageItem({ hash: contract.get('data_hash') }); } item.contracts[renter.nodeID] = contract.toObject(); item.meta[renter.nodeID] = {}; self._manager.save(item, function() {}); }); }); }); }); }; /** * Publishes a contract to the network * @private * @param {Contract} contract */ Network.prototype._publish = function(contract) { assert(contract instanceof Contract, 'Invalid contract supplied'); return this._pubsub.publish(contract.getTopicString(), contract.toObject()); }; /** * Subscribes to a contract identifier on the network * @private * @param {String} identifier * @param {Function} handler */ Network.prototype._subscribe = function(identifier, handler) { return this._pubsub.subscribe(identifier, function(contract) { var contractObj; try { contractObj = Contract.fromObject(contract); } catch (err) { return false; // If the contract is invalid just drop it } handler(contractObj); }); }; /** * Connects to the node at the given URI * @private * @param {String} uri * @param {Function} callback */ Network.prototype._connect = function(uri, callback) { return this._node.connect(this._createContact(uri), callback); }; /** * Returns a Storj contact from the URI * @private * @param {String} uri */ Network.prototype._createContact = function(uri) { var parsed = url.parse(uri); return new kad.contacts.AddressPortContact({ address: parsed.hostname, port: Number(parsed.port), nodeID: parsed.path.substr(1) }); }; /** * Signs an outgoing message * @private * @param {kad.Message} message * @param {Function} callback */ Network.prototype._signMessage = function(message, callback) { var nonce = Date.now(); var target = message.id + nonce; var signature = Message(target).sign(this._keypair._privkey); if (kad.Message.isRequest(message)) { message.params.nonce = nonce; message.params.signature = signature; } else { message.result.nonce = nonce; message.result.signature = signature; } callback(); }; /** * Verifies an incoming message * @private * @param {kad.Message} message * @param {Contact} contact * @param {Function} callback */ Network.prototype._verifyMessage = function(message, contact, callback) { var nonce, signature; if (!utils.isCompatibleVersion(contact.protocol)) { return callback(new Error('Protocol version is incompatible')); } if (kad.Message.isRequest(message)) { nonce = message.params.nonce; signature = message.params.signature; } else { nonce = message.result.nonce; signature = message.result.signature; } if (Date.now() &gt; (constants.NONCE_EXPIRE + nonce)) { return callback(new Error('Message signature expired')); } var target = message.id + nonce; var addr = bitcore.Address.fromPublicKeyHash(Buffer(contact.nodeID, 'hex')); var compactSig; var signobj; try { compactSig = new Buffer(signature, 'base64'); signobj = bitcore.crypto.Signature.fromCompact(compactSig); } catch (err) { return callback(new Error('Signature verification failed')); } var signedmsg = Message(target); var ecdsa = new bitcore.crypto.ECDSA(); ecdsa.hashbuf = signedmsg.magicHash(); ecdsa.sig = signobj; this._pubkeys[contact.nodeID] = ecdsa.toPublicKey(); if (!signedmsg.verify(addr, signature)) { return callback(new Error('Signature verification failed')); } callback(); }; /** * Proxies error events from the underlying transport adapter * @private * @param {Error} error */ Network.prototype._handleTransportError = function(error) { this._logger.error(error.message); }; /** * Setup a PING message to the given contact on an interval * @private * @param {Contact} contact * @param {Number} interval */ Network.prototype._addPingInterval = function(contact, interval) { assert(typeof interval === 'number', 'Invalid interval supplied'); var self = this; if (!this._pingSeeds) { this._pingSeeds = {}; } function pingSeed() { self._transport.send(contact, new kad.Message({ method: 'PING', params: { contact: self._node._self } }), function noop() {}); } this._pingSeeds[contact.nodeID] = setInterval(pingSeed, interval); }; /** * Stop sending PING message to the given contact * @private * @param {Contact} contact */ Network.prototype._removePingInterval = function(contact) { if (!contact) { for (var nodeID in this._pingSeeds) { clearInterval(this._pingSeeds[nodeID]); } } else { clearInterval(this._pingSeeds[contact.nodeID]); } }; /** * Initialize the shard reaper to check for stale contracts and reap shards * @private */ Network.prototype._initShardReaper = function() { var self = this; function startReapInterval() { setInterval( self._manager.clean.bind(self, function() {}), constants.CLEAN_INTERVAL ); } this._logger.info('scanning for expired storage contracts'); this._manager.clean(startReapInterval); }; module.exports = Network; × Search results Close "},"lib_network_protocol.js.html":{"id":"lib_network_protocol.js.html","title":"Source: lib/network/protocol.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/network/protocol.js 'use strict'; var assert = require('assert'); var utils = require('../utils'); var Proof = require('../proof'); var Contract = require('../contract'); var StorageItem = require('../storage/item'); var stream = require('stream'); /** * Defines the Storj protocol methods and mounts on a {@link Network} instance * to handle Storj protocol messages * @constructor * @param {Object} options * @param {Network} options.network - Network instance to bind to */ function Protocol(opts) { if (!(this instanceof Protocol)) { return new Protocol(opts); } assert(typeof opts === 'object' , 'Invalid options supplied'); this._network = opts.network; } /** * Handles OFFER messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleOffer = function(params, callback) { var contract; try { contract = Contract.fromObject(params.contract); } catch (err) { return callback(new Error('Invalid contract format')); } // TODO: Ultimately we will need to create a robust decision engine that will // TODO: allow us to better determine if the received offer is in our best // TODO: interest. For now, we just make sure that we have the data_shard // TODO: from the OFFER and we wish to CONSIGN it. // For now, we just accept any storage offer we get that matches our own... var self = this; var key = contract.get('data_hash'); if (!self._network._pendingContracts[key]) { return callback(new Error('Contract no longer open to offers')); } if (!contract.verify('farmer', params.contact.nodeID)) { return callback(new Error('Invalid signature from farmer')); } contract.sign('renter', self._network._keypair.getPrivateKey()); if (!contract._complete()) { return callback(new Error('Contract is not complete')); } var doConsign = self._network._pendingContracts[key].bind( self._network, params.contact ); delete self._network._pendingContracts[key]; var item = new StorageItem({ hash: key }); item.contracts[params.contact.nodeID] = contract; self._network._manager.save(item, function(err) { if (err) { return callback(err); } callback(null, { contract: contract.toObject() }); doConsign(); }); }; /** * Handles AUDIT messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleAudit = function(params, callback) { var self = this; var shard = new Buffer([]); self._network._manager.load(params.data_hash, function(err, item) { if (err) { return callback(err); } if (item.shard instanceof stream.Writable) { return callback(new Error('Shard not found')); } item.shard.on('data', function(chunk) { shard = Buffer.concat([shard, chunk]); }); item.shard.on('end', function() { var proof = new Proof({ leaves: item.trees[params.contact.nodeID], shard: shard }); callback(null, { proof: proof.prove(params.challenge) }); }); }); }; /** * Handles CONSIGN messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleConsign = function(params, callback) { var self = this; var token = utils.generateToken(); self._network._manager.load(params.data_hash, function(err, item) { if (err) { return callback(err); } var contract = item.contracts[params.contact.nodeID]; var t = Date.now(); item.trees[contract.get('renter_id')] = params.audit_tree; try { assert( t &lt; contract.get('store_end') || t &gt; contract.get('store_begin'), 'Consignment violates contract store time' ); } catch (err) { return callback(err); } self._network._manager.save(item, function(err) { if (err) { return callback(err); } self._network._channel.accept(token, params.data_hash); callback(null, { token: token }); }); }); }; /** * Handles RETRIEVE messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleRetrieve = function(params, callback) { var self = this; var hash = params.data_hash; var token = utils.generateToken(); // TODO: We will need to increment the download count to track payments, as // TODO: well as make sure that the requester is allowed to fetch the shard // TODO: as part of the contract. self._network._manager.load(hash, function(err, item) { if (err) { return callback(err); } self._network._channel.accept(token, item.hash); callback(null, { token: token }); }); }; /** * Returns bound references to the protocol handlers */ Protocol.prototype.handlers = function() { return { OFFER: this._handleOffer.bind(this), AUDIT: this._handleAudit.bind(this), CONSIGN: this._handleConsign.bind(this), RETRIEVE: this._handleRetrieve.bind(this) }; }; module.exports = Protocol; × Search results Close "},"lib_network_transport.js.html":{"id":"lib_network_transport.js.html","title":"Source: lib/network/transport.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/network/transport.js 'use strict'; var inherits = require('util').inherits; var kad = require('kad'); var natupnp = require('nat-upnp').createClient(); var ip = require('ip'); var tunnel = require('localtunnel'); var url = require('url'); /** * Custom HTTP transport adapter * @constructor * @param {kad.Contact} * @param {Object} options * @param {Logger} options.logger * @param {Boolean} options.cors * @param {String} options.tunnelHost */ function Transport(contact, options) { if (!(this instanceof Transport)) { return new Transport(contact, options); } this._tunnelhost = options.tunnelhost; this._noforward = options.noforward; kad.transports.HTTP.call(this, contact, options); } inherits(Transport, kad.transports.HTTP); /** * Opens the transport, trying UPnP to become publicly addressable and falling * back to using a Tunnel * @private * @param {Function} callback */ Transport.prototype._open = function(callback) { var self = this; if (ip.isPublic(self._contact.address) || self._noforward) { return kad.transports.HTTP.prototype._open.call(self, callback); } self._log.warn( 'you are not bound to a public address, trying traversal strategies...' ); self._forwardPort(function(err, ip) { if (err) { self._log.info('attempting to open connection tunnel...'); return tunnel(self._contact.port, { subdomain: self._contact.nodeID.substr(0, 8), host: self._tunnelhost }, function(err, client) { if (err) { self._log.warn( 'failed to tunnel connection, reason: %s', err.message ); return kad.transports.HTTP.prototype._open.call(self, callback); } self._log.info('established tunnel, you are: %s', client.url); var addr = url.parse(client.url); self._tunnel = client; kad.transports.HTTP.prototype._open.call(self, callback); self._contact.address = addr.hostname; self._contact.port = addr.protocol === 'https:' ? 443 : 80; }); } kad.transports.HTTP.prototype._open.call(self, callback); self._contact.address = ip; }); }; /** * Forwards a port and resolves the public IP * @private * @param {Function} callback */ Transport.prototype._forwardPort = function(callback) { var self = this; natupnp.portMapping({ public: self._contact.port, private: self._contact.port, ttl: 0 }, function(err) { if (err) { self._log.warn('could not connect to NAT device via UPnP'); return callback(err); } natupnp.externalIp(function(err, ip) { if (err) { self._log.warn('could not obtain public IP address'); return callback(err); } self._log.info('successfully traversed NAT via UPnP'); callback(null, ip); }); }); }; module.exports = Transport; × Search results Close "},"lib_proof.js.html":{"id":"lib_proof.js.html","title":"Source: lib/proof.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/proof.js 'use strict'; var assert = require('assert'); var MerkleTree = require('mtree'); var utils = require('./utils'); /** * Provides interface for proving possession of a file for an {@link Audit} * @constructor * @param {Object} options * @param {Array} options.leaves - Bottom leaves of the audit merkle tree * @param {Buffer} options.shard - Binary shard data */ function Proof(options) { if (!(this instanceof Proof)) { return new Proof(options); } assert(Array.isArray(options.leaves), 'Merkle leaves must be an array'); assert(Buffer.isBuffer(options.shard), 'Invalid shard supplied'); this._shard = options.shard; this._tree = new MerkleTree( this._generateLeaves(options.leaves), utils.rmd160sha256 ); } /** * Calculate audit response * @param {String} challenge - Challenge string sent by auditor * @returns {Array} result - Challenge response */ Proof.prototype.prove = function(challenge) { var response = utils.rmd160sha256(challenge + this._shard.toString('hex')); var leaf = utils.rmd160sha256(response); var leaves = this._tree.level(this._tree.levels() - 1); var challengenum = leaves.indexOf(leaf); assert(challengenum !== -1, 'Failed to generate proof'); var branches = [response]; for (var i = (this._tree.levels() - 1); i &gt; 0; i--) { var level = this._tree.level(i); if (challengenum % 2 === 0) { branches = [branches, level[challengenum + 1]]; } else { branches = [level[challengenum - 1], branches]; } challengenum = Math.floor(challengenum / 2); } return branches; }; /** * Generates the bottom leaves of the tree to the next power of two * @private * @param {Array} leaves */ Proof.prototype._generateLeaves = function(leaves) { var numEmpty = utils.getNextPowerOfTwo(leaves.length) - leaves.length; var emptyLeaves = []; for (var i = 0; i &lt; numEmpty; i++) { emptyLeaves.push(utils.rmd160sha256('')); } return leaves.concat(emptyLeaves); }; module.exports = Proof; × Search results Close "},"lib_storage_adapter.js.html":{"id":"lib_storage_adapter.js.html","title":"Source: lib/storage/adapter.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/storage/adapter.js 'use strict'; var stream = require('readable-stream'); var assert = require('assert'); var Item = require('./item'); var Contract = require('../contract'); /** * Abstract base class for storage adapter * @constructor */ function StorageAdapter() { if (!(this instanceof StorageAdapter)) { return new StorageAdapter(); } } /** * Calls the implemented {@link StorageAdapter#_get} and validates the result * @param {String} key - Shard hash to get metadata for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.get = function(key, callback) { assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); return this._get(key, callback); }; /** * Calls the implemented {@link StorageAdapter#_put} and validates the input * @param {StorageItem} item - Item to write to storage * @param {Function} callback - Called on complete write */ StorageAdapter.prototype.put = function(item, callback) { assert(item instanceof Item, 'Invalid storage item supplied'); assert(typeof callback === 'function', 'Callback function must be supplied'); for (var nodeID in item.contracts) { if (item.contracts[nodeID] instanceof Contract) { item.contracts[nodeID] = item.contracts[nodeID].toObject(); } } return this._put(item.hash, item, callback); }; /** * Calls the implemented {@link StorageAdapter#_del} * @param {String} key - Shard hash to delete the data for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.del = function(key, callback) { assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); return this._del(key, callback); }; /** * Calls the implemented {@link StorageAdapter#_keys} and returns a readable * stream containing each stored item * @return {ReadableStream} */ StorageAdapter.prototype.createReadStream = function() { var self = this; var keys = null; var current = 0; return new stream.Readable({ objectMode: true, read: function() { var rstream = this; function handleError(err) { rstream.emit('error', err); rstream.push(null); } if (!keys) { return self._keys(function(err, result) { if (err) { return handleError(err); } keys = result; if (!keys[current]) { return rstream.push(null); } self.get(keys[current], function(err, item) { if (err) { return handleError(err); } current++; rstream.push(item); }); }); } if (!keys[current]) { return rstream.push(null); } self.get(keys[current], function(err, item) { if (err) { return handleError(err); } current++; rstream.push(item); }); } }); }; /** * Performs lookup and provides an {@link StorageItem} to the callback * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._get = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Delete the shard data at the given key * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._del = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Stores the {@link StorageItem} * @abstract * @param {String} key - Shard hash * @param {Item} item - Item to store * @param {Function} callback - Called on complete */ StorageAdapter.prototype._put = function(/* item, callback */) { throw new Error('Method not implemented'); }; /** * Returns the hashes of all shards stored * @abstract * @param {Function} callback - Called on complete */ StorageAdapter.prototype._keys = function(/* callback */) { throw new Error('Method not implemented'); }; module.exports = StorageAdapter; × Search results Close "},"lib_storage_adapters_fs.js.html":{"id":"lib_storage_adapters_fs.js.html","title":"Source: lib/storage/adapters/fs.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/storage/adapters/fs.js 'use strict'; var async = require('async'); var inherits = require('util').inherits; var path = require('path'); var fs = require('fs'); var StorageAdapter = require('../adapter'); var StorageItem = require('../item'); var HOME_DIR = process.platform === 'win32' ? process.env.USERPROFILE : process.env.HOME; /* Example Directory Tree ====================== |- &lt;datadir&gt;/ | |- shards/ | | |- &lt;shard_hash&gt;/ | | | |- contracts/ | | | | |- renter_or_farmer_id_1 | | | | |- renter_or_farmer_id_2 | | | |- trees/ | | | | |- renter_or_farmer_id_1 | | | | |- renter_or_farmer_id_1 | | | |- challenges/ | | | | |- farmer_id_1 | | | | |- farmer_id_2 | | | |- meta/ | | | | |- renter_or_farmer_id_1 | | | | |- renter_or_farmer_id_1 | | | |- shard.data */ /** * Implements a file-system based storage adapter * @constructor * @extends {StorageAdapter} * @param {String} datadir - Directory path to store data */ function FSStorageAdapter(datadir) { if (!(this instanceof FSStorageAdapter)) { return new FSStorageAdapter(datadir); } this._datadir = datadir || path.join(HOME_DIR, '.storjnode'); this._sharddir = path.join(this._datadir, 'shards'); if (!fs.existsSync(this._datadir)) { fs.mkdirSync(this._datadir); } if (!fs.existsSync(this._sharddir)) { fs.mkdirSync(this._sharddir); } } inherits(FSStorageAdapter, StorageAdapter); /** * Implements the abstract {@link StorageAdapter#_get} * @private * @param {String} key * @param {Function} callback */ FSStorageAdapter.prototype._get = function(key, callback) { var self = this; var target = path.join(this._sharddir, key); var contracts = path.join(target, 'contracts'); var trees = path.join(target, 'trees'); var challenges = path.join(target, 'challenges'); var meta = path.join(target, 'meta'); var data = { hash: key, shard: null, contracts: null, trees: null, challenges: null, meta: null }; function checkTarget(done) { fs.exists(target, function(exists) { if (exists) { return done(); } done(new Error('Shard data not found')); }); } function getShard(done) { var shardpath = path.join(target, 'shard.data'); fs.exists(shardpath, function(exists) { if (exists &amp;&amp; fs.statSync(shardpath).size) { data.shard = fs.createReadStream(shardpath); } else { data.shard = fs.createWriteStream(shardpath); } done(); }); } function getItemData(done) { async.parallel([ function getContracts(done) { self.__fromDirectory(contracts, function(err, result) { data.contracts = result; if (err) { return done(new Error('Failed to load the shard contracts')); } done(); }); }, function getTrees(done) { self.__fromDirectory(trees, function(err, result) { data.trees = result; if (err) { return done(new Error('Failed to load the shard audit trees')); } done(); }); }, function getChallenges(done) { self.__fromDirectory(challenges, function(err, result) { data.challenges = result; if (err) { return done(new Error('Failed to load the shard audit challenges')); } done(); }); }, function getMeta(done) { self.__fromDirectory(meta, function(err, result) { data.meta = result; if (err) { return done(new Error('Failed to load the shard metadata')); } done(); }); } ], done); } async.series([checkTarget, getShard, getItemData], function(err) { if (err) { return callback(err); } callback(null, new StorageItem(data)); }); }; /** * Implements the abstract {@link StorageAdapter#_put} * @private * @param {String} key * @param {StorageItem} item * @param {Function} callback */ FSStorageAdapter.prototype._put = function(key, item, callback) { var self = this; var target = path.join(this._sharddir, key); var contracts = path.join(target, 'contracts'); var trees = path.join(target, 'trees'); var challenges = path.join(target, 'challenges'); var meta = path.join(target, 'meta'); var directories = [target, contracts, trees, challenges, meta]; function checkTarget(done) { async.eachSeries(directories, function(dirname, next) { fs.exists(dirname, function(exists) { if (exists) { return next(); } fs.mkdir(dirname, function(err) { if (err) { return next(err); } next(); }); }); }, done); } function writeItemData(done) { async.parallel([ function writeContracts(done) { self.__toDirectory(contracts, item.contracts, done); }, function writeTrees(done) { self.__toDirectory(trees, item.trees, done); }, function writeChallenges(done) { self.__toDirectory(challenges, item.challenges, done); }, function writeMeta(done) { self.__toDirectory(meta, item.meta, done); } ], done); } async.series([checkTarget, writeItemData], function(err) { if (err) { return callback(new Error('Failed to write shard data')); } callback(null); }); }; /** * Implements the abstract {@link StorageAdapter#_del} * @private * @param {String} key * @param {Function} callback */ FSStorageAdapter.prototype._del = function(key, callback) { var target = path.join(this._sharddir, key); var shard = path.join(target, 'shard.data'); fs.exists(shard, function(exists) { if (!exists) { return callback(null); } fs.unlink(shard, callback); }); }; /** * Implements the abstract {@link StorageAdapter#_keys} * @private * @param {Function} callback */ FSStorageAdapter.prototype._keys = function(callback) { fs.readdir(this._sharddir, callback); }; /** * Loads the directory contents as an object where key is the file's basename * and value is the parsed JSON object * @private * @param {String} dirname * @param {Function} callback */ FSStorageAdapter.prototype.__fromDirectory = function(dirname, callback) { var result = {}; function onComplete(err) { if (err) { return callback(err); } callback(null, result); } function loadFile(filename, done) { fs.readFile(path.join(dirname, filename), function(err, buffer) { if (err) { result[path.basename(filename)] = {}; } else { try { result[path.basename(filename)] = JSON.parse(buffer.toString('utf8')); } catch (err) { return done(err); } } done(); }); } fs.readdir(dirname, function(err, contents) { if (err) { return callback(err); } async.each(contents, loadFile, onComplete); }); }; /** * Writes the data object to the supplied directory * @private * @param {String} dirname * @param {Object} data * @param {Function} callback */ FSStorageAdapter.prototype.__toDirectory = function(dirname, data, callback) { var filenames = Object.keys(data); function writeFile(filename, next) { var buffer; try { buffer = new Buffer(JSON.stringify(data[filename])); } catch (err) { return next(err); } fs.writeFile(path.join(dirname, filename), buffer, next); } async.each(filenames, writeFile, callback); }; module.exports = FSStorageAdapter; × Search results Close "},"lib_storage_adapters_ram.js.html":{"id":"lib_storage_adapters_ram.js.html","title":"Source: lib/storage/adapters/ram.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/storage/adapters/ram.js 'use strict'; var inherits = require('util').inherits; var stream = require('stream'); var StorageAdapter = require('../adapter'); var StorageItem = require('../item'); /** * Implements an in-memory storage adapter * @extends {StorageAdapter} * @constructor */ function RAMStorageAdapter() { if (!(this instanceof RAMStorageAdapter)) { return new RAMStorageAdapter(); } this._items = {}; this._shards = {}; } inherits(RAMStorageAdapter, StorageAdapter); /** * Implements the abstract {@link StorageAdapter#_get} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._get = function(key, callback) { var self = this; var result = this._items[key]; if (!result) { return callback(new Error('Shard data not found')); } if (this._shards[key]) { result.shard = new stream.Readable({ read: function() { if (this._finished) { this.push(null); } else { this.push(self._shards[key]); this._finished = true; } } }); } else { result.shard = new stream.Writable({ write: function(data, encoding, next) { self._shards[key] = data; next(); } }); } callback(null, new StorageItem(result)); }; /** * Implements the abstract {@link StorageAdapter#_put} * @private * @param {String} key * @param {StorageItem} item * @param {Function} callback */ RAMStorageAdapter.prototype._put = function(key, item, callback) { this._items[key] = item; callback(); }; /** * Implements the abstract {@link StorageAdapter#_del} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._del = function(key, callback) { delete this._shards[key]; callback(); }; /** * Implements the abstract {@link StorageAdapter#_keys} * @private * @param {Function} callback */ RAMStorageAdapter.prototype._keys = function(callback) { callback(null, Object.keys(this._items)); }; module.exports = RAMStorageAdapter; × Search results Close "},"lib_storage_item.js.html":{"id":"lib_storage_item.js.html","title":"Source: lib/storage/item.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/storage/item.js 'use strict'; var assert = require('assert'); var Contract = require('../contract'); /** * Represents a storage item, including contracts, challengs, the shard itself * along with metadata describing download count, payments, etc * @constructor * @param {Object} data * @param {String|null} data.hash - Shard hash to use as storage key * @param {Stream|null} data.shard - Raw binary blob of shard * @param {Object} data.contracts - Dictionary of nodeID:{@link Contract} * @param {Object} data.trees - Dictionary of nodeID:merkleLeaves * @param {Object} data.challenges - Dictionary of nodeID:privateAuditData * @param {Object} data.meta - Dictionary of arbitrary nodeID:metadata */ function StorageItem(data) { if (!(this instanceof StorageItem)) { return new StorageItem(data); } data = data || {}; this.hash = null; this.shard = null; this.contracts = {}; this.trees = data.trees || {}; this.challenges = data.challenges || {}; this.meta = data.meta || {}; this._init(data); } /** * Initializes the item values with the given data * @private * @param {Object} data * @returns {StorageItem} */ StorageItem.prototype._init = function(data) { assert(typeof data === 'object', 'Invalid item data supplied'); this.shard = data.shard || null; this.hash = data.hash || null; for (var nodeID in data.contracts) { this.contracts[nodeID] = new Contract(data.contracts[nodeID]); } return this; }; module.exports = StorageItem; × Search results Close "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/utils.js /** * @module storj/utils */ 'use strict'; var crypto = require('crypto'); var semver = require('semver'); /** * Returns the SHA-256 hash of the input * @param {String|Buffer} input - Data to hash * @returns {String} */ module.exports.sha256 = function(input) { return crypto.createHash('sha256').update(input).digest('hex'); }; /** * Returns the RIPEMD-160 hash of the input * @param {String|Buffer} input - Data to hash * @returns {String} */ module.exports.rmd160 = function(input) { return crypto.createHash('rmd160').update(input).digest('hex'); }; /** * Returns the RIPEMD-160 SHA-256 hash of this input * @param {String|Buffer} input - Data to hash * @returns {String} */ module.exports.rmd160sha256 = function(input) { return module.exports.rmd160(module.exports.sha256(input)); }; /** * Returns the next power of two number * @param {Number} number * @returns {Number} */ module.exports.getNextPowerOfTwo = function(num) { return Math.pow(2, Math.ceil(Math.log(num) / Math.log(2))); }; /** * Generates a unique token * @returns {String} */ module.exports.generateToken = function() { return module.exports.rmd160sha256(crypto.randomBytes(512)); }; /** * Returns a stringified URL from the supplied contact object * @param {Object} contact * @param {String} contact.address * @param {Number} contact.port * @param {String} contact.nodeID * @returns {String} */ module.exports.getContactURL = function(contact) { return [ 'storj://', contact.address, ':', contact.port, '/', contact.nodeID ].join(''); }; /** * Returns whether or not the supplied semver tag is compatible * @param {String} version - The semver tag from the contact * @returns {Boolean} compatible */ module.exports.isCompatibleVersion = function(version) { var local = require('./version'); var remote = version; var sameMajor = semver.major(local) === semver.major(remote); var sameMinor = semver.minor(local) === semver.minor(remote); var diffs = ['prepatch','preminor','premajor']; if (diffs.indexOf(semver.diff(remote, local)) !== -1) { return false; } else if (semver.major(local) === 0 &amp;&amp; sameMajor) { return sameMinor; } else { return sameMajor; } }; × Search results Close "},"lib_verification.js.html":{"id":"lib_verification.js.html","title":"Source: lib/verification.js","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Source: lib/verification.js 'use strict'; var assert = require('assert'); var utils = require('./utils'); /** * Interface for verifying the result of an audit proof * @constructor * @param {Array} proof - The result of {@link Proof#prove} */ function Verification(proof) { if (!(this instanceof Verification)) { return new Verification(proof); } assert(Array.isArray(proof), 'Proof must be an array'); this._proof = proof; } /** * Extracts the challenge response from the proof * @private * @param {Array} response - Challenge response received from farmer * @returns {String} leaf */ Verification.prototype._getChallengeResponse = function(tuple) { var data = tuple || this._proof; if (data.length === 1) { return utils.rmd160sha256(data[0]); } if (Array.isArray(data[0])) { return this._getChallengeResponse(data[0]); } else { return this._getChallengeResponse(data[1]); } }; /** * Verifies the proof given the merkle root and tree depth * @param {String} root - Merkle root * @param {Number} totaldepth - Depth of merkle tree * @returns {Array} result - Array with expected result and verified result */ Verification.prototype.verify = function(root, totaldepth) { function _collapse(proof, leaf, depth) { if (depth === 0) { assert(proof.length === 1, 'Invalid proof structure'); assert(utils.rmd160sha256(proof[0]) === leaf, 'Invalid proof value'); return leaf; } assert(proof.length === 2, 'Invalid proof structure'); var hashL, hashR; if (Array.isArray(proof[0])) { hashL = _collapse(proof[0], leaf, depth - 1); } else { hashL = proof[0]; } if (Array.isArray(proof[1])) { hashR = _collapse(proof[1], leaf, depth - 1); } else { hashR = proof[1]; } return utils.rmd160sha256(hashL + hashR); } return [ _collapse(this._proof, this._getChallengeResponse(), totaldepth - 1), root ]; }; module.exports = Verification; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Modules Classes Audit Contract DataChannelClient DataChannelServer KeyPair Manager Contact Network Protocol Transport Proof StorageAdapter FSStorageAdapter RAMStorageAdapter StorageItem Verification × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Classes Classes Audit Contract DataChannelClient DataChannelServer KeyPair Manager Contact Network Protocol Transport Proof StorageAdapter FSStorageAdapter RAMStorageAdapter StorageItem Verification × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Tutorials Classes Audit Contract DataChannelClient DataChannelServer KeyPair Manager Contact Network Protocol Transport Proof StorageAdapter FSStorageAdapter RAMStorageAdapter StorageItem Verification × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification This package exposes a module that provides all of the tools needed to integrate with the Storj network. Complete documentation can be found here. Quick StartInstall locally as user with NPM: npm install storj --saveImport the storj module, generate a key pair, configure your persistence layer, and join the network in just a few lines of code: var storj = require('storj'); var keypair = new storj.KeyPair(/* existing_key */); var store = new storj.FSStorageAdapter('/path/to/datadir'); var manager = new storj.Manager(store); var network = new storj.Network({ keypair: keypair, manager: manager, contact: { address: 'ip.or.hostname', port: 4000 }, seeds: [ 'storj://api.metadisk.org:8443/593844dc7f0076a1aeda9a6b9788af17e67c1052' ], loglevel: 3, datadir: '/path/to/datadir', farmer: [] }); network.join(function(err) { if (err) { return console.log('Failed to join network, reason: %s', err.message); } console.log('Connected to the Storj network!'); });LicenseStorj Core - Implementation of the Storj protocol for Node.js Copyright (C) 2016 Storj Labs, Inc This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program. If not, see http://www.gnu.org/licenses/. × Search results Close "},"DataChannelServer.html":{"id":"DataChannelServer.html","title":"Class: DataChannelServer","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: DataChannelServer DataChannelServer new DataChannelServer(options) Creates a data channel server for sending and receiving consigned file shards Parameters: Name Type Description options Object Properties Name Type Description transport Transport Transport adapter from Network manager Manager The Manager from Network logger kad.Logger Logger to use from Network ttl Number Close after idle for this length of time Source: lib/datachannel/server.js, line 23 Methods accept(token, filehash) Begin accepting data for the given file hash and token Parameters: Name Type Description token String The authorization token created for transfer filehash String The shard hash to allow for the token Source: lib/datachannel/server.js, line 53 reject(token) Stop accepting data for the given token Parameters: Name Type Description token String The authorization token created for transfer Source: lib/datachannel/server.js, line 64 close() Closes the data channel and disconnects all clients Source: lib/datachannel/server.js, line 79 × Search results Close "},"module-storj.html":{"id":"module-storj.html","title":"Module: storj","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Module: storj Source: index.js, line 1 Members &lt;static&gt; Transport Transport Source: index.js, line 13 &lt;static&gt; Contact Contact Source: index.js, line 16 &lt;static&gt; DataChannelClient DataChannelClient Source: index.js, line 19 &lt;static&gt; DataChannelServer DataChannelServer Source: index.js, line 22 &lt;static&gt; Protocol Protocol Source: index.js, line 25 &lt;static&gt; Contract Contract Source: index.js, line 28 &lt;static&gt; Audit Audit Source: index.js, line 31 &lt;static&gt; Proof Proof Source: index.js, line 34 &lt;static&gt; Verification Verification Source: index.js, line 37 &lt;static&gt; Manager Manager Source: index.js, line 40 &lt;static&gt; StorageAdapter StorageAdapter Source: index.js, line 43 &lt;static&gt; FSStorageAdapter FSStorageAdapter Source: index.js, line 46 &lt;static&gt; RAMStorageAdapter RAMStorageAdapter Source: index.js, line 49 &lt;static&gt; StorageItem StorageItem Source: index.js, line 52 &lt;static&gt; KeyPair KeyPair Source: index.js, line 55 &lt;static&gt; constants constants Source: index.js, line 58 &lt;static&gt; utils utils Source: index.js, line 61 &lt;static&gt; Network Network Source: index.js, line 10 × Search results Close "},"Audit.html":{"id":"Audit.html","title":"Class: Audit","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: Audit Audit new Audit(options) Represents an auditing interface using a precomputed merkle tree Parameters: Name Type Description options Object Properties Name Type Description audits Number Total number of challenges to generate shard Buffer Data to create audit challenges for Source: lib/audit.js, line 17 Methods getPublicRecord() Returns the bottom leaves of the merkle tree for sending to farmer Source: lib/audit.js, line 45 Returns: leaves - Bottom merkle leaves of audit tree Type Array getPrivateRecord() Returns the challenges, the tree depth, and merkle root Source: lib/audit.js, line 53 Returns: challenge - Private audit record with challenges Type Object × Search results Close "},"module-storj_constants.html":{"id":"module-storj_constants.html","title":"Module: storj/constants","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Module: storj/constants Source: lib/constants.js, line 1 Members &lt;inner, constant&gt; PREFIX :Number NodeID prefix (same as bitcoin) Type: Number Source: lib/constants.js, line 8 &lt;inner, constant&gt; NONCE_EXPIRE :Number Time to honor a signed message Type: Number Source: lib/constants.js, line 10 &lt;inner, constant&gt; AUDIT_BYTES :Number Number of bytes for audit challenge Type: Number Source: lib/constants.js, line 12 &lt;inner, constant&gt; CLEAN_INTERVAL :Number Interval for reaping stale shards Type: Number Source: lib/constants.js, line 14 &lt;inner, constant&gt; OPCODE_DEG_LOW :Number Opcode for low criteria degree Type: Number Source: lib/constants.js, line 16 &lt;inner, constant&gt; OPCODE_DEG_MED :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js, line 18 &lt;inner, constant&gt; OPCODE_DEG_HIGH :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js, line 20 × Search results Close "},"Contract.html":{"id":"Contract.html","title":"Class: Contract","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: Contract Contract new Contract(contract, criteria) Represents a storage contract between a renter and a farmer Parameters: Name Type Description contract Object Properties Name Type Description type String Unique identifier for the contract renter_id String Node ID of the renter renter_signature String Renter's cryptographic signature farmer_id String Node ID of the farmer farmer_signature String Farmer's cryptographic signature data_size Number Number of bytes to store data_hash String RIPEMD-160 SHA-256 hash of the data store_begin Number UNIX timestamp to start contract store_end Number UNIX timestamp to end the contract audit_count Number Number of audits renter will perform payment_storage_price Number Total price for storage payment_download_price Number Price per download payment_destination String Bitcoin address to send funds criteria Object Properties Name Type Description size Number Criteria degree OPCODE duration Number Criteria degree OPCODE availability Number Criteria degree OPCODE speed Number Criteria degree OPCODE Version: 0 Source: lib/contract/index.js, line 37 Members &lt;static&gt; Schema Defines the JSON Schema of a Contract Source: lib/contract/index.js, line 54 &lt;static&gt; DEFAULTS Defines some default properties of a Contract Source: lib/contract/index.js, line 60 &lt;static&gt; CRITERIA Defines some default criteria of a Contract Source: lib/contract/index.js, line 80 &lt;static&gt; MATRIX Defines the criteria matrix for a Contract Source: lib/contract/index.js, line 91 Methods sign(actor, secret) Signs the contract as the given actor Parameters: Name Type Description actor String One of 'farmer' or 'renter' secret Buffer ECDSA private key Source: lib/contract/index.js, line 226 Returns: signature Type String verify(actor, pubkeyhash) Verify the contract signature for the given actor Parameters: Name Type Description actor String One of 'farmer' or 'renter' pubkeyhash Buffer ECDSA nodeID Source: lib/contract/index.js, line 240 Returns: validity Type Boolean update(fields) Applies the provided fields to the contract and validates it Parameters: Name Type Description fields Object Contract properties to update Source: lib/contract/index.js, line 253 Returns: self Type Contract get(field_name) Returns the value for the given contract property Parameters: Name Type Description field_name String Contract property to get Source: lib/contract/index.js, line 266 Returns: value Type String | Number | null set(field_name) Sets the contract property to the given value Parameters: Name Type Description field_name String Contract property to get Source: lib/contract/index.js, line 275 Returns: value Type String | Number | null getHash() Calculates the SHA-256 hash of the serialized contract Source: lib/contract/index.js, line 288 Returns: Type Buffer getTopicBuffer() Return OPCODE byte sequence for contract publication topic Source: lib/contract/index.js, line 296 Returns: Type Buffer getTopicString() Return OPCODE byte sequence for contract publication topic as hex string Source: lib/contract/index.js, line 304 Returns: Type String toObject() Converts the contract to a plain object Source: lib/contract/index.js, line 312 Returns: Type Object toJSON() Converts the contract to JSON string Source: lib/contract/index.js, line 320 Returns: Type String toBuffer() Converts the contract to Buffer Source: lib/contract/index.js, line 328 Returns: Type Buffer &lt;static&gt; fromObject(object) Creates a contract from a plain object Parameters: Name Type Description object Object Dictionary of contract data Source: lib/contract/index.js, line 337 Returns: Type Contract &lt;static&gt; fromJSON(json) Creates a contract from a JSON string Parameters: Name Type Description json String JSON encoded contract Source: lib/contract/index.js, line 346 Returns: Type Contract &lt;static&gt; fromBuffer(buffer) Creates a contract from a Buffer Parameters: Name Type Description buffer Buffer Raw binary blob of contract data Source: lib/contract/index.js, line 355 Returns: Type Contract &lt;static&gt; createValidator() Creates a validator function for data against the schema Source: lib/contract/index.js, line 363 Returns: validator Type function &lt;static&gt; createTopic(criteria) Create a topical OPCODE byte sequence from the provided criteria Parameters: Name Type Description criteria Object Properties Name Type Description size Number Criteria degree OPCODE duration Number Criteria degree OPCODE availability Number Criteria degree OPCODE speed Number Criteria degree OPCODE Source: lib/contract/index.js, line 376 Returns: Type Buffer &lt;static&gt; compare(c1, c2) Compares two contracts against each other Parameters: Name Type Description c1 Contract Contract to compare c2 Contract Contract to compare Source: lib/contract/index.js, line 393 Returns: Type Boolean × Search results Close "},"DataChannelClient.html":{"id":"DataChannelClient.html","title":"Class: DataChannelClient","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: DataChannelClient DataChannelClient new DataChannelClient(contact) Creates a data channel client for sending and receiving consigned file shards Parameters: Name Type Description contact Object Properties Name Type Description address String The address of the target farmer port Number The port of the target farmer Source: lib/datachannel/client.js, line 18 Methods retrieve(token, hash) Creates a Readable Stream for the token and hash that receives the data Parameters: Name Type Description token String The RETRIEVE token supplied by the farmer hash String The hash of the data to retrieve Source: lib/datachannel/client.js, line 44 Returns: Type stream.Readable consign(token, data) Creates a Writable Stream for the token and hash that stores the data Parameters: Name Type Description token String The CONSIGN token supplied by the farmer data Buffer The data to store Source: lib/datachannel/client.js, line 81 &lt;static&gt; getChannelURL(contact) Returns the URI of the contact's data channel Parameters: Name Type Description contact Object Source: lib/datachannel/client.js, line 125 × Search results Close "},"KeyPair.html":{"id":"KeyPair.html","title":"Class: KeyPair","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: KeyPair KeyPair new KeyPair(privkey) Represents a ECDSA key pair Parameters: Name Type Description privkey String | Buffer WIF encoded ECDSA private key Source: lib/keypair.js, line 11 Methods getPrivateKey() Returns the private key Source: lib/keypair.js, line 30 Returns: key Type String getPublicKey() Returns the public key Source: lib/keypair.js, line 38 Returns: key Type String getNodeID() Returns the NodeID derived from the public key Source: lib/keypair.js, line 46 Returns: nodeID - RIPEMD160 hash of public key Type String getAddress() Returns the bitcoin address version of the nodeID Source: lib/keypair.js, line 56 Returns: address - Base58 encoded address Type String encrypt(data) Encrypts the data Parameters: Name Type Description data Buffer | String Source: lib/keypair.js, line 67 Returns: Type Buffer decrypt(data) Decrypts the data Parameters: Name Type Description data Buffer | String Source: lib/keypair.js, line 76 Returns: Type Buffer × Search results Close "},"Manager.html":{"id":"Manager.html","title":"Class: Manager","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: Manager Manager new Manager(storage) Interface for managing contracts, shards, and audits Parameters: Name Type Description storage StorageAdapter Storage adapter to use Source: lib/manager.js, line 12 Methods load(hash, callback) Loads the storage Item at the given key Parameters: Name Type Description hash String Shard hash to load data for callback function Called with error or StorageItem Source: lib/manager.js, line 27 save(item, callback) Saves the storage StorageItem at the given key Parameters: Name Type Description item StorageItem The StorageItem to store callback function Called on complete Source: lib/manager.js, line 50 clean(callback) Enumerates all storage contracts and reaps stale data Parameters: Name Type Description callback function Called on complete Source: lib/manager.js, line 61 × Search results Close "},"Contact.html":{"id":"Contact.html","title":"Class: Contact","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: Contact Contact new Contact(options) Represents a Storj contact (or peer) Parameters: Name Type Description options Object Source: lib/network/contact.js, line 12 × Search results Close "},"Network.html":{"id":"Network.html","title":"Class: Network","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: Network Network new Network(options) Storj network interface Parameters: Name Type Description options Object Properties Name Type Description keypair KeyPair Node's cryptographic identity manager Manager Persistence management interface loglevel Number Verbosity level 0 - 4 logger Object Optional logger override seeds Array List of seed URIs to join datadir String Directory path to store data contact Object Properties Name Type Description address String Public node IP or hostname port Number Listening port for RPC farmer Array List of topic strings to subscribe noforward Boolean Flag for skipping traversal strategies Source: lib/network/index.js, line 43 Methods join(callback) Opens the connection to the network Parameters: Name Type Description callback function Called on successful network join Source: lib/network/index.js, line 115 leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Source: lib/network/index.js, line 156 audit(hash, callback) Look up the storage contract by the hash to find the node who has the shard. Look up the appropriate challenge and send it to the node for verification. If successful, invalidate the challenge and pass, otherwise, invalidate the contract. Parameters: Name Type Description hash String RIPEMD-160 SHA-256 hash of the file to audit callback function Called with validity information Source: lib/network/index.js, line 169 retrieve(hash, callback) Look up the storage contract by the hash to find the node who has the shard, then execute a RETRIEVE RPC to the node and return the data as a buffer. Parameters: Name Type Description hash String RIPEMD-160 SHA-256 hash of the file to retrieve callback function Called with an error or the file buffer Source: lib/network/index.js, line 233 store(data, duration, callback) Create a contract from the data and options supplied and publish it on the network. Keep track of the pending contract until it becomes fulfilled by an OFFER, then issue a CONSIGN RPC to the offerer and callback when the data is stored. Parameters: Name Type Description data Buffer Raw binary blob to store duration String String representation of time for `ms` like &quot;2w&quot; callback function Called on successful store Source: lib/network/index.js, line 292 × Search results Close "},"Protocol.html":{"id":"Protocol.html","title":"Class: Protocol","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: Protocol Protocol new Protocol(options) Defines the Storj protocol methods and mounts on a Network instance to handle Storj protocol messages Parameters: Name Type Description options Object Properties Name Type Description network Network Network instance to bind to Source: lib/network/protocol.js, line 17 Methods handlers() Returns bound references to the protocol handlers Source: lib/network/protocol.js, line 186 × Search results Close "},"Transport.html":{"id":"Transport.html","title":"Class: Transport","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: Transport Transport new Transport(contact, options) Custom HTTP transport adapter Parameters: Name Type Description contact kad.Contact options Object Properties Name Type Description logger Logger cors Boolean tunnelHost String Source: lib/network/transport.js, line 19 × Search results Close "},"Proof.html":{"id":"Proof.html","title":"Class: Proof","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: Proof Proof new Proof(options) Provides interface for proving possession of a file for an Audit Parameters: Name Type Description options Object Properties Name Type Description leaves Array Bottom leaves of the audit merkle tree shard Buffer Binary shard data Source: lib/proof.js, line 14 Methods prove(challenge) Calculate audit response Parameters: Name Type Description challenge String Challenge string sent by auditor Source: lib/proof.js, line 35 Returns: result - Challenge response Type Array × Search results Close "},"StorageAdapter.html":{"id":"StorageAdapter.html","title":"Class: StorageAdapter","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: StorageAdapter StorageAdapter new StorageAdapter() Abstract base class for storage adapter Source: lib/storage/adapter.js, line 12 Methods get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Source: lib/storage/adapter.js, line 23 put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Source: lib/storage/adapter.js, line 36 del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Source: lib/storage/adapter.js, line 54 createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Source: lib/storage/adapter.js, line 67 Returns: Type ReadableStream &lt;abstract&gt; _get(key, callback) Performs lookup and provides an StorageItem to the callback Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js, line 127 &lt;abstract&gt; _del(key, callback) Delete the shard data at the given key Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js, line 137 &lt;abstract&gt; _put(key, item, callback) Stores the StorageItem Parameters: Name Type Description key String Shard hash item Item Item to store callback function Called on complete Source: lib/storage/adapter.js, line 148 &lt;abstract&gt; _keys(callback) Returns the hashes of all shards stored Parameters: Name Type Description callback function Called on complete Source: lib/storage/adapter.js, line 157 × Search results Close "},"FSStorageAdapter.html":{"id":"FSStorageAdapter.html","title":"Class: FSStorageAdapter","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: FSStorageAdapter FSStorageAdapter new FSStorageAdapter(datadir) Implements a file-system based storage adapter Parameters: Name Type Description datadir String Directory path to store data Source: lib/storage/adapters/fs.js, line 41 Extends StorageAdapter Methods get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#get Source: lib/storage/adapter.js, line 23 put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Inherited From: StorageAdapter#put Source: lib/storage/adapter.js, line 36 del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Inherited From: StorageAdapter#del Source: lib/storage/adapter.js, line 54 createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Inherited From: StorageAdapter#createReadStream Source: lib/storage/adapter.js, line 67 Returns: Type ReadableStream × Search results Close "},"RAMStorageAdapter.html":{"id":"RAMStorageAdapter.html","title":"Class: RAMStorageAdapter","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: RAMStorageAdapter RAMStorageAdapter new RAMStorageAdapter() Implements an in-memory storage adapter Source: lib/storage/adapters/ram.js, line 13 Extends StorageAdapter Methods get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#get Source: lib/storage/adapter.js, line 23 put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Inherited From: StorageAdapter#put Source: lib/storage/adapter.js, line 36 del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Inherited From: StorageAdapter#del Source: lib/storage/adapter.js, line 54 createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Inherited From: StorageAdapter#createReadStream Source: lib/storage/adapter.js, line 67 Returns: Type ReadableStream × Search results Close "},"StorageItem.html":{"id":"StorageItem.html","title":"Class: StorageItem","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: StorageItem StorageItem new StorageItem(data) Represents a storage item, including contracts, challengs, the shard itself along with metadata describing download count, payments, etc Parameters: Name Type Description data Object Properties Name Type Description hash String | null Shard hash to use as storage key shard Stream | null Raw binary blob of shard contracts Object Dictionary of nodeID:Contract trees Object Dictionary of nodeID:merkleLeaves challenges Object Dictionary of nodeID:privateAuditData meta Object Dictionary of arbitrary nodeID:metadata Source: lib/storage/item.js, line 18 × Search results Close "},"module-storj_utils.html":{"id":"module-storj_utils.html","title":"Module: storj/utils","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Module: storj/utils Source: lib/utils.js, line 1 Methods &lt;static&gt; sha256(input) Returns the SHA-256 hash of the input Parameters: Name Type Description input String | Buffer Data to hash Source: lib/utils.js, line 15 Returns: Type String &lt;static&gt; rmd160(input) Returns the RIPEMD-160 hash of the input Parameters: Name Type Description input String | Buffer Data to hash Source: lib/utils.js, line 24 Returns: Type String &lt;static&gt; rmd160sha256(input) Returns the RIPEMD-160 SHA-256 hash of this input Parameters: Name Type Description input String | Buffer Data to hash Source: lib/utils.js, line 33 Returns: Type String &lt;static&gt; getNextPowerOfTwo(number) Returns the next power of two number Parameters: Name Type Description number Number Source: lib/utils.js, line 42 Returns: Type Number &lt;static&gt; generateToken() Generates a unique token Source: lib/utils.js, line 50 Returns: Type String &lt;static&gt; getContactURL(contact) Returns a stringified URL from the supplied contact object Parameters: Name Type Description contact Object Properties Name Type Description address String port Number nodeID String Source: lib/utils.js, line 62 Returns: Type String &lt;static&gt; isCompatibleVersion(version) Returns whether or not the supplied semver tag is compatible Parameters: Name Type Description version String The semver tag from the contact Source: lib/utils.js, line 73 Returns: compatible Type Boolean × Search results Close "},"Verification.html":{"id":"Verification.html","title":"Class: Verification","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Class: Verification Verification new Verification(proof) Interface for verifying the result of an audit proof Parameters: Name Type Description proof Array The result of Proof#prove Source: lib/verification.js, line 11 Methods verify(root, totaldepth) Verifies the proof given the merkle root and tree depth Parameters: Name Type Description root String Merkle root totaldepth Number Depth of merkle tree Source: lib/verification.js, line 47 Returns: result - Array with expected result and verified result Type Array × Search results Close "},"tutorial-contract-topics.html":{"id":"tutorial-contract-topics.html","title":"Tutorial: Publishing Storage Contracts","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Publishing Storage Contracts Nodes solicit storage contracts with the network by publishing information about their storage requirements as outlined in Protocol Specification. Storj implements a distributed publish/subscribe system based on an algorithm called Quasar. Quasar works by allowing nodes to advertise topics of interest to their neighbors and keeping a record of these topics in their neighborhood by storing them in an attenuated bloom filter. Each node has a view of the topics in which their neighbors are interested up to 3 hops away. By the nature of this design, the network forms gravity wells wherein messages of interest are efficiently relayed to nodes that are subscribed to the topic without flooding the network. This approach works well when there is a diverse number of topics. The Storj protocol leverages this by defining a matrix of criteria and descriptors in the form of opcodes representing the degree of which the criteria must be met. CriteriaAt the time of writing, there are 4 criteria column in the topic matrix: Size Duration Availability Speed SizeRefers to the size of the data to be stored. DurationRefers to the length of time for which the data should be stored. AvailabilityRefers to the relative uptime of required by the contract for retrieval of the stored data. SpeedRefers to the throughput desired for retrieval of the stored data. DescriptorsAt the time of writing, there are 3 descriptor opcodes representing low, medium, and high degrees of the criteria. Low: 0x01 Medium: 0x02 High: 0x03 The ranges represented by these descriptors are advisory and may change based on network performance and improvements to hardware over time. ------------------------------------------------------------------------------- | Descriptor | Size | Duration | Availability | Speed | |-----------------|-------------|------------|--------------|-----------------| | Low (`0x01`) | 0mb - 8mb | 0d - 30d | 0% - 50% | 0mbps - 6mbps | |-----------------|-------------|------------|--------------|-----------------| | Medium (`0x02`) | 8mb - 16mb | 30d - 90d | 50% - 80% | 6mbps - 12mbps | |-----------------|-------------|------------|--------------|-----------------| | High (`0x03`) | 16mb - 32mb | 90d - 270d | 80% - 99% | 12mbps - 32mbps | -------------------------------------------------------------------------------Topic FormatWhen publishing or subscribing to a given topic representing the degrees of these criteria, nodes must serialize the opcodes as the hex representation of the bytes in proper sequence. This sequence is defined as: size|duration|availability|speedTo illustrate by example, we can determine the proper topic by analyzing the use case for a given file shard. For instance, if we want to store an asset that is displayed on a web page we can infer the following: The file is small The file may change often, so we should only store it for medium duration The file needs to always be available The file should be transferred quickly Using the matrix, we can determine the proper opcode sequence: [0x01, 0x02, 0x03, 0x03]Serialized as hex, our topic string becomes: 01020303Another example, by contrast, is data backup. Data backup is quite different than the previous example: The file is large (perhaps part of a hard drive backup) The file will not change and should be stored long term The file will not be accessed often, if ever The file does not need to be transferred at high speed Using the matrix, we can determine the proper opcode sequence: [0x03, 0x03, 0x01, 0x01]Serialized as hex, our topic string becomes: 03030101The resulting hex string from the serialized opcode byte sequence should be used as the topic parameter of a PUBLISH RPC as defined in the Protocol Specification. Nodes that are subscribed to the topic will receive the proposed storage contract and may begin contract negotiation with you directly. × Search results Close "},"tutorial-data-channels.html":{"id":"tutorial-data-channels.html","title":"Tutorial: Transferring File Shards","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Transferring File Shards Nodes on the Storj network implement a separate &quot;data channel&quot; for file transfer. Each node must expose a WebSocket server that accepts connections from clients who wish to use the channel for shard consignments and retrieval. The WebSocket server must be accessible at the same path as the JSON-RPC server and is negotiated by sending the Sec-WebSocket-Key header to indicate the connection upgrade as defined by RFC6455. Once the WebSocket connection is open, the client must send a JSON formatted message including the necessary information for the farmer to authorize the data channel. Authorizing a ChannelThe JSON message the client must provide to the farmer before establishing the channel must contain the token provided from a previous CONSIGN or RETRIEVE request, the hash of the data being transferred, and the operation (either PUSH or PULL). { &quot;token&quot;: &quot;5a7ac2dd58377085bad57f864b3a493c288b7c07&quot;, &quot;hash&quot;: &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;operation&quot;: &quot;PUSH&quot; } Authorization message frames must use opcode 0x1 (textual). The receiving farmer must check that she issued the received token within a reasonable amount of time (recommend 2 minutes) and that the supplied hash is associated with that token before sending or receiving any other data. If the authorization fails, the farmer must close the data channel, optionally responding with a status message. Status MessagesFarmers can communicate their status or the result of an operation by sending JSON formatted messages including code (HTTP status code) and message. { &quot;code&quot;: 200, &quot;message&quot;: &quot;Data consigned successfully&quot; }{ &quot;code&quot;: 401, &quot;message&quot;: &quot;Failed to authorize channel&quot; } Status message frames must use opcode 0x1 (textual). Consigning a ShardTo consign a shard (to upload the shard to a farmer), first send the appropriate authorization message. If the farmer does not respond with a failed status message, the channel is open and you can begin sending binary frames. Farmers must track the amount of data received and ensure that it does not exceed the amount defined in the contract. Once the farmer has received the number of bytes defined in the contract, she must verify the data against the hash defined in the contract. If these checks are successfully executed, then the farmer must respond with a positive status message and terminate the channel. Shard message frames must use opcode 0x2 (binary). Example (browser-based)var channel = new WebSocket('&lt;farmer_uri&gt;'); channel.addEventListener('open', function() { channel.send(JSON.stringify({ token: '&lt;token&gt;', hash: '&lt;hash&gt;', operation: 'PUSH' }); channel.send(new Blob([/* ... */])); }); channel.addEventListener('message', function(e) { var data = JSON.parse(e.data); if (data.code &amp;&amp; data.code !== 200) { console.error('Error consigning data:', data.message); } else { console.log('Successfully consigned data!'); } });Retrieving a ShardTo retrieve a shard from a farmer, first send the appropriate authorization message. The farmer will respond with a negative status message frame if you are not authorized and terminate the channel. If authorization is successful, you will immediately begin receiving binary message frames until there is no more data to be transferred - at which point the farmer must terminate the channel. Shard message frames must use opcode 0x2 (binary). Example (browser-based)var channel = new WebSocket('&lt;farmer_uri&gt;'); var fileparts = []; channel.addEventListener('open', function() { channel.send(JSON.stringify({ token: '&lt;token&gt;', hash: '&lt;hash&gt;', operation: 'PULL' }); }); channel.addEventListener('message', function(e) { fileparts.push(e.data); }); channel.addEventListener('close', function() { var file = new Blob(fileparts, { type: '&lt;mime_type&gt;' }); var url = URL.createObjectURL(file); location.href = url; });File ReconstructionIn most cases a complete file is consigned to a number of different farmers. To reconstruct a file, you'll need to know the location of each shard and the concatenation order. With this information, you can open data channels to each of the farmers storing the file's shards (with whatever degree of parallelism suits your needs) and concatenate the binary blobs received in the proper order. × Search results Close "},"tutorial-private-testnet.html":{"id":"tutorial-private-testnet.html","title":"Tutorial: Running a Test Network","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Running a Test Network Setting up a private or partitioned version of the Storj network is very simple. The Storj protocol requires the inclusion of a protocol property nested inside the contact data included in every RPC message. See Protocol Specification for more information on the RPC message format. Protocol Identifier FormatNodes on the Storj network identify the version of the protocol they are running with the use of a semantic version tag. When a node is trying to determine whether or not another node is compatible with her version of the protocol, she checks the following: Is the MAJOR version the same? Is the MAJOR version 0? Is the MINOR version the same? If both nodes are running the same MAJOR version and that version is not 0, then the nodes are compatible. If the MAJOR version is 0, then the nodes are compatible only if the MINOR version is the same. For example: 0.5.1 is compatible with 0.5.3 0.5.1 is not compatible with 0.6.0 1.5.1 is compatible with 1.13.0 2.1.0 is not compatible with 1.13.0 Special IdentifiersThe semantic versions specification also allows for special identifiers by postfixing the version with a hyphen followed by some identifier. This is where the network partitioning magic happens. Let's say, for example, I work for &quot;Widgets Ltd&quot; and I want to deploy a Storj network within the Widgets Ltd private network. Every workstation would run a modified version of storj/farmer or maybe my own custom interface built atop storj/core. I would simply change my Storj-based software to use the version 1.5.0-widgetsltd. The Storj protocol sees this identifies as a strict match and therefore any nodes running this version of the software will only communicate with nodes running the exact protocol identifier. Changing the VersionChanging the version in storj/core is easy as pie. In your code, simply import the module and change the identifier like so: // Import core library var storj = require('storj'); // Modify protocol version storj.version = '1.5.0-widgetsltd'; // Get on with your stuff...This concept applies broadly to deploying a custom Storj network for any purpose. This could be used for a public testnet (x.x.x-testnet) or for the private network example above. × Search results Close "},"tutorial-protocol-spec.html":{"id":"tutorial-protocol-spec.html","title":"Tutorial: Protocol Specification","body":" Storj JS Modules storjstorj/constantsstorj/utils Classes AuditContractDataChannelClientDataChannelServerKeyPairManagerContactNetworkProtocolTransportProofStorageAdapterFSStorageAdapterRAMStorageAdapterStorageItemVerification Tutorials Publishing Storage ContractsTransferring File ShardsRunning a Test NetworkProtocol Specification Protocol Specification Nodes communicate with each other using JSON-RPC 2.0 over HTTPS. This requires farmers (nodes who are contracted by renter to store data) to be publicly addressable and enables access to content from web browsers, mobile phones, and any other devices that speak HTTP (hint: everything). This document outlines the specification for the RPC interface by defining the message structure, required methods, and expected response formats that are needed for a Storj protocol compliant implementation. Request FormatRequests are formed according to the JSON-RPC 2.0 specification and are issued via HTTP POST. The Storj protocol requires the use of named parameters - positional parameters are not supported. Example: { &quot;method&quot;: &quot;PING&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;89cc3ddb4209c6e7e301c10c0257adf4fd85f253&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;3045022100de2e162d017a1e9d0ebfe2a94df3fc847b68281a9882...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The receiving node for this request would then respond with the result, which in the case of a PING message, is simply an acknowledgement that includes the recipient's contact information and required signature and nonce: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }In the event that an error occurs, an error property must be added to the response. You still need to include your contact data in the result property of the response: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;OH GOD THERE'S SO MUCH BLOOD&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Joining the NetworkTo join the Storj network, one must only know the contact information for a single &quot;seed&quot; node. A node's contact information is defined as the following three properties: address - hostname, domain, or IP port - port number on which the node is listening nodeID - hash of the node's public key (see below) protocol - version of the protocol implementation This information can be expressed as a URI in the following format: storj://10.0.0.2:1337/89cc3ddb4209c6e7e301c10c0257adf4fd85f253In addition to knowing this information about the seed, you also will need to know this information about yourself, so that it can be provided to the nodes with which you are communicating. Your &quot;contact card&quot; must be provided as the contact parameter in every message sent (both requests and responses). This is because messages must be signed with your private key and your nodeID is used by recipients to verify two things: That you own the private key corresponding to your claimed nodeID That the message was in fact sent by you and not an attacker In the Storj network, nodes are identified by the hash of the public portion of an ECDSA key pair. Key pairs are generated using curve SECP256K1 and a node's nodeID is the &quot;pubkeyhash&quot;, defined as: RIPEMD160(SHA256(public_key))This pubkeyhash, combined with a message and signature is enough data to reconstruct the complete public key and is used in the Storj network to sign and verify messages. This ensures that nodes are unable to assume the identity of another node by claiming it has the same nodeID. Joining the network begins with a FIND_NODE request sent to one or more known seeds. The request must include a key, contact (you), along with a signature and nonce. FIND_NODEWhen issuing a FIND_NODE request, you provide a key that represents the nodeID of the contact of which you would like to their neighbors. When joining the network, this value is your own nodeID. { &quot;method&quot;: &quot;FIND_NODE&quot;, &quot;params&quot;: { &quot;key&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When a node receives a FIND_NODE RPC message, it must perform a lookup in it's routing table and respond with a nodes array containing the known contacts that are &quot;closest&quot; to the provided key. This is based on the XOR metric as the Storj network uses a Kademlia-based overlay. In addition, if the receiving node is not already aware of the requesting node, it may add the requester to it's own routing table to later inform other requesters. { &quot;result&quot;: { &quot;nodes&quot;: [ { &quot;address&quot;: &quot;10.0.0.4&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, { &quot;address&quot;: &quot;10.0.0.5&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, { &quot;address&quot;: &quot;10.0.0.6&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of the FIND_NODE response, the node attempting to join the network may iteratively send the same FIND_NODE request to contacts that have been newly added to the routing table to build out a wider view of the network. Once the joining node is satisfied with the size of the routing table (or there are no more nodes to discover), this is considered a successful join. Soliciting StorageOnce a node has a sufficiently complete routing table and view of the network, it's time to buddy up with it's neighbors to cooperate in the sharing and relay of publications. A &quot;publication&quot; is essentially a request for storage. When a node in the network wishes to store some data, it notifies it's closest neighbors who, if interested, will respond to negotiate a storage contract. If the neighbors are not offering storage or do not wish to fulfill the terms of the storage contract, they must check to see if any of their neighbors are and forward the publication to them. If no known neighbors are interested, then the publication is sent to a random node in that neighbor's routing table and the process repeats until an interested node fulfills the contract. SUBSCRIBEIn order to know what publications in which your neighbors are interested, we select the 3 nodes in our routing table that are identified by a nodeID that is closest to ours and we issue a SUBSCRIBE message to each of them: { &quot;method&quot;: &quot;SUBSCRIBE&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }To properly handle a SUBSCRIBE message, the recipient must respond with an attenuated bloom filter, with a size 160 bits and a depth of 3. This data structure represents 3 sets of topics to which the recipient's neighbors are subscribed 3 &quot;hops&quot; away. { &quot;result&quot;: { &quot;filters&quot;: [ &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When the original requesting node receives this response, it must update it's local attenuated bloom filter to reflect this response, starting at it's filter at index 1 (since index 0 is reserved for topic to which the node itself is interested). UPDATEAfter the requester updates it's local view of it's neighbor's publication subscriptions, it must in turn update it's neighbors with it's own publication subscriptions by providing it's own attenuated bloom filter: { &quot;method&quot;: &quot;UPDATE&quot;, &quot;params&quot;: { &quot;filters&quot;: [ &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }This method is essentially the &quot;push&quot; version of the SUBSCRIBE message, where instead of providing subscription information as a response, we provide it as a request. Whenever a node subscribes to a new publication topic, it should initiate another SUBSCRIBE/UPDATE loop with it's neighbors to ensure that it may cooperate in publication relay effectively. PUBLISHOnce a node has a view of the publications to which it's neighbors are subscribed, it is capable of issuing a PUBLISH message containing a topic and some content. This message is sent to the node's nearest neighbors, who then relay it to their neighbors based upon their own view of nearby subscriptions. The topic property and the corresponding contents data is arbitrary, but this mechanism is used for publishing &quot;asks&quot; for storage contracts. In this case, the topic is equal to the Contract type and the contents is equal to the proposed contract itself. See Publishing Storage Contracts for more information on how to choose a valid contract type for your storage needs. { &quot;method&quot;: &quot;PUBLISH&quot;, &quot;params&quot;: { &quot;uuid&quot;: &quot;7f0c40a2-e465-4f3e-b617-3d53460e34f7&quot;, &quot;topic&quot;: &quot;02010303&quot;, &quot;contents&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: null, &quot;farmer_id&quot;: null, &quot;farmer_signature&quot;: null, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: null }, &quot;publishers&quot;: [ &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; ], &quot;ttl&quot;: 1455228597837, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of a PUBLISH message, a node must first check to make sure it has not already received the publication. This is done by caching the uuid of received publications. If the node has already seen the publication, it should respond with an error message indicating such. The node should also make sure that the publication has not expired by checking the ttl against the current UNIX time. If the node has not previously seen the publication and the message has not expired, then it must check to see if the publication topic is of interest to itself by testing it's attenuated bloom filter at index 0 for the topic. If the node is interested in the publication, it may take action accordingly. In the case of storage contract, the node may begin communicating directly with the original publisher to finalize the contract. Regardless of whether or not the node is interested in the publication, it should acknowledge receipt of the publication to the forwarder: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Then, it must append negative information to the publication message by adding it's own nodeID to the publishers property. Once the message has been updated with the negative information, the node must check it's attenuated bloom filter to see if any of it's neighbors are also interested and, if so, forward the message along to them. If no neighbors are interested, the node must select a random contact from the routing table and forward the message to that contact. Negotiating Storage ContractsWhen a node receives a contract proposal in the form of a PUBLISH message and that proposal meets the recipient's criteria, it can send an OFFER message to the original publisher. OFFERThe offer message must contain the original contract, supplemented with the information that is required of the offering node, which at minimum must include farmer_id, farmer_signature, and payment_destination. The *_signature property value should be the hex-encoded signature of the JSON string representation of the contract, minus both signature fields and with keys sorted alphanumerically. In addition to these fields, the offering node (or &quot;farmer&quot;) may modify the other fields in the contract to their liking if they wish to counter the original offer: { &quot;method&quot;: &quot;OFFER&quot;, &quot;params&quot;: { &quot;contract&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: null, &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The receiving node must check the offer and determine whether or not the modified contract terms are satisfactory. If so, it may finalize the contract by adding it's signature to the renter_signature field: { &quot;result&quot;: { &quot;contract&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: &quot;304402202ccc152ee81fbff7e802c290cabea0c62384bb12...&quot;, &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Alternatively, the receiving node may counter the offer by modifying any of the fields and returning those in the response. The farmer must check the contract against it's signature to determine if the terms of the contract have been changed. This counter offer loop can continue until one party abandons the offer loop or until both parties have signed the same contract. Once a contract has been finalized, each node should store a copy locally that can be keyed by the data_hash. Executing a Storage ContractOnce a storage contract has been signed by both parties, the renter may execute the terms of the contract by issuing a CONSIGN message to the farmer. The purpose of this message is to deliver the data referenced by the contract for the farmer to store. The consign message must contain the hex-encoded data_shard itself, the contract_hash, as well as an audit_tree that contains the bottom leaves of the audit strategy's merkle tree (see Auditing a Storage Contract below). { &quot;method&quot;: &quot;CONSIGN&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;audit_tree&quot;: [ &quot;40a98e19c298631cba19d6c19691360ce08ccf36&quot;, &quot;02f0d971096305e797da9165cd50d4d1bb19590b&quot;, &quot;a44ad75d8aa118cdd73df77ae2543d3e87f94576&quot;, &quot;d84e8bfac28a98df418d0c3029f77a4d9f338e9e&quot;, &quot;7408bb5b0a9eefa56f3234fc83d2423f76c4b857&quot;, &quot;d1b71886c910d34b31cee9e23316abded9ef3fe0&quot;, &quot;0ac89686a12e26aaf952180c0fec5373224c4c1e&quot;, &quot;98c304116e7eb89839ff6c96202eb4c3cbdaf8e0&quot;, &quot;c7937b8a1be9da426e076eff70c5b4edf8a66270&quot;, &quot;c6c2c5cdafb99e4d62185d42e59522d15c33d676&quot;, &quot;1f87ca29e75944aa36e676b3ddf27e49a8ca4fe2&quot;, &quot;8585e356a517535b8a36ec9222b955c5b61a5227&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of a CONSIGN message, the farmer must lookup the reference contract by the supplied data_hash and verify that the renter is authorized to store the data and that the number of items in the audit_tree is equal to the next power of 2 of the audit_count supplied in the original contract. Once verified, the farmer must respond with a generated token that the renter can use to open a data channel with the farmer (via websocket) to deliver the data as a binary stream. For more information on the Data Channel specification see the tutorial for Transferring File Shards. In addition, the farmer should verify that the current UNIX time is greater than or equal to the agreed upon store_begin and less than the agreed upon store_end. If everything checks out, the farmer must store the consigned data in such a way that it may later be retrieved by it's hash. Once the farmer has done this, it must acknowledge the renter to confirm: { &quot;result&quot;: { &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Auditing a Storage ContractBefore a renter issues a CONSIGN RPC, it must pre-calculate a series of &quot;challenges&quot;, the number of which must equal the audit_count defined in the negotiated contract. A challenge is simply 32 random bytes encoded as hex. The generated challenges must not be shared until the renter wishes to issue an AUDIT request. When issuing a CONSIGN request, the renter must include an audit_tree which contains the bottom leaves of a merkle tree. Each of the bottom leaves of the tree must be equal to the double RIPEMD160(SHA256(challenge + shard)) encoded as hex. In order to ensure that the resulting merkle tree is properly &quot;balanced&quot;, the number of bottom leaves must be equal to the next power of 2 of the audit count. To ensure this, the additional leaves can simply be the double RIPEMD160(SHA256('')) (the same hash function for an audit, but applied to an empty buffer). To audit a farmer is to request proof that it is still honoring the terms of the storage contract without the need to have them supply the entire data_shard. To do this, the renter must supply the farmer with one of the secret pre-calculated challenges: { &quot;method&quot;: &quot;AUDIT&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;challenge&quot;: &quot;6290bb9e1766bf3fc00eea3bb14146925611026d453e1aa95c32973f8baa5c98&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of an AUDIT request, the farmer must lookup the data_shard by the supplied data_hash, then calculate the single RIPEMD160(SHA256(challenge + shard)). The result of this operation should hash again to match one of the items supplied in the audit_tree property of the original CONSIGN request. In addition to supplying this value as proof that the farmer is still honoring the terms of the contract, the farmer must also provide the uncles required to rebuild the merkle tree. This proof response is specified as a series of nested JSON arrays: { &quot;result&quot;: { &quot;proof&quot;: [ [ [ [ [ &quot;6a2f02144c461e178dc4496c263313e64d7a56ab&quot; ], &quot;efb0dfa48813e3289ba8d16e9e23cf1efa1a99fd&quot; ], &quot;dfb8877b84e7a7496a4b08b2aef6ffd02ccbfccc&quot; ], &quot;82c60f546bcaaabeb908c911b1fadb816e039409&quot; ], &quot;5e265b0256cd471c6af22bd66b59ed9242067654&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of the farmer's proof, the renter must verify that the proof is valid by using it to rebuild the merkle tree. See Verification#verify for an implementation example. If the proof is verified successfully, then the renter is expected to issue a payment to the payment_destination defined in the original contract. The amount of the payment should be equal to: (payment_storage_price / audit_count) + (payment_download_price * downloads_since_last_audit)If the verification fails then the contract is null and no payment is required. Conversely, if the verification succeeds and the renter does not issue the payment in a timely manner, then the contract is also null and the farmer may decide to cease storage of the data. Downloading Consigned DataWhen a renter wishes to retrieve data that is stored under contract, it can issue a RETRIEVE RPC message that includes the data_hash to the farmer storing the data: { &quot;method&quot;: &quot;RETRIEVE&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }After the recipient of the RETRIEVE message verifies the sender's signature it must lookup the storage contract by the supplied data_hash and verify that the sender is the party with which the contract was negotiated. If all tests pass, then the farmer must respond with a generated token to allow the renter to open a data channel (via websocket) to retrieve the data as a binary stream. After the data shard is delivered successfully, the farmer must increment it's record of the downloads_since_last_audit (which must be reset after the next audit). For more information on the Data Channel specification see the tutorial for Transferring File Shards. { &quot;result&quot;: { &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }In addition, the renter must check the integrity of the returned data_shard by calculating the hash and checking it against the expected data_hash. If the test fails, then this effectively a failed audit and the contract is null. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
